{"version":3,"file":"utils-CqbeJfE1.cjs","names":["event: FlexibleEventData","key: string","fields: string[]","apiService: SentryApiService","organizationSlug: string","dataset: \"errors\" | \"logs\" | \"spans\"","projectId?: string","timeParams?: { statsPeriod?: string; start?: string; end?: string }","customAttributes: Record<string, string>","fieldTypes: Record<string, \"string\" | \"number\">","UserInputError"],"sources":["../src/tools/search-events/utils.ts"],"sourcesContent":["import { tool } from \"ai\";\nimport { z } from \"zod\";\nimport type { SentryApiService } from \"../../api-client\";\nimport { logError } from \"../../logging\";\nimport { UserInputError } from \"../../errors\";\n\n// Type for flexible event data that can contain any fields\nexport type FlexibleEventData = Record<string, unknown>;\n\n// Helper to safely get a string value from event data\nexport function getStringValue(\n  event: FlexibleEventData,\n  key: string,\n  defaultValue = \"\",\n): string {\n  const value = event[key];\n  return typeof value === \"string\" ? value : defaultValue;\n}\n\n// Helper to safely get a number value from event data\nexport function getNumberValue(\n  event: FlexibleEventData,\n  key: string,\n): number | undefined {\n  const value = event[key];\n  return typeof value === \"number\" ? value : undefined;\n}\n\n// Helper to check if fields contain aggregate functions\nexport function isAggregateQuery(fields: string[]): boolean {\n  return fields.some((field) => field.includes(\"(\") && field.includes(\")\"));\n}\n\n// Helper function to fetch custom attributes for a dataset\nexport async function fetchCustomAttributes(\n  apiService: SentryApiService,\n  organizationSlug: string,\n  dataset: \"errors\" | \"logs\" | \"spans\",\n  projectId?: string,\n  timeParams?: { statsPeriod?: string; start?: string; end?: string },\n): Promise<{\n  attributes: Record<string, string>;\n  fieldTypes: Record<string, \"string\" | \"number\">;\n}> {\n  const customAttributes: Record<string, string> = {};\n  const fieldTypes: Record<string, \"string\" | \"number\"> = {};\n\n  try {\n    if (dataset === \"errors\") {\n      // TODO: For errors dataset, we currently need to use the old listTags API\n      // This will be updated in the future to use the new trace-items attributes API\n      const tagsResponse = await apiService.listTags({\n        organizationSlug,\n        dataset: \"events\",\n        project: projectId,\n        statsPeriod: \"14d\",\n        useCache: true,\n        useFlagsBackend: true,\n      });\n\n      for (const tag of tagsResponse) {\n        if (tag.key && !tag.key.startsWith(\"sentry:\")) {\n          customAttributes[tag.key] = tag.name || tag.key;\n        }\n      }\n    } else {\n      // For logs and spans datasets, use the trace-items attributes endpoint\n      const itemType = dataset === \"logs\" ? \"logs\" : \"spans\";\n      const attributesResponse = await apiService.listTraceItemAttributes({\n        organizationSlug,\n        itemType,\n        project: projectId,\n        statsPeriod: \"14d\",\n      });\n\n      for (const attr of attributesResponse) {\n        if (attr.key) {\n          customAttributes[attr.key] = attr.name || attr.key;\n          // Track field type from the attribute response with validation\n          if (attr.type && (attr.type === \"string\" || attr.type === \"number\")) {\n            fieldTypes[attr.key] = attr.type;\n          }\n        }\n      }\n    }\n  } catch (error) {\n    // If we can't get custom attributes, continue with just common fields\n    logError(error, {\n      search_events: {\n        dataset,\n        organizationSlug,\n        operation:\n          dataset === \"errors\" ? \"listTags\" : \"listTraceItemAttributes\",\n        ...(dataset !== \"errors\" && {\n          itemType: dataset === \"logs\" ? \"logs\" : \"spans\",\n        }),\n      },\n    });\n  }\n\n  return { attributes: customAttributes, fieldTypes };\n}\n\n/**\n * Create a tool for the agent to query available attributes by dataset\n */\nexport function createDatasetAttributesTool(\n  apiService: SentryApiService,\n  organizationSlug: string,\n  projectId?: string,\n) {\n  return tool({\n    description:\n      \"Query available attributes and fields for a specific Sentry dataset to understand what data is available\",\n    parameters: z.object({\n      dataset: z\n        .enum([\"spans\", \"errors\", \"logs\"])\n        .describe(\"The dataset to query attributes for\"),\n    }),\n    execute: async ({ dataset }) => {\n      try {\n        const {\n          BASE_COMMON_FIELDS,\n          DATASET_FIELDS,\n          RECOMMENDED_FIELDS,\n          NUMERIC_FIELDS,\n        } = await import(\"./config\");\n\n        // Get custom attributes for this dataset\n        const { attributes: customAttributes, fieldTypes } =\n          await fetchCustomAttributes(\n            apiService,\n            organizationSlug,\n            dataset,\n            projectId,\n          );\n\n        // Combine all available fields\n        const allFields = {\n          ...BASE_COMMON_FIELDS,\n          ...DATASET_FIELDS[dataset],\n          ...customAttributes,\n        };\n\n        const recommendedFields = RECOMMENDED_FIELDS[dataset];\n\n        // Combine field types from both static config and dynamic API\n        const allFieldTypes = { ...fieldTypes };\n        const staticNumericFields = NUMERIC_FIELDS[dataset] || new Set();\n        for (const field of staticNumericFields) {\n          allFieldTypes[field] = \"number\";\n        }\n\n        return `Dataset: ${dataset}\n\nAvailable Fields (${Object.keys(allFields).length} total):\n${Object.entries(allFields)\n  .slice(0, 50) // Limit to first 50 to avoid overwhelming the agent\n  .map(([key, desc]) => `- ${key}: ${desc}`)\n  .join(\"\\n\")}\n${Object.keys(allFields).length > 50 ? `\\n... and ${Object.keys(allFields).length - 50} more fields` : \"\"}\n\nRecommended Fields for ${dataset}:\n${recommendedFields.basic.map((f) => `- ${f}`).join(\"\\n\")}\n\nField Types (CRITICAL for aggregate functions):\n${Object.entries(allFieldTypes)\n  .slice(0, 30) // Show more field types since this is critical for validation\n  .map(([key, type]) => `- ${key}: ${type}`)\n  .join(\"\\n\")}\n${Object.keys(allFieldTypes).length > 30 ? `\\n... and ${Object.keys(allFieldTypes).length - 30} more fields` : \"\"}\n\nIMPORTANT: Only use numeric aggregate functions (avg, sum, min, max, percentiles) with numeric fields. Use count() or count_unique() for non-numeric fields.\n\nUse this information to construct appropriate queries for the ${dataset} dataset.`;\n      } catch (error) {\n        if (error instanceof UserInputError) {\n          return `Error: ${error.message}`;\n        }\n        throw error;\n      }\n    },\n  });\n}\n"],"mappings":"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"}