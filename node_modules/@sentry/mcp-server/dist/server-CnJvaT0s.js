import { MCP_SERVER_NAME } from "./constants-Fe-4NTUo.js";
import { ConfigurationError, UserInputError } from "./errors-D_R568zP.js";
import { ApiError } from "./client-MaVV1gVC.js";
import { logError } from "./logging-tGU_SYcA.js";
import { tools_default } from "./tools-B0wbxDty.js";
import { RESOURCES, isTemplateResource } from "./resources-jcFoc4JU.js";
import { PROMPT_DEFINITIONS } from "./promptDefinitions-DF8nuJVq.js";
import { PROMPT_HANDLERS } from "./prompts-CYcvIxWR.js";
import { LIB_VERSION } from "./version-DvjTvYJs.js";
import { setTag, setUser, startNewTrace, startSpan } from "@sentry/core";

//#region src/server.ts
/**
* Type guard to identify Sentry API errors.
*/
function isApiError(error) {
	return error instanceof ApiError;
}
/**
* Type guard to identify user input validation errors.
*/
function isUserInputError(error) {
	return error instanceof UserInputError;
}
/**
* Type guard to identify configuration errors.
*/
function isConfigurationError(error) {
	return error instanceof ConfigurationError;
}
/**
* Formats errors for LLM consumption with appropriate telemetry handling.
*
* **Error Types:**
* - User Input Errors: Clear guidance without telemetry
* - Configuration Errors: Configuration guidance without telemetry
* - API Errors: Enhanced messaging with HTTP status context
* - System Errors: Full telemetry capture with event IDs
*
* @example User Input Error Response
* ```markdown
* **Input Error**
*
* It looks like there was a problem with the input you provided.
* Organization slug is required. Please provide an organizationSlug parameter.
* You may be able to resolve the issue by addressing the concern and trying again.
* ```
*
* @example Configuration Error Response
* ```markdown
* **Configuration Error**
*
* There appears to be a configuration issue with your setup.
* Unable to connect to sentry.invalid.com - Hostname not found. Verify the URL is correct.
* Please check your environment configuration and try again.
* ```
*/
async function logAndFormatError(error) {
	if (isUserInputError(error)) return [
		"**Input Error**",
		"It looks like there was a problem with the input you provided.",
		error.message,
		`You may be able to resolve the issue by addressing the concern and trying again.`
	].join("\n\n");
	if (isConfigurationError(error)) return [
		"**Configuration Error**",
		"There appears to be a configuration issue with your setup.",
		error.message,
		`Please check your environment configuration and try again.`
	].join("\n\n");
	if (isApiError(error)) {
		const eventId$1 = error.status >= 500 ? logError(error) : void 0;
		return [
			"**Error**",
			`There was an HTTP ${error.status} error with your request to the Sentry API.`,
			`${error.message}`,
			eventId$1 ? `**Event ID**: ${eventId$1}` : "",
			`You may be able to resolve the issue by addressing the concern and trying again.`
		].filter(Boolean).join("\n\n");
	}
	const eventId = logError(error);
	return [
		"**Error**",
		"It looks like there was a problem communicating with the Sentry API.",
		"Please report the following to the user for the Sentry team:",
		`**Event ID**: ${eventId}`,
		process.env.NODE_ENV !== "production" ? error instanceof Error ? error.message : String(error) : ""
	].join("\n\n");
}
/**
* Extracts MCP request parameters for OpenTelemetry attributes.
*
* @example Parameter Transformation
* ```typescript
* const input = { organizationSlug: "my-org", query: "is:unresolved" };
* const output = extractMcpParameters(input);
* // { "mcp.request.argument.organizationSlug": "\"my-org\"", "mcp.request.argument.query": "\"is:unresolved\"" }
* ```
*/
function extractMcpParameters(args) {
	return Object.fromEntries(Object.entries(args).map(([key, value]) => {
		return [`mcp.request.argument.${key}`, JSON.stringify(value)];
	}));
}
/**
* Creates a telemetry wrapper for regular URI resource handlers.
* Captures URI access and user context for observability.
*/
function createResourceHandler(resource, context) {
	return async (uri, extra) => {
		return await startNewTrace(async () => {
			return await startSpan({
				name: `resources/read ${resource.name}`,
				attributes: {
					"mcp.resource.name": resource.name,
					"mcp.resource.uri": uri.toString(),
					...context.mcpClientName && { "mcp.client.name": context.mcpClientName },
					...context.mcpClientVersion && { "mcp.client.version": context.mcpClientVersion },
					...context.mcpProtocolVersion && { "mcp.protocol.version": context.mcpProtocolVersion },
					"mcp.server.name": "Sentry MCP",
					"mcp.server.version": LIB_VERSION
				}
			}, async () => {
				if (context.userId) setUser({ id: context.userId });
				if (context.clientId) setTag("client.id", context.clientId);
				return resource.handler(uri, extra);
			});
		});
	};
}
/**
* Creates a telemetry wrapper for URI template resource handlers.
* Captures template parameters and user context for observability.
*/
function createTemplateResourceHandler(resource, context) {
	return async (uri, variables, extra) => {
		return await startNewTrace(async () => {
			return await startSpan({
				name: `resources/read ${resource.name}`,
				attributes: {
					"mcp.resource.name": resource.name,
					"mcp.resource.uri": uri.toString(),
					...context.mcpClientName && { "mcp.client.name": context.mcpClientName },
					...context.mcpClientVersion && { "mcp.client.version": context.mcpClientVersion },
					...context.mcpProtocolVersion && { "mcp.protocol.version": context.mcpProtocolVersion },
					"mcp.server.name": "Sentry MCP",
					"mcp.server.version": LIB_VERSION,
					...extractMcpParameters(variables)
				}
			}, async () => {
				if (context.userId) setUser({ id: context.userId });
				if (context.clientId) setTag("client.id", context.clientId);
				return resource.handler(uri, extra);
			});
		});
	};
}
/**
* Configures an MCP server with all tools, prompts, resources, and telemetry.
*
* Transforms a bare MCP server instance into a fully-featured Sentry integration
* with comprehensive observability, error handling, and handler registration.
*
* @example Basic Configuration
* ```typescript
* const server = new McpServer();
* const context = {
*   accessToken: process.env.SENTRY_TOKEN,
*   host: "sentry.io",
*   userId: "user-123",
*   clientId: "cursor-ide"
* };
*
* await configureServer({ server, context });
* ```
*/
async function configureServer({ server, context, onToolComplete, onInitialized }) {
	server.server.onerror = (error) => {
		logError(error);
	};
	server.server.oninitialized = () => {
		const serverInstance = server.server;
		const clientInfo = serverInstance._clientVersion;
		const protocolVersion = serverInstance._protocolVersion;
		if (clientInfo) {
			context.mcpClientName = clientInfo.name;
			context.mcpClientVersion = clientInfo.version;
		}
		if (protocolVersion) context.mcpProtocolVersion = protocolVersion;
		if (onInitialized) {
			const result = onInitialized();
			if (result instanceof Promise) result.catch((error) => {
				console.error("Error in onInitialized callback:", error);
				logError(error);
			});
		}
	};
	for (const resource of RESOURCES) if (isTemplateResource(resource)) server.registerResource(resource.name, resource.template, {
		description: resource.description,
		mimeType: resource.mimeType
	}, createTemplateResourceHandler(resource, context));
	else server.registerResource(resource.name, resource.uri, {
		description: resource.description,
		mimeType: resource.mimeType
	}, createResourceHandler(resource, context));
	for (const prompt of PROMPT_DEFINITIONS) {
		const handler = PROMPT_HANDLERS[prompt.name];
		server.prompt(prompt.name, prompt.description, prompt.paramsSchema ? prompt.paramsSchema : {}, async (...args) => {
			try {
				return await startNewTrace(async () => {
					return await startSpan({
						name: `prompts/get ${prompt.name}`,
						attributes: {
							"mcp.prompt.name": prompt.name,
							...context.mcpClientName && { "mcp.client.name": context.mcpClientName },
							...context.mcpClientVersion && { "mcp.client.version": context.mcpClientVersion },
							...context.mcpProtocolVersion && { "mcp.protocol.version": context.mcpProtocolVersion },
							"mcp.server.name": MCP_SERVER_NAME,
							"mcp.server.version": LIB_VERSION,
							...extractMcpParameters(args[0] || {})
						}
					}, async (span) => {
						if (context.userId) setUser({ id: context.userId });
						if (context.clientId) setTag("client.id", context.clientId);
						try {
							const output = await handler(context, ...args);
							span.setStatus({ code: 1 });
							return { messages: [{
								role: "user",
								content: {
									type: "text",
									text: output
								}
							}] };
						} catch (error) {
							span.setStatus({ code: 2 });
							throw error;
						}
					});
				});
			} finally {
				onToolComplete?.();
			}
		});
	}
	for (const [toolKey, tool] of Object.entries(tools_default)) server.tool(tool.name, tool.description, tool.inputSchema, async (params, extra) => {
		try {
			return await startNewTrace(async () => {
				return await startSpan({
					name: `tools/call ${tool.name}`,
					attributes: {
						"mcp.tool.name": tool.name,
						...context.mcpClientName && { "mcp.client.name": context.mcpClientName },
						...context.mcpClientVersion && { "mcp.client.version": context.mcpClientVersion },
						...context.mcpProtocolVersion && { "mcp.protocol.version": context.mcpProtocolVersion },
						"mcp.server.name": MCP_SERVER_NAME,
						"mcp.server.version": LIB_VERSION,
						...extractMcpParameters(params || {})
					}
				}, async (span) => {
					if (context.userId) setUser({ id: context.userId });
					if (context.clientId) setTag("client.id", context.clientId);
					try {
						const output = await tool.handler(params, context);
						span.setStatus({ code: 1 });
						if (typeof output === "string") return { content: [{
							type: "text",
							text: output
						}] };
						if (Array.isArray(output)) return { content: output };
						throw new Error(`Invalid tool output: ${output}`);
					} catch (error) {
						span.setStatus({ code: 2 });
						return {
							content: [{
								type: "text",
								text: await logAndFormatError(error)
							}],
							isError: true
						};
					}
				});
			});
		} finally {
			onToolComplete?.();
		}
	});
}

//#endregion
export { configureServer };
//# sourceMappingURL=server-CnJvaT0s.js.map