{"version":3,"file":"client-CPrEfAwa.cjs","names":["NETWORK_ERROR_MESSAGES: Record<string, string>","message: string","status: number","host: string","path: string","options: RequestInit","headers: Record<string, string>","ConfigurationError","response: Response","parsed: unknown | undefined","requestOptions?: { host?: string }","organizationSlug: string","issueId: string","traceId: string","params: {\n    organizationSlug: string;\n    query: string;\n    projectSlug?: string;\n    fields?: string[];\n    sort?: string;\n    statsPeriod?: string;\n    aggregateFunctions?: string[];\n    groupByFields?: string[];\n  }","params: {\n    organizationSlug: string;\n    query: string;\n    dataset: \"spans\" | \"logs\";\n    projectSlug?: string;\n    fields?: string[];\n    sort?: string;\n    statsPeriod?: string;\n    aggregateFunctions?: string[];\n    groupByFields?: string[];\n  }","query: string","projectSlug?: string","dataset: \"spans\" | \"errors\" | \"logs\"","fields?: string[]","sort?: string","aggregateFunctions?: string[]","groupByFields?: string[]","opts?: RequestOptions","authHost: string | undefined","updateData: Record<string, any>","allAttributes: Array<{\n      key: string;\n      name: string;\n      type: \"string\" | \"number\";\n    }>","itemType: \"spans\" | \"logs\"","attributeType: \"string\" | \"number\"","project?: string","statsPeriod?: string","start?: string","end?: string","sentryQuery: string[]","params: {\n    query: string;\n    fields: string[];\n    limit: number;\n    projectSlug?: string;\n    statsPeriod?: string;\n    start?: string;\n    end?: string;\n    sort: string;\n  }","params: {\n    query: string;\n    fields: string[];\n    limit: number;\n    projectSlug?: string;\n    dataset: \"spans\" | \"ourlogs\";\n    statsPeriod?: string;\n    start?: string;\n    end?: string;\n    sort: string;\n  }","queryParams: URLSearchParams"],"sources":["../src/api-client/client.ts"],"sourcesContent":["import {\n  getIssueUrl as getIssueUrlUtil,\n  getTraceUrl as getTraceUrlUtil,\n  getEventsExplorerUrl as getEventsExplorerUrlUtil,\n  isSentryHost,\n} from \"../utils/url-utils\";\nimport {\n  OrganizationListSchema,\n  ClientKeySchema,\n  TeamListSchema,\n  TeamSchema,\n  ProjectListSchema,\n  ProjectSchema,\n  ReleaseListSchema,\n  IssueListSchema,\n  IssueSchema,\n  EventSchema,\n  EventAttachmentListSchema,\n  ErrorsSearchResponseSchema,\n  SpansSearchResponseSchema,\n  TagListSchema,\n  ApiErrorSchema,\n  ClientKeyListSchema,\n  AutofixRunSchema,\n  AutofixRunStateSchema,\n  UserSchema,\n  UserRegionsSchema,\n} from \"./schema\";\nimport { UserInputError, ConfigurationError } from \"../errors\";\nimport type {\n  AutofixRun,\n  AutofixRunState,\n  ClientKey,\n  ClientKeyList,\n  Event,\n  EventAttachment,\n  EventAttachmentList,\n  Issue,\n  IssueList,\n  OrganizationList,\n  Project,\n  ProjectList,\n  ReleaseList,\n  TagList,\n  Team,\n  TeamList,\n  User,\n} from \"./types\";\n// TODO: this is shared - so ideally, for safety, it uses @sentry/core, but currently\n// logger isnt exposed (or rather, it is, but its not the right logger)\n// import { logger } from \"@sentry/node\";\n\n/**\n * Mapping of common network error codes to user-friendly messages.\n * These help users understand and resolve connection issues.\n */\nconst NETWORK_ERROR_MESSAGES: Record<string, string> = {\n  EAI_AGAIN: \"DNS temporarily unavailable. Check your internet connection.\",\n  ENOTFOUND: \"Hostname not found. Verify the URL is correct.\",\n  ECONNREFUSED: \"Connection refused. Ensure the service is accessible.\",\n  ETIMEDOUT: \"Connection timed out. Check network connectivity.\",\n  ECONNRESET: \"Connection reset. Try again in a moment.\",\n};\n\n/**\n * Custom error class for Sentry API responses.\n *\n * Provides enhanced error messages for LLM consumption and handles\n * common API error scenarios with user-friendly messaging.\n *\n * @example\n * ```typescript\n * try {\n *   await apiService.listIssues({ organizationSlug: \"invalid\" });\n * } catch (error) {\n *   if (error instanceof ApiError) {\n *     console.log(`API Error ${error.status}: ${error.message}`);\n *   }\n * }\n * ```\n */\nexport class ApiError extends Error {\n  constructor(\n    message: string,\n    public status: number,\n  ) {\n    // HACK: improving this error message for the LLMs\n    let finalMessage = message;\n    if (\n      message.includes(\n        \"You do not have the multi project stream feature enabled\",\n      ) ||\n      message.includes(\"You cannot view events from multiple projects\")\n    ) {\n      finalMessage =\n        \"You do not have access to query across multiple projects. Please select a project for your query.\";\n    }\n\n    super(finalMessage);\n  }\n}\n\ntype RequestOptions = {\n  host?: string;\n};\n\n/**\n * Sentry API client service for interacting with Sentry's REST API.\n *\n * This service provides a comprehensive interface to Sentry's API endpoints,\n * handling authentication, error processing, multi-region support, and\n * response validation through Zod schemas.\n *\n * Key Features:\n * - Multi-region support for Sentry SaaS and self-hosted instances\n * - Automatic schema validation with Zod\n * - Enhanced error handling with LLM-friendly messages\n * - URL generation for Sentry resources (issues, traces)\n * - Bearer token authentication\n * - Always uses HTTPS for secure connections\n *\n * @example Basic Usage\n * ```typescript\n * const apiService = new SentryApiService({\n *   accessToken: \"your-token\",\n *   host: \"sentry.io\"\n * });\n *\n * const orgs = await apiService.listOrganizations();\n * const issues = await apiService.listIssues({\n *   organizationSlug: \"my-org\",\n *   query: \"is:unresolved\"\n * });\n * ```\n *\n * @example Multi-Region Support\n * ```typescript\n * // Self-hosted instance with hostname\n * const selfHosted = new SentryApiService({\n *   accessToken: \"token\",\n *   host: \"sentry.company.com\"\n * });\n *\n * // Regional endpoint override\n * const issues = await apiService.listIssues(\n *   { organizationSlug: \"org\" },\n *   { host: \"eu.sentry.io\" }\n * );\n * ```\n */\nexport class SentryApiService {\n  private accessToken: string | null;\n  protected host: string;\n  protected apiPrefix: string;\n\n  /**\n   * Creates a new Sentry API service instance.\n   *\n   * Always uses HTTPS for secure connections.\n   *\n   * @param config Configuration object\n   * @param config.accessToken OAuth access token for authentication (optional for some endpoints)\n   * @param config.host Sentry hostname (e.g. \"sentry.io\", \"sentry.example.com\")\n   */\n  constructor({\n    accessToken = null,\n    host = \"sentry.io\",\n  }: {\n    accessToken?: string | null;\n    host?: string;\n  }) {\n    this.accessToken = accessToken;\n    this.host = host;\n    this.apiPrefix = `https://${host}/api/0`;\n  }\n\n  /**\n   * Updates the host for API requests.\n   *\n   * Used for multi-region support or switching between Sentry instances.\n   * Always uses HTTPS protocol.\n   *\n   * @param host New hostname to use for API requests\n   */\n  setHost(host: string) {\n    this.host = host;\n    this.apiPrefix = `https://${this.host}/api/0`;\n  }\n\n  /**\n   * Checks if the current host is Sentry SaaS (sentry.io).\n   *\n   * Used to determine API endpoint availability and URL formats.\n   * Self-hosted instances may not have all endpoints available.\n   *\n   * @returns True if using Sentry SaaS, false for self-hosted instances\n   */\n  private isSaas(): boolean {\n    return isSentryHost(this.host);\n  }\n\n  /**\n   * Internal method for making authenticated requests to Sentry API.\n   *\n   * Handles:\n   * - Bearer token authentication\n   * - Error response parsing and enhancement\n   * - Multi-region host overrides\n   * - Fetch availability validation\n   *\n   * @param path API endpoint path (without /api/0 prefix)\n   * @param options Fetch options\n   * @param requestOptions Additional request configuration\n   * @returns Promise resolving to Response object\n   * @throws {ApiError} Enhanced API errors with user-friendly messages\n   * @throws {Error} Network or parsing errors\n   */\n  private async request(\n    path: string,\n    options: RequestInit = {},\n    { host }: { host?: string } = {},\n  ): Promise<Response> {\n    const url = host\n      ? `https://${host}/api/0${path}`\n      : `${this.apiPrefix}${path}`;\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": \"Sentry MCP Server\",\n    };\n    if (this.accessToken) {\n      headers.Authorization = `Bearer ${this.accessToken}`;\n    }\n\n    // Check if fetch is available, otherwise provide a helpful error message\n    if (typeof globalThis.fetch === \"undefined\") {\n      throw new ConfigurationError(\n        \"fetch is not available. Please use Node.js >= 18 or ensure fetch is available in your environment.\",\n      );\n    }\n\n    // logger.info(logger.fmt`[sentryApi] ${options.method || \"GET\"} ${url}`);\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        ...options,\n        headers,\n      });\n    } catch (error) {\n      // Extract the root cause from the error chain\n      let rootCause = error;\n      while (rootCause instanceof Error && rootCause.cause) {\n        rootCause = rootCause.cause;\n      }\n\n      const errorMessage =\n        rootCause instanceof Error ? rootCause.message : String(rootCause);\n\n      let friendlyMessage = `Unable to connect to ${url}`;\n\n      // Check if we have a specific message for this error\n      const errorCode = Object.keys(NETWORK_ERROR_MESSAGES).find((code) =>\n        errorMessage.includes(code),\n      );\n\n      if (errorCode) {\n        friendlyMessage += ` - ${NETWORK_ERROR_MESSAGES[errorCode]}`;\n      } else {\n        friendlyMessage += ` - ${errorMessage}`;\n      }\n\n      // DNS resolution failures and connection timeouts to custom hosts are configuration issues\n      if (\n        errorCode === \"ENOTFOUND\" ||\n        errorCode === \"EAI_AGAIN\" ||\n        errorCode === \"ECONNREFUSED\" ||\n        errorCode === \"ETIMEDOUT\" ||\n        errorMessage.includes(\"Connect Timeout Error\")\n      ) {\n        throw new ConfigurationError(friendlyMessage, { cause: error });\n      }\n\n      throw new Error(friendlyMessage, { cause: error });\n    }\n\n    // Handle error responses generically\n    if (!response.ok) {\n      const errorText = await response.text();\n      let parsed: unknown | undefined;\n      try {\n        parsed = JSON.parse(errorText);\n      } catch (error) {\n        // If we can't parse JSON, check if it's HTML (server error)\n        if (errorText.includes(\"<!DOCTYPE\") || errorText.includes(\"<html\")) {\n          console.error(\n            `[sentryApi] Received HTML error page instead of JSON (status ${response.status})`,\n            error,\n          );\n          throw new Error(\n            `Server error: Received HTML instead of JSON (${response.status} ${response.statusText}). This may indicate an invalid URL or server issue.`,\n          );\n        }\n        console.error(\n          `[sentryApi] Failed to parse error response: ${errorText}`,\n          error,\n        );\n      }\n\n      if (parsed) {\n        const { data, success, error } = ApiErrorSchema.safeParse(parsed);\n\n        if (success) {\n          throw new ApiError(data.detail, response.status);\n        }\n\n        console.error(\n          `[sentryApi] Failed to parse error response: ${errorText}`,\n          error,\n        );\n      }\n\n      throw new Error(\n        `API request failed: ${response.status} ${response.statusText}\\n${errorText}`,\n      );\n    }\n\n    return response;\n  }\n\n  /**\n   * Safely parses a JSON response, checking Content-Type header first.\n   *\n   * @param response The Response object from fetch\n   * @returns Promise resolving to the parsed JSON object\n   * @throws {Error} If response is not JSON or parsing fails\n   */\n  private async parseJsonResponse(response: Response): Promise<unknown> {\n    // Handle case where response might not have all properties (e.g., in tests or promise chains)\n    if (!response.headers?.get) {\n      return response.json();\n    }\n\n    const contentType = response.headers.get(\"content-type\");\n\n    // Check if the response is JSON\n    if (!contentType || !contentType.includes(\"application/json\")) {\n      const responseText = await response.text();\n\n      // Check if it's HTML\n      if (\n        contentType?.includes(\"text/html\") ||\n        responseText.includes(\"<!DOCTYPE\") ||\n        responseText.includes(\"<html\")\n      ) {\n        throw new Error(\n          `Expected JSON response but received HTML (${response.status} ${response.statusText}). This may indicate you're not authenticated, the URL is incorrect, or there's a server issue.`,\n        );\n      }\n\n      // Generic non-JSON error\n      throw new Error(\n        `Expected JSON response but received ${contentType || \"unknown content type\"} ` +\n          `(${response.status} ${response.statusText})`,\n      );\n    }\n\n    try {\n      return await response.json();\n    } catch (error) {\n      throw new Error(\n        `Failed to parse JSON response: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Makes a request to the Sentry API and parses the JSON response.\n   *\n   * This is the primary method for API calls that expect JSON responses.\n   * It automatically validates Content-Type and provides helpful error messages\n   * for common issues like authentication failures or server errors.\n   *\n   * @param path API endpoint path (without /api/0 prefix)\n   * @param options Fetch options\n   * @param requestOptions Additional request configuration\n   * @returns Promise resolving to the parsed JSON response\n   * @throws {ApiError} Enhanced API errors with user-friendly messages\n   * @throws {Error} Network, parsing, or validation errors\n   */\n  private async requestJSON(\n    path: string,\n    options: RequestInit = {},\n    requestOptions?: { host?: string },\n  ): Promise<unknown> {\n    const response = await this.request(path, options, requestOptions);\n    return this.parseJsonResponse(response);\n  }\n\n  /**\n   * Generates a Sentry issue URL for browser navigation.\n   *\n   * Handles both SaaS (subdomain-based) and self-hosted URL formats.\n   * Always uses HTTPS protocol.\n   *\n   * @param organizationSlug Organization identifier\n   * @param issueId Issue identifier (short ID or numeric ID)\n   * @returns Full URL to the issue in Sentry UI\n   *\n   * @example\n   * ```typescript\n   * // SaaS: https://my-org.sentry.io/issues/PROJ-123\n   * apiService.getIssueUrl(\"my-org\", \"PROJ-123\")\n   *\n   * // Self-hosted: https://sentry.company.com/organizations/my-org/issues/PROJ-123\n   * apiService.getIssueUrl(\"my-org\", \"PROJ-123\")\n   * ```\n   */\n  getIssueUrl(organizationSlug: string, issueId: string): string {\n    return getIssueUrlUtil(this.host, organizationSlug, issueId);\n  }\n\n  /**\n   * Generates a Sentry trace URL for performance investigation.\n   *\n   * Always uses HTTPS protocol.\n   *\n   * @param organizationSlug Organization identifier\n   * @param traceId Trace identifier (hex string)\n   * @returns Full HTTPS URL to the trace in Sentry UI\n   *\n   * @example\n   * ```typescript\n   * const traceUrl = apiService.getTraceUrl(\"my-org\", \"6a477f5b0f31ef7b6b9b5e1dea66c91d\");\n   * // https://my-org.sentry.io/explore/traces/trace/6a477f5b0f31ef7b6b9b5e1dea66c91d\n   * ```\n   */\n  getTraceUrl(organizationSlug: string, traceId: string): string {\n    return getTraceUrlUtil(this.host, organizationSlug, traceId);\n  }\n\n  // ================================================================================\n  // URL BUILDERS FOR DIFFERENT SENTRY APIS\n  // ================================================================================\n\n  /**\n   * Builds a URL for the legacy Discover API (used by errors dataset).\n   *\n   * The Discover API is the older query interface that includes aggregate\n   * functions directly in the field list.\n   *\n   * @example\n   * // URL format: /explore/discover/homepage/?field=title&field=count_unique(user)\n   * buildDiscoverUrl(\"my-org\", \"level:error\", \"123\", [\"title\", \"count_unique(user)\"], \"-timestamp\")\n   */\n  private buildDiscoverUrl(params: {\n    organizationSlug: string;\n    query: string;\n    projectSlug?: string;\n    fields?: string[];\n    sort?: string;\n    statsPeriod?: string;\n    aggregateFunctions?: string[];\n    groupByFields?: string[];\n  }): string {\n    const {\n      organizationSlug,\n      query,\n      projectSlug,\n      fields,\n      sort,\n      statsPeriod = \"24h\",\n      aggregateFunctions,\n      groupByFields,\n    } = params;\n\n    const urlParams = new URLSearchParams();\n\n    // Discover API specific parameters\n    urlParams.set(\"dataset\", \"errors\");\n    urlParams.set(\"queryDataset\", \"error-events\");\n    urlParams.set(\"query\", query);\n\n    if (projectSlug) {\n      urlParams.set(\"project\", projectSlug);\n    }\n\n    // Discover API includes aggregate functions directly in field list\n    if (fields && fields.length > 0) {\n      for (const field of fields) {\n        urlParams.append(\"field\", field);\n      }\n    } else {\n      // Default fields for Discover\n      urlParams.append(\"field\", \"title\");\n      urlParams.append(\"field\", \"project\");\n      urlParams.append(\"field\", \"user.display\");\n      urlParams.append(\"field\", \"timestamp\");\n    }\n\n    urlParams.set(\"sort\", sort || \"-timestamp\");\n    urlParams.set(\"statsPeriod\", statsPeriod);\n\n    // Check if this is an aggregate query\n    const isAggregate = (aggregateFunctions?.length ?? 0) > 0;\n    if (isAggregate) {\n      urlParams.set(\"mode\", \"aggregate\");\n      // For aggregate queries in Discover, set yAxis to the first aggregate function\n      if (aggregateFunctions && aggregateFunctions.length > 0) {\n        urlParams.set(\"yAxis\", aggregateFunctions[0]);\n      }\n    } else {\n      urlParams.set(\"yAxis\", \"count()\");\n    }\n\n    const path = this.isSaas()\n      ? `https://${organizationSlug}.sentry.io/explore/discover/homepage/`\n      : `https://${this.host}/organizations/${organizationSlug}/explore/discover/homepage/`;\n\n    return `${path}?${urlParams.toString()}`;\n  }\n\n  /**\n   * Builds a URL for the modern EAP (Event Analytics Platform) API used by spans/logs.\n   *\n   * The EAP API uses structured aggregate queries with separate aggregateField\n   * parameters containing JSON objects for groupBy and yAxes.\n   *\n   * @example\n   * // URL format: /explore/traces/?aggregateField={\"groupBy\":\"span.op\"}&aggregateField={\"yAxes\":[\"count()\"]}\n   * buildEapUrl(\"my-org\", \"span.op:db\", \"123\", [\"span.op\", \"count()\"], \"-count()\", [\"count()\"], [\"span.op\"])\n   */\n  private buildEapUrl(params: {\n    organizationSlug: string;\n    query: string;\n    dataset: \"spans\" | \"logs\";\n    projectSlug?: string;\n    fields?: string[];\n    sort?: string;\n    statsPeriod?: string;\n    aggregateFunctions?: string[];\n    groupByFields?: string[];\n  }): string {\n    const {\n      organizationSlug,\n      query,\n      dataset,\n      projectSlug,\n      fields,\n      sort,\n      statsPeriod = \"24h\",\n      aggregateFunctions,\n      groupByFields,\n    } = params;\n\n    const urlParams = new URLSearchParams();\n    urlParams.set(\"query\", query);\n\n    if (projectSlug) {\n      urlParams.set(\"project\", projectSlug);\n    }\n\n    // Determine if this is an aggregate query\n    const isAggregateQuery =\n      (aggregateFunctions?.length ?? 0) > 0 ||\n      fields?.some((field) => field.includes(\"(\") && field.includes(\")\")) ||\n      false;\n\n    if (isAggregateQuery) {\n      // EAP API uses structured aggregate parameters\n      if (\n        (aggregateFunctions?.length ?? 0) > 0 ||\n        (groupByFields?.length ?? 0) > 0\n      ) {\n        // Add each groupBy field as a separate aggregateField parameter\n        if (groupByFields && groupByFields.length > 0) {\n          for (const field of groupByFields) {\n            urlParams.append(\n              \"aggregateField\",\n              JSON.stringify({ groupBy: field }),\n            );\n          }\n        }\n\n        // Add aggregate functions (yAxes)\n        if (aggregateFunctions && aggregateFunctions.length > 0) {\n          urlParams.append(\n            \"aggregateField\",\n            JSON.stringify({ yAxes: aggregateFunctions }),\n          );\n        }\n      } else {\n        // Fallback: parse fields to extract aggregate info\n        const parsedGroupByFields =\n          fields?.filter(\n            (field) => !field.includes(\"(\") && !field.includes(\")\"),\n          ) || [];\n        const parsedAggregateFunctions =\n          fields?.filter(\n            (field) => field.includes(\"(\") && field.includes(\")\"),\n          ) || [];\n\n        for (const field of parsedGroupByFields) {\n          urlParams.append(\n            \"aggregateField\",\n            JSON.stringify({ groupBy: field }),\n          );\n        }\n\n        if (parsedAggregateFunctions.length > 0) {\n          urlParams.append(\n            \"aggregateField\",\n            JSON.stringify({ yAxes: parsedAggregateFunctions }),\n          );\n        }\n      }\n\n      urlParams.set(\"mode\", \"aggregate\");\n    } else {\n      // Non-aggregate query, add individual fields\n      if (fields && fields.length > 0) {\n        for (const field of fields) {\n          urlParams.append(\"field\", field);\n        }\n      }\n    }\n\n    // Add sort parameter for all queries\n    if (sort) {\n      urlParams.set(\"sort\", sort);\n    }\n\n    urlParams.set(\"statsPeriod\", statsPeriod);\n\n    const basePath = dataset === \"logs\" ? \"logs\" : \"traces\";\n    const path = this.isSaas()\n      ? `https://${organizationSlug}.sentry.io/explore/${basePath}/`\n      : `https://${this.host}/organizations/${organizationSlug}/explore/${basePath}/`;\n\n    return `${path}?${urlParams.toString()}`;\n  }\n\n  /**\n   * Generates a Sentry events explorer URL for viewing search results.\n   *\n   * Routes to the appropriate API based on dataset:\n   * - Errors: Uses legacy Discover API\n   * - Spans/Logs: Uses modern EAP (Event Analytics Platform) API\n   *\n   * @param organizationSlug Organization identifier\n   * @param query Sentry search query\n   * @param projectSlug Optional project filter\n   * @param dataset Dataset type (spans, errors, or logs)\n   * @param fields Array of fields to include in results\n   * @param sort Sort parameter (e.g., \"-timestamp\", \"-count()\")\n   * @param aggregateFunctions Array of aggregate functions (only used for EAP datasets)\n   * @param groupByFields Array of fields to group by (only used for EAP datasets)\n   * @returns Full HTTPS URL to the events explorer in Sentry UI\n   */\n  getEventsExplorerUrl(\n    organizationSlug: string,\n    query: string,\n    projectSlug?: string,\n    dataset: \"spans\" | \"errors\" | \"logs\" = \"spans\",\n    fields?: string[],\n    sort?: string,\n    aggregateFunctions?: string[],\n    groupByFields?: string[],\n  ): string {\n    if (dataset === \"errors\") {\n      // Route to legacy Discover API\n      return this.buildDiscoverUrl({\n        organizationSlug,\n        query,\n        projectSlug,\n        fields,\n        sort,\n        aggregateFunctions,\n        groupByFields,\n      });\n    }\n\n    // Route to modern EAP API (spans and logs)\n    return this.buildEapUrl({\n      organizationSlug,\n      query,\n      dataset,\n      projectSlug,\n      fields,\n      sort,\n      aggregateFunctions,\n      groupByFields,\n    });\n  }\n\n  /**\n   * Retrieves the authenticated user's profile information.\n   *\n   * @param opts Request options including host override\n   * @returns User profile data\n   * @throws {ApiError} If authentication fails or user not found\n   */\n  async getAuthenticatedUser(opts?: RequestOptions): Promise<User> {\n    // Auth endpoints only exist on the main API server, never on regional endpoints\n    let authHost: string | undefined;\n\n    if (this.isSaas()) {\n      // For SaaS, always use the main sentry.io host, not regional hosts\n      // This handles cases like us.sentry.io, eu.sentry.io, etc.\n      authHost = \"sentry.io\";\n    }\n    // For self-hosted, use the configured host (authHost remains undefined)\n\n    const body = await this.requestJSON(\"/auth/\", undefined, {\n      ...opts,\n      host: authHost,\n    });\n    return UserSchema.parse(body);\n  }\n\n  /**\n   * Lists all organizations accessible to the authenticated user.\n   *\n   * Automatically handles multi-region queries by fetching from all\n   * available regions and combining results.\n   *\n   * @param opts Request options\n   * @returns Array of organizations across all accessible regions\n   *\n   * @example\n   * ```typescript\n   * const orgs = await apiService.listOrganizations();\n   * orgs.forEach(org => {\n   *   // regionUrl present for Cloud Service, empty for self-hosted\n   *   console.log(`${org.name} (${org.slug}) - ${org.links?.regionUrl || 'No region URL'}`);\n   * });\n   * ```\n   */\n  async listOrganizations(opts?: RequestOptions): Promise<OrganizationList> {\n    // For self-hosted instances, the regions endpoint doesn't exist\n    if (!this.isSaas()) {\n      const body = await this.requestJSON(\"/organizations/\", undefined, opts);\n      return OrganizationListSchema.parse(body);\n    }\n\n    // For SaaS, try to use regions endpoint first\n    try {\n      // TODO: Sentry is currently not returning all orgs without hitting region endpoints\n      // The regions endpoint only exists on the main API server, not on regional endpoints\n      const regionsBody = await this.requestJSON(\n        \"/users/me/regions/\",\n        undefined,\n        {}, // Don't pass opts to ensure we use the main host\n      );\n      const regionData = UserRegionsSchema.parse(regionsBody);\n\n      return (\n        await Promise.all(\n          regionData.regions.map(async (region) =>\n            this.requestJSON(`/organizations/`, undefined, {\n              ...opts,\n              host: new URL(region.url).host,\n            }),\n          ),\n        )\n      )\n        .map((data) => OrganizationListSchema.parse(data))\n        .reduce((acc, curr) => acc.concat(curr), []);\n    } catch (error) {\n      // If regions endpoint fails (e.g., older self-hosted versions identifying as sentry.io),\n      // fall back to direct organizations endpoint\n      if (error instanceof ApiError && error.status === 404) {\n        // logger.info(\"Regions endpoint not found, falling back to direct organizations endpoint\");\n        const body = await this.requestJSON(\"/organizations/\", undefined, opts);\n        return OrganizationListSchema.parse(body);\n      }\n\n      // Re-throw other errors\n      throw error;\n    }\n  }\n\n  /**\n   * Lists teams within an organization.\n   *\n   * @param organizationSlug Organization identifier\n   * @param opts Request options including host override\n   * @returns Array of teams in the organization\n   */\n  async listTeams(\n    organizationSlug: string,\n    opts?: RequestOptions,\n  ): Promise<TeamList> {\n    const body = await this.requestJSON(\n      `/organizations/${organizationSlug}/teams/`,\n      undefined,\n      opts,\n    );\n    return TeamListSchema.parse(body);\n  }\n\n  /**\n   * Creates a new team within an organization.\n   *\n   * @param params Team creation parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.name Team name\n   * @param opts Request options\n   * @returns Created team data\n   * @throws {ApiError} If team creation fails (e.g., name conflicts)\n   */\n  async createTeam(\n    {\n      organizationSlug,\n      name,\n    }: {\n      organizationSlug: string;\n      name: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Team> {\n    const body = await this.requestJSON(\n      `/organizations/${organizationSlug}/teams/`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({ name }),\n      },\n      opts,\n    );\n    return TeamSchema.parse(body);\n  }\n\n  /**\n   * Lists projects within an organization.\n   *\n   * @param organizationSlug Organization identifier\n   * @param opts Request options\n   * @returns Array of projects in the organization\n   */\n  async listProjects(\n    organizationSlug: string,\n    opts?: RequestOptions,\n  ): Promise<ProjectList> {\n    const body = await this.requestJSON(\n      `/organizations/${organizationSlug}/projects/`,\n      undefined,\n      opts,\n    );\n    return ProjectListSchema.parse(body);\n  }\n\n  /**\n   * Gets a single project by slug or ID.\n   *\n   * @param params Project fetch parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.projectSlugOrId Project slug or numeric ID\n   * @param opts Request options\n   * @returns Project data\n   */\n  async getProject(\n    {\n      organizationSlug,\n      projectSlugOrId,\n    }: {\n      organizationSlug: string;\n      projectSlugOrId: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Project> {\n    const body = await this.requestJSON(\n      `/projects/${organizationSlug}/${projectSlugOrId}/`,\n      undefined,\n      opts,\n    );\n    return ProjectSchema.parse(body);\n  }\n\n  /**\n   * Creates a new project within a team.\n   *\n   * @param params Project creation parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.teamSlug Team identifier\n   * @param params.name Project name\n   * @param params.platform Platform identifier (e.g., \"javascript\", \"python\")\n   * @param opts Request options\n   * @returns Created project data\n   */\n  async createProject(\n    {\n      organizationSlug,\n      teamSlug,\n      name,\n      platform,\n    }: {\n      organizationSlug: string;\n      teamSlug: string;\n      name: string;\n      platform?: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Project> {\n    const body = await this.requestJSON(\n      `/teams/${organizationSlug}/${teamSlug}/projects/`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          name,\n          platform,\n        }),\n      },\n      opts,\n    );\n    return ProjectSchema.parse(body);\n  }\n\n  /**\n   * Updates an existing project's configuration.\n   *\n   * @param params Project update parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.projectSlug Current project identifier\n   * @param params.name New project name (optional)\n   * @param params.slug New project slug (optional)\n   * @param params.platform New platform identifier (optional)\n   * @param opts Request options\n   * @returns Updated project data\n   */\n  async updateProject(\n    {\n      organizationSlug,\n      projectSlug,\n      name,\n      slug,\n      platform,\n    }: {\n      organizationSlug: string;\n      projectSlug: string;\n      name?: string;\n      slug?: string;\n      platform?: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Project> {\n    const updateData: Record<string, any> = {};\n    if (name !== undefined) updateData.name = name;\n    if (slug !== undefined) updateData.slug = slug;\n    if (platform !== undefined) updateData.platform = platform;\n\n    const body = await this.requestJSON(\n      `/projects/${organizationSlug}/${projectSlug}/`,\n      {\n        method: \"PUT\",\n        body: JSON.stringify(updateData),\n      },\n      opts,\n    );\n    return ProjectSchema.parse(body);\n  }\n\n  /**\n   * Assigns a team to a project.\n   *\n   * @param params Assignment parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.projectSlug Project identifier\n   * @param params.teamSlug Team identifier to assign\n   * @param opts Request options\n   */\n  async addTeamToProject(\n    {\n      organizationSlug,\n      projectSlug,\n      teamSlug,\n    }: {\n      organizationSlug: string;\n      projectSlug: string;\n      teamSlug: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<void> {\n    await this.request(\n      `/projects/${organizationSlug}/${projectSlug}/teams/${teamSlug}/`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({}),\n      },\n      opts,\n    );\n  }\n\n  /**\n   * Creates a new client key (DSN) for a project.\n   *\n   * Client keys are used to identify and authenticate SDK requests to Sentry.\n   *\n   * @param params Key creation parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.projectSlug Project identifier\n   * @param params.name Human-readable name for the key (optional)\n   * @param opts Request options\n   * @returns Created client key with DSN information\n   *\n   * @example\n   * ```typescript\n   * const key = await apiService.createClientKey({\n   *   organizationSlug: \"my-org\",\n   *   projectSlug: \"my-project\",\n   *   name: \"Production\"\n   * });\n   * console.log(`DSN: ${key.dsn.public}`);\n   * ```\n   */\n  async createClientKey(\n    {\n      organizationSlug,\n      projectSlug,\n      name,\n    }: {\n      organizationSlug: string;\n      projectSlug: string;\n      name?: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<ClientKey> {\n    const body = await this.requestJSON(\n      `/projects/${organizationSlug}/${projectSlug}/keys/`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          name,\n        }),\n      },\n      opts,\n    );\n    return ClientKeySchema.parse(body);\n  }\n\n  /**\n   * Lists all client keys (DSNs) for a project.\n   *\n   * @param params Query parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.projectSlug Project identifier\n   * @param opts Request options\n   * @returns Array of client keys with DSN information\n   */\n  async listClientKeys(\n    {\n      organizationSlug,\n      projectSlug,\n    }: {\n      organizationSlug: string;\n      projectSlug: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<ClientKeyList> {\n    const body = await this.requestJSON(\n      `/projects/${organizationSlug}/${projectSlug}/keys/`,\n      undefined,\n      opts,\n    );\n    return ClientKeyListSchema.parse(body);\n  }\n\n  /**\n   * Lists releases for an organization or specific project.\n   *\n   * @param params Query parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.projectSlug Project identifier (optional, scopes to specific project)\n   * @param params.query Search query for filtering releases\n   * @param opts Request options\n   * @returns Array of releases with deployment and commit information\n   *\n   * @example\n   * ```typescript\n   * // All releases for organization\n   * const releases = await apiService.listReleases({\n   *   organizationSlug: \"my-org\"\n   * });\n   *\n   * // Search for specific version\n   * const filtered = await apiService.listReleases({\n   *   organizationSlug: \"my-org\",\n   *   query: \"v1.2.3\"\n   * });\n   * ```\n   */\n  async listReleases(\n    {\n      organizationSlug,\n      projectSlug,\n      query,\n    }: {\n      organizationSlug: string;\n      projectSlug?: string;\n      query?: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<ReleaseList> {\n    const searchQuery = new URLSearchParams();\n    if (query) {\n      searchQuery.set(\"query\", query);\n    }\n\n    const path = projectSlug\n      ? `/projects/${organizationSlug}/${projectSlug}/releases/`\n      : `/organizations/${organizationSlug}/releases/`;\n\n    const body = await this.requestJSON(\n      searchQuery.toString() ? `${path}?${searchQuery.toString()}` : path,\n      undefined,\n      opts,\n    );\n    return ReleaseListSchema.parse(body);\n  }\n\n  /**\n   * Lists available tags for search queries.\n   *\n   * Tags represent indexed fields that can be used in Sentry search queries.\n   *\n   * @param params Query parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.dataset Dataset to query tags for (\"events\", \"errors\" or \"search_issues\")\n   * @param params.project Numeric project ID to filter tags\n   * @param params.statsPeriod Time range for tag statistics (e.g., \"24h\", \"7d\")\n   * @param params.useCache Whether to use cached results\n   * @param params.useFlagsBackend Whether to use flags backend features\n   * @param opts Request options\n   * @returns Array of available tags with metadata\n   *\n   * @example\n   * ```typescript\n   * const tags = await apiService.listTags({\n   *   organizationSlug: \"my-org\",\n   *   dataset: \"events\",\n   *   project: \"123456\",\n   *   statsPeriod: \"24h\",\n   *   useCache: true\n   * });\n   * tags.forEach(tag => console.log(`${tag.key}: ${tag.name}`));\n   * ```\n   */\n  async listTags(\n    {\n      organizationSlug,\n      dataset,\n      project,\n      statsPeriod,\n      start,\n      end,\n      useCache,\n      useFlagsBackend,\n    }: {\n      organizationSlug: string;\n      dataset?: \"events\" | \"errors\" | \"search_issues\";\n      project?: string;\n      statsPeriod?: string;\n      start?: string;\n      end?: string;\n      useCache?: boolean;\n      useFlagsBackend?: boolean;\n    },\n    opts?: RequestOptions,\n  ): Promise<TagList> {\n    const searchQuery = new URLSearchParams();\n    if (dataset) {\n      searchQuery.set(\"dataset\", dataset);\n    }\n    if (project) {\n      searchQuery.set(\"project\", project);\n    }\n    // Validate time parameters - can't use both relative and absolute\n    if (statsPeriod && (start || end)) {\n      throw new Error(\n        \"Cannot use both statsPeriod and start/end parameters. Use either statsPeriod for relative time or start/end for absolute time.\",\n      );\n    }\n    if ((start && !end) || (!start && end)) {\n      throw new Error(\n        \"Both start and end parameters must be provided together for absolute time ranges.\",\n      );\n    }\n    // Use either relative time (statsPeriod) or absolute time (start/end)\n    if (statsPeriod) {\n      searchQuery.set(\"statsPeriod\", statsPeriod);\n    } else if (start && end) {\n      searchQuery.set(\"start\", start);\n      searchQuery.set(\"end\", end);\n    }\n    if (useCache !== undefined) {\n      searchQuery.set(\"useCache\", useCache ? \"1\" : \"0\");\n    }\n    if (useFlagsBackend !== undefined) {\n      searchQuery.set(\"useFlagsBackend\", useFlagsBackend ? \"1\" : \"0\");\n    }\n\n    const body = await this.requestJSON(\n      searchQuery.toString()\n        ? `/organizations/${organizationSlug}/tags/?${searchQuery.toString()}`\n        : `/organizations/${organizationSlug}/tags/`,\n      undefined,\n      opts,\n    );\n    return TagListSchema.parse(body);\n  }\n\n  /**\n   * Lists trace item attributes available for search queries.\n   *\n   * Returns all available fields/attributes that can be used in event searches,\n   * including both built-in fields and custom tags.\n   *\n   * @param params Query parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.itemType Item type to query attributes for (\"spans\" or \"logs\")\n   * @param params.project Numeric project ID to filter attributes\n   * @param params.statsPeriod Time range for attribute statistics (e.g., \"24h\", \"7d\")\n   * @param opts Request options\n   * @returns Array of available attributes with metadata including type\n   */\n  async listTraceItemAttributes(\n    {\n      organizationSlug,\n      itemType = \"spans\",\n      project,\n      statsPeriod,\n      start,\n      end,\n    }: {\n      organizationSlug: string;\n      itemType?: \"spans\" | \"logs\";\n      project?: string;\n      statsPeriod?: string;\n      start?: string;\n      end?: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Array<{ key: string; name: string; type: \"string\" | \"number\" }>> {\n    // Fetch both string and number attributes\n    const [stringAttributes, numberAttributes] = await Promise.all([\n      this.fetchTraceItemAttributesByType(\n        organizationSlug,\n        itemType,\n        \"string\",\n        project,\n        statsPeriod,\n        start,\n        end,\n        opts,\n      ),\n      this.fetchTraceItemAttributesByType(\n        organizationSlug,\n        itemType,\n        \"number\",\n        project,\n        statsPeriod,\n        start,\n        end,\n        opts,\n      ),\n    ]);\n\n    // Combine attributes with explicit type information\n    const allAttributes: Array<{\n      key: string;\n      name: string;\n      type: \"string\" | \"number\";\n    }> = [];\n\n    // Add string attributes\n    for (const attr of stringAttributes) {\n      allAttributes.push({\n        key: attr.key,\n        name: attr.name || attr.key,\n        type: \"string\",\n      });\n    }\n\n    // Add number attributes\n    for (const attr of numberAttributes) {\n      allAttributes.push({\n        key: attr.key,\n        name: attr.name || attr.key,\n        type: \"number\",\n      });\n    }\n\n    return allAttributes;\n  }\n\n  private async fetchTraceItemAttributesByType(\n    organizationSlug: string,\n    itemType: \"spans\" | \"logs\",\n    attributeType: \"string\" | \"number\",\n    project?: string,\n    statsPeriod?: string,\n    start?: string,\n    end?: string,\n    opts?: RequestOptions,\n  ): Promise<any> {\n    const queryParams = new URLSearchParams();\n    queryParams.set(\"itemType\", itemType);\n    queryParams.set(\"attributeType\", attributeType);\n    if (project) {\n      queryParams.set(\"project\", project);\n    }\n    // Validate time parameters - can't use both relative and absolute\n    if (statsPeriod && (start || end)) {\n      throw new Error(\n        \"Cannot use both statsPeriod and start/end parameters. Use either statsPeriod for relative time or start/end for absolute time.\",\n      );\n    }\n    if ((start && !end) || (!start && end)) {\n      throw new Error(\n        \"Both start and end parameters must be provided together for absolute time ranges.\",\n      );\n    }\n    // Use either relative time (statsPeriod) or absolute time (start/end)\n    if (statsPeriod) {\n      queryParams.set(\"statsPeriod\", statsPeriod);\n    } else if (start && end) {\n      queryParams.set(\"start\", start);\n      queryParams.set(\"end\", end);\n    }\n\n    const url = `/organizations/${organizationSlug}/trace-items/attributes/?${queryParams.toString()}`;\n\n    const body = await this.requestJSON(url, undefined, opts);\n    return Array.isArray(body) ? body : [];\n  }\n\n  /**\n   * Lists issues within an organization or project.\n   *\n   * Issues represent groups of similar errors or problems in your application.\n   * Supports Sentry's powerful query syntax for filtering and sorting.\n   *\n   * @param params Query parameters\n   * @param params.organizationSlug Organization identifier\n   * @param params.projectSlug Project identifier (optional, scopes to specific project)\n   * @param params.query Sentry search query (e.g., \"is:unresolved browser:chrome\")\n   * @param params.sortBy Sort order (\"user\", \"freq\", \"date\", \"new\")\n   * @param opts Request options\n   * @returns Array of issues with metadata and statistics\n   *\n   * @example\n   * ```typescript\n   * // Recent unresolved issues\n   * const issues = await apiService.listIssues({\n   *   organizationSlug: \"my-org\",\n   *   query: \"is:unresolved\",\n   *   sortBy: \"date\"\n   * });\n   *\n   * // High-frequency errors in specific project\n   * const critical = await apiService.listIssues({\n   *   organizationSlug: \"my-org\",\n   *   projectSlug: \"backend\",\n   *   query: \"level:error\",\n   *   sortBy: \"freq\"\n   * });\n   * ```\n   */\n  async listIssues(\n    {\n      organizationSlug,\n      projectSlug,\n      query,\n      sortBy,\n      limit = 10,\n    }: {\n      organizationSlug: string;\n      projectSlug?: string;\n      query?: string;\n      sortBy?: \"user\" | \"freq\" | \"date\" | \"new\";\n      limit?: number;\n    },\n    opts?: RequestOptions,\n  ): Promise<IssueList> {\n    const sentryQuery: string[] = [];\n    if (query) {\n      sentryQuery.push(query);\n    }\n\n    const queryParams = new URLSearchParams();\n    queryParams.set(\"per_page\", String(limit));\n    queryParams.set(\"referrer\", \"sentry-mcp\");\n    if (sortBy) queryParams.set(\"sort\", sortBy);\n    queryParams.set(\"statsPeriod\", \"24h\");\n    queryParams.set(\"query\", sentryQuery.join(\" \"));\n\n    queryParams.append(\"collapse\", \"unhandled\");\n\n    const apiUrl = projectSlug\n      ? `/projects/${organizationSlug}/${projectSlug}/issues/?${queryParams.toString()}`\n      : `/organizations/${organizationSlug}/issues/?${queryParams.toString()}`;\n\n    const body = await this.requestJSON(apiUrl, undefined, opts);\n    return IssueListSchema.parse(body);\n  }\n\n  async getIssue(\n    {\n      organizationSlug,\n      issueId,\n    }: {\n      organizationSlug: string;\n      issueId: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Issue> {\n    const body = await this.requestJSON(\n      `/organizations/${organizationSlug}/issues/${issueId}/`,\n      undefined,\n      opts,\n    );\n    return IssueSchema.parse(body);\n  }\n\n  async getEventForIssue(\n    {\n      organizationSlug,\n      issueId,\n      eventId,\n    }: {\n      organizationSlug: string;\n      issueId: string;\n      eventId: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Event> {\n    const body = await this.requestJSON(\n      `/organizations/${organizationSlug}/issues/${issueId}/events/${eventId}/`,\n      undefined,\n      opts,\n    );\n    return EventSchema.parse(body);\n  }\n\n  async getLatestEventForIssue(\n    {\n      organizationSlug,\n      issueId,\n    }: {\n      organizationSlug: string;\n      issueId: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Event> {\n    return this.getEventForIssue(\n      {\n        organizationSlug,\n        issueId,\n        eventId: \"latest\",\n      },\n      opts,\n    );\n  }\n\n  async listEventAttachments(\n    {\n      organizationSlug,\n      projectSlug,\n      eventId,\n    }: {\n      organizationSlug: string;\n      projectSlug: string;\n      eventId: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<EventAttachmentList> {\n    const body = await this.requestJSON(\n      `/projects/${organizationSlug}/${projectSlug}/events/${eventId}/attachments/`,\n      undefined,\n      opts,\n    );\n    return EventAttachmentListSchema.parse(body);\n  }\n\n  async getEventAttachment(\n    {\n      organizationSlug,\n      projectSlug,\n      eventId,\n      attachmentId,\n    }: {\n      organizationSlug: string;\n      projectSlug: string;\n      eventId: string;\n      attachmentId: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<{\n    attachment: EventAttachment;\n    downloadUrl: string;\n    filename: string;\n    blob: Blob;\n  }> {\n    // Get the attachment metadata first\n    const attachmentsData = await this.requestJSON(\n      `/projects/${organizationSlug}/${projectSlug}/events/${eventId}/attachments/`,\n      undefined,\n      opts,\n    );\n\n    const attachments = EventAttachmentListSchema.parse(attachmentsData);\n    const attachment = attachments.find((att) => att.id === attachmentId);\n\n    if (!attachment) {\n      throw new Error(\n        `Attachment with ID ${attachmentId} not found for event ${eventId}`,\n      );\n    }\n\n    // Download the actual file content\n    const downloadUrl = `/projects/${organizationSlug}/${projectSlug}/events/${eventId}/attachments/${attachmentId}/?download=1`;\n    const downloadResponse = await this.request(\n      downloadUrl,\n      {\n        method: \"GET\",\n        headers: {\n          Accept: \"application/octet-stream\",\n        },\n      },\n      opts,\n    );\n\n    return {\n      attachment,\n      downloadUrl: downloadResponse.url,\n      filename: attachment.name,\n      blob: await downloadResponse.blob(),\n    };\n  }\n\n  async updateIssue(\n    {\n      organizationSlug,\n      issueId,\n      status,\n      assignedTo,\n    }: {\n      organizationSlug: string;\n      issueId: string;\n      status?: string;\n      assignedTo?: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<Issue> {\n    const updateData: Record<string, any> = {};\n    if (status !== undefined) updateData.status = status;\n    if (assignedTo !== undefined) updateData.assignedTo = assignedTo;\n\n    const body = await this.requestJSON(\n      `/organizations/${organizationSlug}/issues/${issueId}/`,\n      {\n        method: \"PUT\",\n        body: JSON.stringify(updateData),\n      },\n      opts,\n    );\n    return IssueSchema.parse(body);\n  }\n\n  // TODO: Sentry is not yet exposing a reasonable API to fetch trace data\n  // async getTrace({\n  //   organizationSlug,\n  //   traceId,\n  // }: {\n  //   organizationSlug: string;\n  //   traceId: string;\n  // }): Promise<z.infer<typeof SentryIssueSchema>> {\n  //   const response = await this.request(\n  //     `/organizations/${organizationSlug}/issues/${traceId}/`,\n  //   );\n\n  //   const body = await response.json();\n  //   return SentryIssueSchema.parse(body);\n  // }\n\n  async searchErrors(\n    {\n      organizationSlug,\n      projectSlug,\n      filename,\n      transaction,\n      query,\n      sortBy = \"last_seen\",\n    }: {\n      organizationSlug: string;\n      projectSlug?: string;\n      filename?: string;\n      transaction?: string;\n      query?: string;\n      sortBy?: \"last_seen\" | \"count\";\n    },\n    opts?: RequestOptions,\n  ) {\n    const sentryQuery: string[] = [];\n    if (filename) {\n      sentryQuery.push(`stack.filename:\"*${filename.replace(/\"/g, '\\\\\"')}\"`);\n    }\n    if (transaction) {\n      sentryQuery.push(`transaction:\"${transaction.replace(/\"/g, '\\\\\"')}\"`);\n    }\n    if (query) {\n      sentryQuery.push(query);\n    }\n    if (projectSlug) {\n      sentryQuery.push(`project:${projectSlug}`);\n    }\n\n    const queryParams = new URLSearchParams();\n    queryParams.set(\"dataset\", \"errors\");\n    queryParams.set(\"per_page\", \"10\");\n    queryParams.set(\"referrer\", \"sentry-mcp\");\n    queryParams.set(\n      \"sort\",\n      `-${sortBy === \"last_seen\" ? \"last_seen\" : \"count\"}`,\n    );\n    queryParams.set(\"statsPeriod\", \"24h\");\n    queryParams.append(\"field\", \"issue\");\n    queryParams.append(\"field\", \"title\");\n    queryParams.append(\"field\", \"project\");\n    queryParams.append(\"field\", \"last_seen()\");\n    queryParams.append(\"field\", \"count()\");\n    queryParams.set(\"query\", sentryQuery.join(\" \"));\n    // if (projectSlug) queryParams.set(\"project\", projectSlug);\n\n    const apiUrl = `/organizations/${organizationSlug}/events/?${queryParams.toString()}`;\n\n    const body = await this.requestJSON(apiUrl, undefined, opts);\n    // TODO(dcramer): If you're using an older version of Sentry this API had a breaking change\n    // meaning this endpoint will error.\n    return ErrorsSearchResponseSchema.parse(body).data;\n  }\n\n  async searchSpans(\n    {\n      organizationSlug,\n      projectSlug,\n      transaction,\n      query,\n      sortBy = \"timestamp\",\n    }: {\n      organizationSlug: string;\n      projectSlug?: string;\n      transaction?: string;\n      query?: string;\n      sortBy?: \"timestamp\" | \"duration\";\n    },\n    opts?: RequestOptions,\n  ) {\n    const sentryQuery: string[] = [\"is_transaction:true\"];\n    if (transaction) {\n      sentryQuery.push(`transaction:\"${transaction.replace(/\"/g, '\\\\\"')}\"`);\n    }\n    if (query) {\n      sentryQuery.push(query);\n    }\n    if (projectSlug) {\n      sentryQuery.push(`project:${projectSlug}`);\n    }\n\n    const queryParams = new URLSearchParams();\n    queryParams.set(\"dataset\", \"spans\");\n    queryParams.set(\"per_page\", \"10\");\n    queryParams.set(\"referrer\", \"sentry-mcp\");\n    queryParams.set(\n      \"sort\",\n      `-${sortBy === \"timestamp\" ? \"timestamp\" : \"span.duration\"}`,\n    );\n    queryParams.set(\"allowAggregateConditions\", \"0\");\n    queryParams.set(\"useRpc\", \"1\");\n    queryParams.append(\"field\", \"id\");\n    queryParams.append(\"field\", \"trace\");\n    queryParams.append(\"field\", \"span.op\");\n    queryParams.append(\"field\", \"span.description\");\n    queryParams.append(\"field\", \"span.duration\");\n    queryParams.append(\"field\", \"transaction\");\n    queryParams.append(\"field\", \"project\");\n    queryParams.append(\"field\", \"timestamp\");\n    queryParams.set(\"query\", sentryQuery.join(\" \"));\n    // if (projectSlug) queryParams.set(\"project\", projectSlug);\n\n    const apiUrl = `/organizations/${organizationSlug}/events/?${queryParams.toString()}`;\n\n    const body = await this.requestJSON(apiUrl, undefined, opts);\n    return SpansSearchResponseSchema.parse(body).data;\n  }\n\n  // ================================================================================\n  // API QUERY BUILDERS FOR DIFFERENT SENTRY APIS\n  // ================================================================================\n\n  /**\n   * Builds query parameters for the legacy Discover API (primarily used by errors dataset).\n   *\n   * Note: While the API endpoint is the same for all datasets, we maintain separate\n   * builders to make future divergence easier and to keep the code organized.\n   */\n  private buildDiscoverApiQuery(params: {\n    query: string;\n    fields: string[];\n    limit: number;\n    projectSlug?: string;\n    statsPeriod?: string;\n    start?: string;\n    end?: string;\n    sort: string;\n  }): URLSearchParams {\n    const queryParams = new URLSearchParams();\n\n    // Basic parameters\n    queryParams.set(\"per_page\", params.limit.toString());\n    queryParams.set(\"query\", params.query);\n    queryParams.set(\"referrer\", \"sentry-mcp\");\n    queryParams.set(\"dataset\", \"errors\");\n\n    // Validate time parameters - can't use both relative and absolute\n    if (params.statsPeriod && (params.start || params.end)) {\n      throw new Error(\n        \"Cannot use both statsPeriod and start/end parameters. Use either statsPeriod for relative time or start/end for absolute time.\",\n      );\n    }\n    if ((params.start && !params.end) || (!params.start && params.end)) {\n      throw new Error(\n        \"Both start and end parameters must be provided together for absolute time ranges.\",\n      );\n    }\n    // Use either relative time (statsPeriod) or absolute time (start/end)\n    if (params.statsPeriod) {\n      queryParams.set(\"statsPeriod\", params.statsPeriod);\n    } else if (params.start && params.end) {\n      queryParams.set(\"start\", params.start);\n      queryParams.set(\"end\", params.end);\n    }\n\n    if (params.projectSlug) {\n      queryParams.set(\"project\", params.projectSlug);\n    }\n\n    // Sort parameter transformation for API compatibility\n    let apiSort = params.sort;\n    if (params.sort?.includes(\"(\")) {\n      // Transform: count(field) -> count_field, count() -> count\n      // Use safer string manipulation to avoid ReDoS\n      const parenStart = params.sort.indexOf(\"(\");\n      const parenEnd = params.sort.indexOf(\")\", parenStart);\n      if (parenStart !== -1 && parenEnd !== -1) {\n        const beforeParen = params.sort.substring(0, parenStart);\n        const insideParen = params.sort.substring(parenStart + 1, parenEnd);\n        const afterParen = params.sort.substring(parenEnd + 1);\n        const transformedInside = insideParen\n          ? `_${insideParen.replace(/\\./g, \"_\")}`\n          : \"\";\n        apiSort = beforeParen + transformedInside + afterParen;\n      }\n    }\n    queryParams.set(\"sort\", apiSort);\n\n    // Add fields\n    for (const field of params.fields) {\n      queryParams.append(\"field\", field);\n    }\n\n    return queryParams;\n  }\n\n  /**\n   * Builds query parameters for the modern EAP API (used by spans/logs datasets).\n   *\n   * Includes dataset-specific parameters like sampling for spans.\n   */\n  private buildEapApiQuery(params: {\n    query: string;\n    fields: string[];\n    limit: number;\n    projectSlug?: string;\n    dataset: \"spans\" | \"ourlogs\";\n    statsPeriod?: string;\n    start?: string;\n    end?: string;\n    sort: string;\n  }): URLSearchParams {\n    const queryParams = new URLSearchParams();\n\n    // Basic parameters\n    queryParams.set(\"per_page\", params.limit.toString());\n    queryParams.set(\"query\", params.query);\n    queryParams.set(\"referrer\", \"sentry-mcp\");\n    queryParams.set(\"dataset\", params.dataset);\n\n    // Validate time parameters - can't use both relative and absolute\n    if (params.statsPeriod && (params.start || params.end)) {\n      throw new Error(\n        \"Cannot use both statsPeriod and start/end parameters. Use either statsPeriod for relative time or start/end for absolute time.\",\n      );\n    }\n    if ((params.start && !params.end) || (!params.start && params.end)) {\n      throw new Error(\n        \"Both start and end parameters must be provided together for absolute time ranges.\",\n      );\n    }\n    // Use either relative time (statsPeriod) or absolute time (start/end)\n    if (params.statsPeriod) {\n      queryParams.set(\"statsPeriod\", params.statsPeriod);\n    } else if (params.start && params.end) {\n      queryParams.set(\"start\", params.start);\n      queryParams.set(\"end\", params.end);\n    }\n\n    if (params.projectSlug) {\n      queryParams.set(\"project\", params.projectSlug);\n    }\n\n    // Dataset-specific parameters\n    if (params.dataset === \"spans\") {\n      queryParams.set(\"sampling\", \"NORMAL\");\n    }\n\n    // Sort parameter transformation for API compatibility\n    let apiSort = params.sort;\n    if (params.sort?.includes(\"(\")) {\n      // Transform: count(field) -> count_field, count() -> count\n      // Use safer string manipulation to avoid ReDoS\n      const parenStart = params.sort.indexOf(\"(\");\n      const parenEnd = params.sort.indexOf(\")\", parenStart);\n      if (parenStart !== -1 && parenEnd !== -1) {\n        const beforeParen = params.sort.substring(0, parenStart);\n        const insideParen = params.sort.substring(parenStart + 1, parenEnd);\n        const afterParen = params.sort.substring(parenEnd + 1);\n        const transformedInside = insideParen\n          ? `_${insideParen.replace(/\\./g, \"_\")}`\n          : \"\";\n        apiSort = beforeParen + transformedInside + afterParen;\n      }\n    }\n    queryParams.set(\"sort\", apiSort);\n\n    // Add fields\n    for (const field of params.fields) {\n      queryParams.append(\"field\", field);\n    }\n\n    return queryParams;\n  }\n\n  /**\n   * Searches for events in Sentry using the unified events API.\n   * This method is used by the search_events tool for semantic search.\n   *\n   * Routes to the appropriate query builder based on dataset, even though\n   * the underlying API endpoint is the same. This separation makes the code\n   * cleaner and allows for future API divergence.\n   */\n  async searchEvents(\n    {\n      organizationSlug,\n      query,\n      fields,\n      limit = 10,\n      projectSlug,\n      dataset = \"spans\",\n      statsPeriod,\n      start,\n      end,\n      sort = \"-timestamp\",\n    }: {\n      organizationSlug: string;\n      query: string;\n      fields: string[];\n      limit?: number;\n      projectSlug?: string;\n      dataset?: \"spans\" | \"errors\" | \"ourlogs\";\n      statsPeriod?: string;\n      start?: string;\n      end?: string;\n      sort?: string;\n    },\n    opts?: RequestOptions,\n  ) {\n    let queryParams: URLSearchParams;\n\n    if (dataset === \"errors\") {\n      // Use Discover API query builder\n      queryParams = this.buildDiscoverApiQuery({\n        query,\n        fields,\n        limit,\n        projectSlug,\n        statsPeriod,\n        start,\n        end,\n        sort,\n      });\n    } else {\n      // Use EAP API query builder for spans and logs\n      queryParams = this.buildEapApiQuery({\n        query,\n        fields,\n        limit,\n        projectSlug,\n        dataset,\n        statsPeriod,\n        start,\n        end,\n        sort,\n      });\n    }\n\n    const apiUrl = `/organizations/${organizationSlug}/events/?${queryParams.toString()}`;\n    return await this.requestJSON(apiUrl, undefined, opts);\n  }\n\n  // POST https://us.sentry.io/api/0/issues/5485083130/autofix/\n  async startAutofix(\n    {\n      organizationSlug,\n      issueId,\n      eventId,\n      instruction = \"\",\n    }: {\n      organizationSlug: string;\n      issueId: string;\n      eventId?: string;\n      instruction?: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<AutofixRun> {\n    const body = await this.requestJSON(\n      `/organizations/${organizationSlug}/issues/${issueId}/autofix/`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          event_id: eventId,\n          instruction,\n        }),\n      },\n      opts,\n    );\n    return AutofixRunSchema.parse(body);\n  }\n\n  // GET https://us.sentry.io/api/0/issues/5485083130/autofix/\n  async getAutofixState(\n    {\n      organizationSlug,\n      issueId,\n    }: {\n      organizationSlug: string;\n      issueId: string;\n    },\n    opts?: RequestOptions,\n  ): Promise<AutofixRunState> {\n    const body = await this.requestJSON(\n      `/organizations/${organizationSlug}/issues/${issueId}/autofix/`,\n      undefined,\n      opts,\n    );\n    return AutofixRunStateSchema.parse(body);\n  }\n}\n"],"mappings":"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"}