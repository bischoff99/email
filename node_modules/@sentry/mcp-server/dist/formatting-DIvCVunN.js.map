{"version":3,"file":"formatting-DIvCVunN.js","names":["LANGUAGE_EXTENSIONS: Record<string, string>","LANGUAGE_MODULE_PATTERNS: Array<[RegExp, string]>","frame: z.infer<typeof FrameInterface>","platform?: string | null","frameIndex?: number","event: Event","parts: string[]","data: z.infer<typeof ErrorEntrySchema>","platform: string | null","index: number","totalExceptions: number","data: z.infer<typeof RequestEntrySchema>","data: z.infer<typeof MessageEntrySchema>","data: z.infer<typeof ThreadsEntrySchema>","lines: string[]","value: unknown","vars: Record<string, unknown>","frames: z.infer<typeof FrameInterface>[]","contexts: z.infer<typeof EventSchema>[\"contexts\"]","autofixState: AutofixRunState"],"sources":["../src/internal/formatting.ts"],"sourcesContent":["/**\n * LLM response formatting utilities for Sentry data.\n *\n * Converts Sentry API responses into structured markdown format optimized\n * for LLM consumption. Handles stacktraces, event details, issue summaries,\n * and contextual information with consistent formatting patterns.\n */\nimport type { z } from \"zod\";\nimport type { Event, Issue, AutofixRunState } from \"../api-client/types\";\nimport type {\n  ErrorEntrySchema,\n  ErrorEventSchema,\n  EventSchema,\n  FrameInterface,\n  RequestEntrySchema,\n  MessageEntrySchema,\n  ThreadsEntrySchema,\n  SentryApiService,\n} from \"../api-client\";\nimport {\n  getOutputForAutofixStep,\n  getStatusDisplayName,\n  isTerminalStatus,\n} from \"../tools/utils/seer-utils\";\n\n// Language detection mappings\nconst LANGUAGE_EXTENSIONS: Record<string, string> = {\n  \".java\": \"java\",\n  \".py\": \"python\",\n  \".js\": \"javascript\",\n  \".jsx\": \"javascript\",\n  \".ts\": \"javascript\",\n  \".tsx\": \"javascript\",\n  \".rb\": \"ruby\",\n  \".php\": \"php\",\n};\n\nconst LANGUAGE_MODULE_PATTERNS: Array<[RegExp, string]> = [\n  [/^(java\\.|com\\.|org\\.)/, \"java\"],\n];\n\n/**\n * Detects the programming language of a stack frame based on the file extension.\n * Falls back to the platform parameter if no filename is available or extension is unrecognized.\n *\n * @param frame - The stack frame containing file and location information\n * @param platform - Optional platform hint to use as fallback\n * @returns The detected language or platform fallback or \"unknown\"\n */\nfunction detectLanguage(\n  frame: z.infer<typeof FrameInterface>,\n  platform?: string | null,\n): string {\n  // Check filename extensions\n  if (frame.filename) {\n    const ext = frame.filename.toLowerCase().match(/\\.[^.]+$/)?.[0];\n    if (ext && LANGUAGE_EXTENSIONS[ext]) {\n      return LANGUAGE_EXTENSIONS[ext];\n    }\n  }\n\n  // Check module patterns\n  if (frame.module) {\n    for (const [pattern, language] of LANGUAGE_MODULE_PATTERNS) {\n      if (pattern.test(frame.module)) {\n        return language;\n      }\n    }\n  }\n\n  // Fallback to platform or unknown\n  return platform || \"unknown\";\n}\n\n/**\n * Formats a stack frame into a language-specific string representation.\n * Different languages have different conventions for displaying stack traces.\n *\n * @param frame - The stack frame to format\n * @param frameIndex - Optional frame index for languages that display frame numbers\n * @param platform - Optional platform hint for language detection fallback\n * @returns Formatted stack frame string\n */\nexport function formatFrameHeader(\n  frame: z.infer<typeof FrameInterface>,\n  frameIndex?: number,\n  platform?: string | null,\n) {\n  const language = detectLanguage(frame, platform);\n\n  switch (language) {\n    case \"java\": {\n      // at com.example.ClassName.methodName(FileName.java:123)\n      const className = frame.module || \"UnknownClass\";\n      const method = frame.function || \"<unknown>\";\n      const source = frame.filename || \"Unknown Source\";\n      const location = frame.lineNo ? `:${frame.lineNo}` : \"\";\n      return `at ${className}.${method}(${source}${location})`;\n    }\n\n    case \"python\": {\n      // File \"/path/to/file.py\", line 42, in function_name\n      const file =\n        frame.filename || frame.absPath || frame.module || \"<unknown>\";\n      const func = frame.function || \"<module>\";\n      const line = frame.lineNo ? `, line ${frame.lineNo}` : \"\";\n      return `  File \"${file}\"${line}, in ${func}`;\n    }\n\n    case \"javascript\": {\n      // Original compact format: filename:line:col (function)\n      // This preserves backward compatibility\n      return `${[frame.filename, frame.lineNo, frame.colNo]\n        .filter((i) => !!i)\n        .join(\":\")}${frame.function ? ` (${frame.function})` : \"\"}`;\n    }\n\n    case \"ruby\": {\n      // from /path/to/file.rb:42:in `method_name'\n      const file = frame.filename || frame.module || \"<unknown>\";\n      const func = frame.function ? ` \\`${frame.function}\\`` : \"\";\n      const line = frame.lineNo ? `:${frame.lineNo}:in` : \"\";\n      return `    from ${file}${line}${func}`;\n    }\n\n    case \"php\": {\n      // #0 /path/to/file.php(42): functionName()\n      const file = frame.filename || \"<unknown>\";\n      const line = frame.lineNo ? `(${frame.lineNo})` : \"\";\n      const func = frame.function || \"<unknown>\";\n      const prefix = frameIndex !== undefined ? `#${frameIndex} ` : \"\";\n      return `${prefix}${file}${line}: ${func}()`;\n    }\n\n    default: {\n      // Generic format for unknown languages\n      const func = frame.function || \"<unknown>\";\n      const location = frame.filename || frame.module || \"<unknown>\";\n      const line = frame.lineNo ? `:${frame.lineNo}` : \"\";\n      const col = frame.colNo != null ? `:${frame.colNo}` : \"\";\n      return `    at ${func} (${location}${line}${col})`;\n    }\n  }\n}\n\n/**\n * Formats a Sentry event into a structured markdown output.\n * Includes error messages, stack traces, request info, and contextual data.\n *\n * @param event - The Sentry event to format\n * @returns Formatted markdown string\n */\nexport function formatEventOutput(event: Event) {\n  let output = \"\";\n\n  // Look for the primary error information\n  const messageEntry = event.entries.find((e) => e.type === \"message\");\n  const exceptionEntry = event.entries.find((e) => e.type === \"exception\");\n  const threadsEntry = event.entries.find((e) => e.type === \"threads\");\n  const requestEntry = event.entries.find((e) => e.type === \"request\");\n\n  // Error message (if present)\n  if (messageEntry) {\n    output += formatMessageInterfaceOutput(\n      event,\n      messageEntry.data as z.infer<typeof MessageEntrySchema>,\n    );\n  }\n\n  // Stack trace (from exception or threads)\n  if (exceptionEntry) {\n    output += formatExceptionInterfaceOutput(\n      event,\n      exceptionEntry.data as z.infer<typeof ErrorEntrySchema>,\n    );\n  } else if (threadsEntry) {\n    output += formatThreadsInterfaceOutput(\n      event,\n      threadsEntry.data as z.infer<typeof ThreadsEntrySchema>,\n    );\n  }\n\n  // Request info (if HTTP error)\n  if (requestEntry) {\n    output += formatRequestInterfaceOutput(\n      event,\n      requestEntry.data as z.infer<typeof RequestEntrySchema>,\n    );\n  }\n\n  output += formatContexts(event.contexts);\n  return output;\n}\n\n/**\n * Extracts the context line matching the frame's line number for inline display.\n * This is used in the full stacktrace view to show the actual line of code\n * that caused the error inline with the stack frame.\n *\n * @param frame - The stack frame containing context lines\n * @returns The line of code at the frame's line number, or empty string if not available\n */\nfunction renderInlineContext(frame: z.infer<typeof FrameInterface>): string {\n  if (!frame.context?.length || !frame.lineNo) {\n    return \"\";\n  }\n\n  const contextLine = frame.context.find(([lineNo]) => lineNo === frame.lineNo);\n  return contextLine ? `\\n${contextLine[1]}` : \"\";\n}\n\n/**\n * Renders an enhanced view of a stack frame with context lines and variables.\n * Used for the \"Most Relevant Frame\" section to provide detailed information\n * about the most relevant application frame where the error occurred.\n *\n * @param frame - The stack frame to render with enhanced information\n * @param event - The Sentry event containing platform information for language detection\n * @returns Formatted string with frame header, context lines, and variables table\n */\nfunction renderEnhancedFrame(\n  frame: z.infer<typeof FrameInterface>,\n  event: Event,\n): string {\n  const parts: string[] = [];\n\n  parts.push(\"**Most Relevant Frame:**\");\n  parts.push(\"─────────────────────\");\n  parts.push(formatFrameHeader(frame, undefined, event.platform));\n\n  // Add context lines if available\n  if (frame.context?.length) {\n    const contextLines = renderContextLines(frame);\n    if (contextLines) {\n      parts.push(\"\");\n      parts.push(contextLines);\n    }\n  }\n\n  // Add variables table if available\n  if (frame.vars && Object.keys(frame.vars).length > 0) {\n    parts.push(\"\");\n    parts.push(renderVariablesTable(frame.vars));\n  }\n\n  return parts.join(\"\\n\");\n}\n\nfunction formatExceptionInterfaceOutput(\n  event: Event,\n  data: z.infer<typeof ErrorEntrySchema>,\n) {\n  const parts: string[] = [];\n\n  // Handle both single exception (value) and chained exceptions (values)\n  const exceptions = data.values || (data.value ? [data.value] : []);\n\n  if (exceptions.length === 0) {\n    return \"\";\n  }\n\n  // For chained exceptions, they are typically ordered from innermost to outermost\n  // We'll render them in reverse order (outermost first) to match how they occurred\n  const isChained = exceptions.length > 1;\n\n  // Create a copy before reversing to avoid mutating the original array\n  [...exceptions].reverse().forEach((exception, index) => {\n    if (!exception) return;\n\n    // Add language-specific chain indicator for multiple exceptions\n    if (isChained && index > 0) {\n      parts.push(\"\");\n      parts.push(\n        getExceptionChainMessage(\n          event.platform || null,\n          index,\n          exceptions.length,\n        ),\n      );\n      parts.push(\"\");\n    }\n\n    // Use the actual exception type and value as the heading\n    const exceptionTitle = `${exception.type}${exception.value ? `: ${exception.value}` : \"\"}`;\n\n    parts.push(index === 0 ? \"### Error\" : `### ${exceptionTitle}`);\n    parts.push(\"\");\n\n    // Add the error details in a code block for the first exception\n    // to maintain backward compatibility\n    if (index === 0) {\n      parts.push(\"```\");\n      parts.push(exceptionTitle);\n      parts.push(\"```\");\n      parts.push(\"\");\n    }\n\n    if (!exception.stacktrace || !exception.stacktrace.frames) {\n      parts.push(\"**Stacktrace:**\");\n      parts.push(\"```\");\n      parts.push(\"No stacktrace available\");\n      parts.push(\"```\");\n      return;\n    }\n\n    const frames = exception.stacktrace.frames;\n\n    // Only show enhanced frame for the first (outermost) exception to avoid overwhelming output\n    if (index === 0) {\n      const firstInAppFrame = findFirstInAppFrame(frames);\n      if (\n        firstInAppFrame &&\n        (firstInAppFrame.context?.length || firstInAppFrame.vars)\n      ) {\n        parts.push(renderEnhancedFrame(firstInAppFrame, event));\n        parts.push(\"\");\n        parts.push(\"**Full Stacktrace:**\");\n        parts.push(\"────────────────\");\n      } else {\n        parts.push(\"**Stacktrace:**\");\n      }\n    } else {\n      parts.push(\"**Stacktrace:**\");\n    }\n\n    parts.push(\"```\");\n    parts.push(\n      frames\n        .map((frame) => {\n          const header = formatFrameHeader(frame, undefined, event.platform);\n          const context = renderInlineContext(frame);\n          return `${header}${context}`;\n        })\n        .join(\"\\n\"),\n    );\n    parts.push(\"```\");\n  });\n\n  parts.push(\"\");\n  parts.push(\"\");\n\n  return parts.join(\"\\n\");\n}\n\n/**\n * Get the appropriate exception chain message based on the platform\n */\nfunction getExceptionChainMessage(\n  platform: string | null,\n  index: number,\n  totalExceptions: number,\n): string {\n  // Default message for unknown platforms\n  const defaultMessage =\n    \"**During handling of the above exception, another exception occurred:**\";\n\n  if (!platform) {\n    return defaultMessage;\n  }\n\n  switch (platform.toLowerCase()) {\n    case \"python\":\n      // Python has two distinct messages, but without additional metadata\n      // we default to the implicit chaining message\n      return \"**During handling of the above exception, another exception occurred:**\";\n\n    case \"java\":\n      return \"**Caused by:**\";\n\n    case \"csharp\":\n    case \"dotnet\":\n      return \"**---> Inner Exception:**\";\n\n    case \"ruby\":\n      return \"**Caused by:**\";\n\n    case \"go\":\n      return \"**Wrapped error:**\";\n\n    case \"rust\":\n      return `**Caused by (${index}):**`;\n\n    default:\n      return defaultMessage;\n  }\n}\n\nfunction formatRequestInterfaceOutput(\n  event: Event,\n  data: z.infer<typeof RequestEntrySchema>,\n) {\n  if (!data.method || !data.url) {\n    return \"\";\n  }\n  return `### HTTP Request\\n\\n**Method:** ${data.method}\\n**URL:** ${data.url}\\n\\n`;\n}\n\nfunction formatMessageInterfaceOutput(\n  event: Event,\n  data: z.infer<typeof MessageEntrySchema>,\n) {\n  if (!data.formatted && !data.message) {\n    return \"\";\n  }\n  const message = data.formatted || data.message || \"\";\n  return `### Error\\n\\n${\"```\"}\\n${message}\\n${\"```\"}\\n\\n`;\n}\n\nfunction formatThreadsInterfaceOutput(\n  event: Event,\n  data: z.infer<typeof ThreadsEntrySchema>,\n) {\n  if (!data.values || data.values.length === 0) {\n    return \"\";\n  }\n\n  // Find the crashed thread only\n  const crashedThread = data.values.find((t) => t.crashed);\n\n  if (!crashedThread?.stacktrace?.frames) {\n    return \"\";\n  }\n\n  const parts: string[] = [];\n\n  // Include thread name if available\n  if (crashedThread.name) {\n    parts.push(`**Thread** (${crashedThread.name})`);\n    parts.push(\"\");\n  }\n\n  const frames = crashedThread.stacktrace.frames;\n\n  // Find and format the first in-app frame with enhanced view\n  const firstInAppFrame = findFirstInAppFrame(frames);\n  if (\n    firstInAppFrame &&\n    (firstInAppFrame.context?.length || firstInAppFrame.vars)\n  ) {\n    parts.push(renderEnhancedFrame(firstInAppFrame, event));\n    parts.push(\"\");\n    parts.push(\"**Full Stacktrace:**\");\n    parts.push(\"────────────────\");\n  } else {\n    parts.push(\"**Stacktrace:**\");\n  }\n\n  parts.push(\"```\");\n  parts.push(\n    frames\n      .map((frame) => {\n        const header = formatFrameHeader(frame, undefined, event.platform);\n        const context = renderInlineContext(frame);\n        return `${header}${context}`;\n      })\n      .join(\"\\n\"),\n  );\n  parts.push(\"```\");\n  parts.push(\"\");\n\n  return parts.join(\"\\n\");\n}\n\n/**\n * Renders surrounding source code context for a stack frame.\n * Shows a window of code lines around the error line with visual indicators.\n *\n * @param frame - The stack frame containing context lines\n * @param contextSize - Number of lines to show before and after the error line (default: 3)\n * @returns Formatted context lines with line numbers and arrow indicator for the error line\n */\nfunction renderContextLines(\n  frame: z.infer<typeof FrameInterface>,\n  contextSize = 3,\n): string {\n  if (!frame.context || frame.context.length === 0 || !frame.lineNo) {\n    return \"\";\n  }\n\n  const lines: string[] = [];\n  const errorLine = frame.lineNo;\n  const maxLineNoWidth = Math.max(\n    ...frame.context.map(([lineNo]) => lineNo.toString().length),\n  );\n\n  for (const [lineNo, code] of frame.context) {\n    const isErrorLine = lineNo === errorLine;\n    const lineNoStr = lineNo.toString().padStart(maxLineNoWidth, \" \");\n\n    if (Math.abs(lineNo - errorLine) <= contextSize) {\n      if (isErrorLine) {\n        lines.push(`  → ${lineNoStr} │ ${code}`);\n      } else {\n        lines.push(`    ${lineNoStr} │ ${code}`);\n      }\n    }\n  }\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Formats a variable value for display in the variables table.\n * Handles different types appropriately and safely, converting complex objects\n * to readable representations and handling edge cases like circular references.\n *\n * @param value - The variable value to format (can be any type)\n * @param maxLength - Maximum length for stringified objects/arrays (default: 80)\n * @returns Human-readable string representation of the value\n */\nfunction formatVariableValue(value: unknown, maxLength = 80): string {\n  try {\n    if (typeof value === \"string\") {\n      return `\"${value}\"`;\n    }\n    if (value === null) {\n      return \"null\";\n    }\n    if (value === undefined) {\n      return \"undefined\";\n    }\n    if (typeof value === \"object\") {\n      const stringified = JSON.stringify(value);\n      if (stringified.length > maxLength) {\n        // Leave room for \", ...]\" or \", ...}\"\n        const truncateAt = maxLength - 6;\n        let truncated = stringified.substring(0, truncateAt);\n\n        // Find the last complete element by looking for the last comma\n        const lastComma = truncated.lastIndexOf(\",\");\n        if (lastComma > 0) {\n          truncated = truncated.substring(0, lastComma);\n        }\n\n        // Add the appropriate ending\n        if (Array.isArray(value)) {\n          return `${truncated}, ...]`;\n        }\n        return `${truncated}, ...}`;\n      }\n      return stringified;\n    }\n    return String(value);\n  } catch {\n    // Handle circular references or other stringify errors\n    return `<${typeof value}>`;\n  }\n}\n\n/**\n * Renders a table of local variables in a tree-like format.\n * Uses box-drawing characters to create a visual hierarchy of variables\n * and their values at the point where the error occurred.\n *\n * @param vars - Object containing variable names as keys and their values\n * @returns Formatted variables table with tree-style prefix characters\n */\nfunction renderVariablesTable(vars: Record<string, unknown>): string {\n  const entries = Object.entries(vars);\n  if (entries.length === 0) {\n    return \"\";\n  }\n\n  const lines: string[] = [\"Local Variables:\"];\n  const lastIndex = entries.length - 1;\n\n  entries.forEach(([key, value], index) => {\n    const prefix = index === lastIndex ? \"└─\" : \"├─\";\n    const valueStr = formatVariableValue(value);\n    lines.push(`${prefix} ${key}: ${valueStr}`);\n  });\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Finds the first application frame (in_app) in a stack trace.\n * Searches from the bottom of the stack (oldest frame) to find the first\n * frame that belongs to the user's application code rather than libraries.\n *\n * @param frames - Array of stack frames, typically in reverse chronological order\n * @returns The first in-app frame found, or undefined if none exist\n */\nfunction findFirstInAppFrame(\n  frames: z.infer<typeof FrameInterface>[],\n): z.infer<typeof FrameInterface> | undefined {\n  // Frames are usually in reverse order (most recent first)\n  // We want the first in-app frame from the bottom\n  for (let i = frames.length - 1; i >= 0; i--) {\n    if (frames[i].inApp === true) {\n      return frames[i];\n    }\n  }\n  return undefined;\n}\n\nfunction formatContexts(contexts: z.infer<typeof EventSchema>[\"contexts\"]) {\n  if (!contexts || Object.keys(contexts).length === 0) {\n    return \"\";\n  }\n  return `### Additional Context\\n\\nThese are additional context provided by the user when they're instrumenting their application.\\n\\n${Object.entries(\n    contexts,\n  )\n    .map(\n      ([name, data]) =>\n        `**${name}**\\n${Object.entries(data)\n          .filter(([key, _]) => key !== \"type\")\n          .map(([key, value]) => {\n            return `${key}: ${JSON.stringify(value, undefined, 2)}`;\n          })\n          .join(\"\\n\")}`,\n    )\n    .join(\"\\n\\n\")}\\n\\n`;\n}\n\n/**\n * Formats Seer AI analysis context for inclusion in issue details.\n * Provides a minimal summary showing just the key solution when available.\n *\n * @param autofixState - The autofix state containing Seer analysis data\n * @returns Formatted markdown string with Seer context, or empty string if no analysis exists\n */\nfunction formatSeerContext(autofixState: AutofixRunState): string {\n  if (!autofixState.autofix) {\n    return \"\";\n  }\n\n  const { autofix } = autofixState;\n  const parts: string[] = [];\n\n  parts.push(\"## Seer AI Analysis\");\n  parts.push(\"\");\n\n  // For completed analyses, show just the key solution\n  if (isTerminalStatus(autofix.status) && autofix.steps.length > 0) {\n    const completedSteps = autofix.steps.filter(\n      (step) => step.status === \"COMPLETED\",\n    );\n\n    // Find the solution step and show its description directly\n    const solutionStep = completedSteps.find(\n      (step) => step.type === \"solution\",\n    );\n\n    if (solutionStep) {\n      // For solution steps, use the description directly\n      const solutionDescription = solutionStep.description;\n      if (\n        solutionDescription &&\n        typeof solutionDescription === \"string\" &&\n        solutionDescription.trim()\n      ) {\n        parts.push(solutionDescription.trim());\n      } else {\n        // Fallback to extracting from output if no description\n        const solutionOutput = getOutputForAutofixStep(solutionStep);\n        const lines = solutionOutput.split(\"\\n\");\n        const firstParagraph = lines.find(\n          (line) =>\n            line.trim().length > 50 &&\n            !line.startsWith(\"#\") &&\n            !line.startsWith(\"*\"),\n        );\n        if (firstParagraph) {\n          parts.push(firstParagraph.trim());\n        }\n      }\n    }\n  }\n  return `${parts.join(\"\\n\")}\\n\\n`;\n}\n\n/**\n * Formats a Sentry issue with its latest event into comprehensive markdown output.\n * Includes issue metadata, event details, and usage instructions.\n *\n * @param params - Object containing organization slug, issue, event, and API service\n * @returns Formatted markdown string with complete issue information\n */\nexport function formatIssueOutput({\n  organizationSlug,\n  issue,\n  event,\n  apiService,\n  autofixState,\n}: {\n  organizationSlug: string;\n  issue: Issue;\n  event: Event;\n  apiService: SentryApiService;\n  autofixState?: AutofixRunState;\n}) {\n  let output = `# Issue ${issue.shortId} in **${organizationSlug}**\\n\\n`;\n  output += `**Description**: ${issue.title}\\n`;\n  output += `**Culprit**: ${issue.culprit}\\n`;\n  output += `**First Seen**: ${new Date(issue.firstSeen).toISOString()}\\n`;\n  output += `**Last Seen**: ${new Date(issue.lastSeen).toISOString()}\\n`;\n  output += `**Occurrences**: ${issue.count}\\n`;\n  output += `**Users Impacted**: ${issue.userCount}\\n`;\n  output += `**Status**: ${issue.status}\\n`;\n  output += `**Platform**: ${issue.platform}\\n`;\n  output += `**Project**: ${issue.project.name}\\n`;\n  output += `**URL**: ${apiService.getIssueUrl(organizationSlug, issue.shortId)}\\n`;\n  output += \"\\n\";\n  output += \"## Event Details\\n\\n\";\n  output += `**Event ID**: ${event.id}\\n`;\n  if (event.type === \"error\") {\n    output += `**Occurred At**: ${new Date((event as z.infer<typeof ErrorEventSchema>).dateCreated).toISOString()}\\n`;\n  }\n  if (event.message) {\n    output += `**Message**:\\n${event.message}\\n`;\n  }\n  output += \"\\n\";\n  output += formatEventOutput(event);\n\n  // Add Seer context if available\n  if (autofixState) {\n    output += formatSeerContext(autofixState);\n  }\n\n  output += \"# Using this information\\n\\n\";\n  output += `- You can reference the IssueID in commit messages (e.g. \\`Fixes ${issue.shortId}\\`) to automatically close the issue when the commit is merged.\\n`;\n  output +=\n    \"- The stacktrace includes both first-party application code as well as third-party code, its important to triage to first-party code.\\n\";\n  return output;\n}\n"],"mappings":"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"}