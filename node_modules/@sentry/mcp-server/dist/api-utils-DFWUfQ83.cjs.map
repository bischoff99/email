{"version":3,"file":"api-utils-DFWUfQ83.cjs","names":["context: ServerContext","opts: { regionUrl?: string }","UserInputError","SentryApiService","error: unknown","params?: Record<string, unknown>","ApiError","paramsList: string[]","fn: () => Promise<T>"],"sources":["../src/tools/utils/api-utils.ts"],"sourcesContent":["import { SentryApiService, ApiError } from \"../../api-client/index\";\nimport { UserInputError } from \"../../errors\";\nimport type { ServerContext } from \"../../types\";\n\n/**\n * Create a Sentry API service from server context with optional region override\n * @param context - Server context containing host and access token\n * @param opts - Options object containing optional regionUrl override\n * @returns Configured SentryApiService instance (always uses HTTPS)\n * @throws {UserInputError} When regionUrl is provided but invalid\n */\nexport function apiServiceFromContext(\n  context: ServerContext,\n  opts: { regionUrl?: string } = {},\n) {\n  let host = context.sentryHost;\n\n  if (opts.regionUrl?.trim()) {\n    try {\n      const parsedUrl = new URL(opts.regionUrl);\n\n      // Validate that the URL has a proper protocol\n      if (![\"http:\", \"https:\"].includes(parsedUrl.protocol)) {\n        throw new UserInputError(\n          `Invalid regionUrl provided: ${opts.regionUrl}. Must include protocol (http:// or https://).`,\n        );\n      }\n\n      // Validate that the host is not just the protocol name\n      if (parsedUrl.host === \"https\" || parsedUrl.host === \"http\") {\n        throw new UserInputError(\n          `Invalid regionUrl provided: ${opts.regionUrl}. The host cannot be just a protocol name.`,\n        );\n      }\n\n      host = parsedUrl.host;\n    } catch (error) {\n      if (error instanceof UserInputError) {\n        throw error;\n      }\n      throw new UserInputError(\n        `Invalid regionUrl provided: ${opts.regionUrl}. Must be a valid URL.`,\n      );\n    }\n  }\n\n  return new SentryApiService({\n    host,\n    accessToken: context.accessToken,\n  });\n}\n\n/**\n * Maps API errors to user-friendly errors based on context\n * @param error - The error to handle\n * @param params - The parameters that were used in the API call\n * @returns Never - always throws an error\n * @throws {UserInputError} For 4xx errors that are likely user input issues\n * @throws {Error} For other errors\n */\nexport function handleApiError(\n  error: unknown,\n  params?: Record<string, unknown>,\n): never {\n  if (error instanceof ApiError) {\n    // For 4xx errors, convert to UserInputError with status code in message\n    // This provides agents with the specific error type while using the appropriate error class\n    if (error.status >= 400 && error.status < 500) {\n      let message = `API error (${error.status}): ${error.message}`;\n\n      // For 404s, add helpful context about parameters if available\n      if (error.status === 404 && params) {\n        const paramsList: string[] = [];\n        for (const [key, value] of Object.entries(params)) {\n          if (value !== undefined && value !== null && value !== \"\") {\n            paramsList.push(`${key}: '${value}'`);\n          }\n        }\n\n        if (paramsList.length > 0) {\n          message = `Resource not found (404): ${error.message}\\nPlease verify these parameters are correct:\\n${paramsList.map((p) => `  - ${p}`).join(\"\\n\")}`;\n        }\n      }\n\n      throw new UserInputError(message, { cause: error });\n    }\n  }\n\n  // Re-throw any other errors as-is (including 5xx server errors)\n  throw error;\n}\n\n/**\n * Wraps an async API call with automatic error handling\n * @param fn - The async function to execute\n * @param params - The parameters that were used in the API call\n * @returns The result of the function\n * @throws {UserInputError} For user input errors\n * @throws {Error} For other errors\n */\nexport async function withApiErrorHandling<T>(\n  fn: () => Promise<T>,\n  params?: Record<string, unknown>,\n): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    handleApiError(error, params);\n  }\n}\n"],"mappings":";;;;;;;;;;;AAWA,SAAgB,sBACdA,SACAC,OAA+B,CAAE,GACjC;CACA,IAAI,OAAO,QAAQ;AAEnB,KAAI,KAAK,WAAW,MAAM,CACxB,KAAI;EACF,MAAM,YAAY,IAAI,IAAI,KAAK;AAG/B,OAAK,CAAC,SAAS,QAAS,EAAC,SAAS,UAAU,SAAS,CACnD,OAAM,IAAIC,+BACP,8BAA8B,KAAK,UAAU;AAKlD,MAAI,UAAU,SAAS,WAAW,UAAU,SAAS,OACnD,OAAM,IAAIA,+BACP,8BAA8B,KAAK,UAAU;AAIlD,SAAO,UAAU;CAClB,SAAQ,OAAO;AACd,MAAI,iBAAiBA,8BACnB,OAAM;AAER,QAAM,IAAIA,+BACP,8BAA8B,KAAK,UAAU;CAEjD;AAGH,QAAO,IAAIC,gCAAiB;EAC1B;EACA,aAAa,QAAQ;CACtB;AACF;;;;;;;;;AAUD,SAAgB,eACdC,OACAC,QACO;AACP,KAAI,iBAAiBC,yBAGnB;MAAI,MAAM,UAAU,OAAO,MAAM,SAAS,KAAK;GAC7C,IAAI,WAAW,aAAa,MAAM,OAAO,KAAK,MAAM;AAGpD,OAAI,MAAM,WAAW,OAAO,QAAQ;IAClC,MAAMC,aAAuB,CAAE;AAC/B,SAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,QAAQ,OAAO,CAC/C,KAAI,oBAAuB,UAAU,QAAQ,UAAU,GACrD,YAAW,QAAQ,IAAI,KAAK,MAAM,GAAG;AAIzC,QAAI,WAAW,SAAS,EACtB,YAAW,4BAA4B,MAAM,QAAQ,iDAAiD,WAAW,IAAI,CAAC,OAAO,MAAM,IAAI,CAAC,KAAK,KAAK;GAErJ;AAED,SAAM,IAAIL,8BAAe,SAAS,EAAE,OAAO,MAAO;EACnD;;AAIH,OAAM;AACP;;;;;;;;;AAUD,eAAsB,qBACpBM,IACAH,QACY;AACZ,KAAI;AACF,SAAO,MAAM,IAAI;CAClB,SAAQ,OAAO;AACd,iBAAe,OAAO,OAAO;CAC9B;AACF"}