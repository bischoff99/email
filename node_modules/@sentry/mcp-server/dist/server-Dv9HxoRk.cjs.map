{"version":3,"file":"server-Dv9HxoRk.cjs","names":["error: unknown","ApiError","UserInputError","ConfigurationError","eventId","args: Record<string, unknown>","resource: { name: string; handler: ReadResourceCallback }","context: ServerContext","uri: URL","extra: RequestHandlerExtra<any, any>","LIB_VERSION","variables: Variables","RESOURCES","PROMPT_DEFINITIONS","PROMPT_HANDLERS","MCP_SERVER_NAME","tools","params: any","extra: RequestHandlerExtra<ServerRequest, ServerNotification>"],"sources":["../src/server.ts"],"sourcesContent":["/**\n * MCP Server Configuration and Request Handling Infrastructure.\n *\n * This module orchestrates tool execution, prompt handling, resource management,\n * and telemetry collection in a unified server interface for LLMs.\n *\n * **Configuration Example:**\n * ```typescript\n * const server = new McpServer();\n * const context: ServerContext = {\n *   accessToken: \"your-sentry-token\",\n *   host: \"sentry.io\",\n *   userId: \"user-123\",\n *   clientId: \"mcp-client\"\n * };\n *\n * await configureServer({ server, context });\n * ```\n */\nimport type { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { RequestHandlerExtra } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport type {\n  ServerRequest,\n  ServerNotification,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type {\n  ReadResourceCallback,\n  ReadResourceTemplateCallback,\n} from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { Variables } from \"@modelcontextprotocol/sdk/shared/uriTemplate.js\";\nimport tools from \"./tools/index\";\nimport type { ServerContext } from \"./types\";\nimport { setTag, setUser, startNewTrace, startSpan } from \"@sentry/core\";\nimport { logError } from \"./logging\";\nimport { RESOURCES, isTemplateResource } from \"./resources\";\nimport { PROMPT_DEFINITIONS } from \"./promptDefinitions\";\nimport { PROMPT_HANDLERS } from \"./prompts\";\nimport { ApiError } from \"./api-client\";\nimport { UserInputError, ConfigurationError } from \"./errors\";\nimport { LIB_VERSION } from \"./version\";\nimport { MCP_SERVER_NAME } from \"./constants\";\n\n/**\n * Type guard to identify Sentry API errors.\n */\nfunction isApiError(error: unknown): error is ApiError {\n  return error instanceof ApiError;\n}\n\n/**\n * Type guard to identify user input validation errors.\n */\nfunction isUserInputError(error: unknown): error is UserInputError {\n  return error instanceof UserInputError;\n}\n\n/**\n * Type guard to identify configuration errors.\n */\nfunction isConfigurationError(error: unknown): error is ConfigurationError {\n  return error instanceof ConfigurationError;\n}\n\n/**\n * Formats errors for LLM consumption with appropriate telemetry handling.\n *\n * **Error Types:**\n * - User Input Errors: Clear guidance without telemetry\n * - Configuration Errors: Configuration guidance without telemetry\n * - API Errors: Enhanced messaging with HTTP status context\n * - System Errors: Full telemetry capture with event IDs\n *\n * @example User Input Error Response\n * ```markdown\n * **Input Error**\n *\n * It looks like there was a problem with the input you provided.\n * Organization slug is required. Please provide an organizationSlug parameter.\n * You may be able to resolve the issue by addressing the concern and trying again.\n * ```\n *\n * @example Configuration Error Response\n * ```markdown\n * **Configuration Error**\n *\n * There appears to be a configuration issue with your setup.\n * Unable to connect to sentry.invalid.com - Hostname not found. Verify the URL is correct.\n * Please check your environment configuration and try again.\n * ```\n */\nasync function logAndFormatError(error: unknown) {\n  if (isUserInputError(error)) {\n    return [\n      \"**Input Error**\",\n      \"It looks like there was a problem with the input you provided.\",\n      error.message,\n      `You may be able to resolve the issue by addressing the concern and trying again.`,\n    ].join(\"\\n\\n\");\n  }\n\n  if (isConfigurationError(error)) {\n    return [\n      \"**Configuration Error**\",\n      \"There appears to be a configuration issue with your setup.\",\n      error.message,\n      `Please check your environment configuration and try again.`,\n    ].join(\"\\n\\n\");\n  }\n\n  if (isApiError(error)) {\n    // Log 500+ errors to Sentry for debugging\n    const eventId = error.status >= 500 ? logError(error) : undefined;\n\n    return [\n      \"**Error**\",\n      `There was an HTTP ${error.status} error with your request to the Sentry API.`,\n      `${error.message}`,\n      eventId ? `**Event ID**: ${eventId}` : \"\",\n      `You may be able to resolve the issue by addressing the concern and trying again.`,\n    ]\n      .filter(Boolean)\n      .join(\"\\n\\n\");\n  }\n\n  const eventId = logError(error);\n\n  return [\n    \"**Error**\",\n    \"It looks like there was a problem communicating with the Sentry API.\",\n    \"Please report the following to the user for the Sentry team:\",\n    `**Event ID**: ${eventId}`,\n    process.env.NODE_ENV !== \"production\"\n      ? error instanceof Error\n        ? error.message\n        : String(error)\n      : \"\",\n  ].join(\"\\n\\n\");\n}\n\n/**\n * Extracts MCP request parameters for OpenTelemetry attributes.\n *\n * @example Parameter Transformation\n * ```typescript\n * const input = { organizationSlug: \"my-org\", query: \"is:unresolved\" };\n * const output = extractMcpParameters(input);\n * // { \"mcp.request.argument.organizationSlug\": \"\\\"my-org\\\"\", \"mcp.request.argument.query\": \"\\\"is:unresolved\\\"\" }\n * ```\n */\nfunction extractMcpParameters(args: Record<string, unknown>) {\n  return Object.fromEntries(\n    Object.entries(args).map(([key, value]) => {\n      return [`mcp.request.argument.${key}`, JSON.stringify(value)];\n    }),\n  );\n}\n\n/**\n * Creates a telemetry wrapper for regular URI resource handlers.\n * Captures URI access and user context for observability.\n */\nfunction createResourceHandler(\n  resource: { name: string; handler: ReadResourceCallback },\n  context: ServerContext,\n): ReadResourceCallback {\n  return async (uri: URL, extra: RequestHandlerExtra<any, any>) => {\n    return await startNewTrace(async () => {\n      return await startSpan(\n        {\n          name: `resources/read ${resource.name}`,\n          attributes: {\n            \"mcp.resource.name\": resource.name,\n            \"mcp.resource.uri\": uri.toString(),\n            ...(context.mcpClientName && {\n              \"mcp.client.name\": context.mcpClientName,\n            }),\n            ...(context.mcpClientVersion && {\n              \"mcp.client.version\": context.mcpClientVersion,\n            }),\n            ...(context.mcpProtocolVersion && {\n              \"mcp.protocol.version\": context.mcpProtocolVersion,\n            }),\n            \"mcp.server.name\": \"Sentry MCP\",\n            \"mcp.server.version\": LIB_VERSION,\n          },\n        },\n        async () => {\n          if (context.userId) {\n            setUser({\n              id: context.userId,\n            });\n          }\n          if (context.clientId) {\n            setTag(\"client.id\", context.clientId);\n          }\n\n          return resource.handler(uri, extra);\n        },\n      );\n    });\n  };\n}\n\n/**\n * Creates a telemetry wrapper for URI template resource handlers.\n * Captures template parameters and user context for observability.\n */\nfunction createTemplateResourceHandler(\n  resource: { name: string; handler: ReadResourceCallback },\n  context: ServerContext,\n): ReadResourceTemplateCallback {\n  return async (\n    uri: URL,\n    variables: Variables,\n    extra: RequestHandlerExtra<any, any>,\n  ) => {\n    return await startNewTrace(async () => {\n      return await startSpan(\n        {\n          name: `resources/read ${resource.name}`,\n          attributes: {\n            \"mcp.resource.name\": resource.name,\n            \"mcp.resource.uri\": uri.toString(),\n            ...(context.mcpClientName && {\n              \"mcp.client.name\": context.mcpClientName,\n            }),\n            ...(context.mcpClientVersion && {\n              \"mcp.client.version\": context.mcpClientVersion,\n            }),\n            ...(context.mcpProtocolVersion && {\n              \"mcp.protocol.version\": context.mcpProtocolVersion,\n            }),\n            \"mcp.server.name\": \"Sentry MCP\",\n            \"mcp.server.version\": LIB_VERSION,\n            ...extractMcpParameters(variables),\n          },\n        },\n        async () => {\n          if (context.userId) {\n            setUser({\n              id: context.userId,\n            });\n          }\n          if (context.clientId) {\n            setTag(\"client.id\", context.clientId);\n          }\n\n          // The MCP SDK has already constructed the URI from the template and variables\n          // We just need to call the handler with the constructed URI\n          return resource.handler(uri, extra);\n        },\n      );\n    });\n  };\n}\n\n/**\n * Configures an MCP server with all tools, prompts, resources, and telemetry.\n *\n * Transforms a bare MCP server instance into a fully-featured Sentry integration\n * with comprehensive observability, error handling, and handler registration.\n *\n * @example Basic Configuration\n * ```typescript\n * const server = new McpServer();\n * const context = {\n *   accessToken: process.env.SENTRY_TOKEN,\n *   host: \"sentry.io\",\n *   userId: \"user-123\",\n *   clientId: \"cursor-ide\"\n * };\n *\n * await configureServer({ server, context });\n * ```\n */\nexport async function configureServer({\n  server,\n  context,\n  onToolComplete,\n  onInitialized,\n}: {\n  server: McpServer;\n  context: ServerContext;\n  onToolComplete?: () => void;\n  onInitialized?: () => void | Promise<void>;\n}) {\n  server.server.onerror = (error) => {\n    logError(error);\n  };\n\n  // Hook into the initialized notification to capture client information\n  server.server.oninitialized = () => {\n    const serverInstance = server.server as any;\n    const clientInfo = serverInstance._clientVersion;\n    const protocolVersion = serverInstance._protocolVersion;\n\n    // Update the context object with client information\n    if (clientInfo) {\n      context.mcpClientName = clientInfo.name;\n      context.mcpClientVersion = clientInfo.version;\n    }\n\n    if (protocolVersion) {\n      context.mcpProtocolVersion = protocolVersion;\n    }\n\n    // Call the custom onInitialized handler if provided\n    // Note: MCP SDK doesn't support async callbacks, so we handle promises\n    // without awaiting to avoid blocking the initialization flow\n    if (onInitialized) {\n      const result = onInitialized();\n      if (result instanceof Promise) {\n        result.catch((error) => {\n          console.error(\"Error in onInitialized callback:\", error);\n          logError(error);\n        });\n      }\n    }\n  };\n\n  for (const resource of RESOURCES) {\n    if (isTemplateResource(resource)) {\n      // Handle URI template resources\n      server.registerResource(\n        resource.name,\n        resource.template,\n        {\n          description: resource.description,\n          mimeType: resource.mimeType,\n        },\n        createTemplateResourceHandler(resource, context),\n      );\n    } else {\n      // Handle regular URI resources\n      server.registerResource(\n        resource.name,\n        resource.uri,\n        {\n          description: resource.description,\n          mimeType: resource.mimeType,\n        },\n        createResourceHandler(resource, context),\n      );\n    }\n  }\n\n  for (const prompt of PROMPT_DEFINITIONS) {\n    const handler = PROMPT_HANDLERS[prompt.name];\n\n    server.prompt(\n      prompt.name,\n      prompt.description,\n      prompt.paramsSchema ? prompt.paramsSchema : {},\n      async (...args) => {\n        try {\n          return await startNewTrace(async () => {\n            return await startSpan(\n              {\n                name: `prompts/get ${prompt.name}`,\n                attributes: {\n                  \"mcp.prompt.name\": prompt.name,\n                  ...(context.mcpClientName && {\n                    \"mcp.client.name\": context.mcpClientName,\n                  }),\n                  ...(context.mcpClientVersion && {\n                    \"mcp.client.version\": context.mcpClientVersion,\n                  }),\n                  ...(context.mcpProtocolVersion && {\n                    \"mcp.protocol.version\": context.mcpProtocolVersion,\n                  }),\n                  \"mcp.server.name\": MCP_SERVER_NAME,\n                  \"mcp.server.version\": LIB_VERSION,\n                  ...extractMcpParameters(args[0] || {}),\n                },\n              },\n              async (span) => {\n                if (context.userId) {\n                  setUser({\n                    id: context.userId,\n                  });\n                }\n                if (context.clientId) {\n                  setTag(\"client.id\", context.clientId);\n                }\n                try {\n                  // TODO(dcramer): I'm too dumb to figure this out\n                  // @ts-ignore\n                  const output = await handler(context, ...args);\n                  span.setStatus({\n                    code: 1, // ok\n                  });\n                  return {\n                    messages: [\n                      {\n                        role: \"user\" as const,\n                        content: {\n                          type: \"text\" as const,\n                          text: output,\n                        },\n                      },\n                    ],\n                  };\n                } catch (error) {\n                  span.setStatus({\n                    code: 2, // error\n                  });\n                  throw error;\n                }\n              },\n            );\n          });\n        } finally {\n          onToolComplete?.();\n        }\n      },\n    );\n  }\n\n  for (const [toolKey, tool] of Object.entries(tools)) {\n    server.tool(\n      tool.name,\n      tool.description,\n      tool.inputSchema,\n      async (\n        params: any,\n        extra: RequestHandlerExtra<ServerRequest, ServerNotification>,\n      ) => {\n        try {\n          return await startNewTrace(async () => {\n            return await startSpan(\n              {\n                name: `tools/call ${tool.name}`,\n                attributes: {\n                  \"mcp.tool.name\": tool.name,\n                  ...(context.mcpClientName && {\n                    \"mcp.client.name\": context.mcpClientName,\n                  }),\n                  ...(context.mcpClientVersion && {\n                    \"mcp.client.version\": context.mcpClientVersion,\n                  }),\n                  ...(context.mcpProtocolVersion && {\n                    \"mcp.protocol.version\": context.mcpProtocolVersion,\n                  }),\n                  \"mcp.server.name\": MCP_SERVER_NAME,\n                  \"mcp.server.version\": LIB_VERSION,\n                  ...extractMcpParameters(params || {}),\n                },\n              },\n              async (span) => {\n                if (context.userId) {\n                  setUser({\n                    id: context.userId,\n                  });\n                }\n                if (context.clientId) {\n                  setTag(\"client.id\", context.clientId);\n                }\n\n                try {\n                  const output = await tool.handler(params, context);\n                  span.setStatus({\n                    code: 1, // ok\n                  });\n                  // if the tool returns a string, assume it's a message\n                  if (typeof output === \"string\") {\n                    return {\n                      content: [\n                        {\n                          type: \"text\" as const,\n                          text: output,\n                        },\n                      ],\n                    };\n                  }\n                  // if the tool returns a list, assume it's a content list\n                  if (Array.isArray(output)) {\n                    return {\n                      content: output,\n                    };\n                  }\n                  throw new Error(`Invalid tool output: ${output}`);\n                } catch (error) {\n                  span.setStatus({\n                    code: 2, // error\n                  });\n\n                  // CRITICAL: Tool errors MUST be returned as formatted text responses,\n                  // NOT thrown as exceptions. This ensures consistent error handling\n                  // and prevents the MCP client from receiving raw error objects.\n                  //\n                  // The logAndFormatError function provides user-friendly error messages\n                  // with appropriate formatting for different error types:\n                  // - UserInputError: Clear guidance for fixing input problems\n                  // - ConfigurationError: Clear guidance for fixing configuration issues\n                  // - ApiError: HTTP status context with helpful messaging\n                  // - System errors: Sentry event IDs for debugging\n                  //\n                  // DO NOT change this to throw error - it breaks error handling!\n                  return {\n                    content: [\n                      {\n                        type: \"text\" as const,\n                        text: await logAndFormatError(error),\n                      },\n                    ],\n                    isError: true,\n                  };\n                }\n              },\n            );\n          });\n        } finally {\n          onToolComplete?.();\n        }\n      },\n    );\n  }\n}\n"],"mappings":"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"}