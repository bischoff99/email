{"version":3,"file":"analyze-issue-with-seer-CpwtN4UA.js","names":["context: ServerContext"],"sources":["../src/tools/analyze-issue-with-seer.ts"],"sourcesContent":["import { z } from \"zod\";\nimport { setTag } from \"@sentry/core\";\nimport { defineTool } from \"./utils/defineTool\";\nimport { apiServiceFromContext } from \"./utils/api-utils\";\nimport { parseIssueParams } from \"./utils/issue-utils\";\nimport {\n  getStatusDisplayName,\n  isTerminalStatus,\n  isHumanInterventionStatus,\n  getHumanInterventionGuidance,\n  getOutputForAutofixStep,\n  SEER_POLLING_INTERVAL,\n  SEER_TIMEOUT,\n  SEER_MAX_RETRIES,\n  SEER_INITIAL_RETRY_DELAY,\n} from \"./utils/seer-utils\";\nimport { retryWithBackoff } from \"../internal/fetch-utils\";\nimport type { ServerContext } from \"../types\";\nimport { ApiError } from \"../api-client/index\";\nimport {\n  ParamOrganizationSlug,\n  ParamRegionUrl,\n  ParamIssueShortId,\n  ParamIssueUrl,\n} from \"../schema\";\n\nexport default defineTool({\n  name: \"analyze_issue_with_seer\",\n  description: [\n    \"Use Seer AI to analyze production errors and get detailed root cause analysis with specific code fixes.\",\n    \"\",\n    \"Use this tool when you need:\",\n    \"- Detailed AI-powered root cause analysis\",\n    \"- Specific code fixes and implementation guidance\",\n    \"- Step-by-step troubleshooting for complex issues\",\n    \"- Understanding why an error is happening in production\",\n    \"\",\n    \"What this tool provides:\",\n    \"- Root cause analysis with code-level explanations\",\n    \"- Specific file locations and line numbers where errors occur\",\n    \"- Concrete code fixes you can apply\",\n    \"- Step-by-step implementation guidance\",\n    \"\",\n    \"This tool automatically:\",\n    \"1. Checks if analysis already exists (instant results)\",\n    \"2. Starts new AI analysis if needed (~2-5 minutes)\",\n    \"3. Returns complete fix recommendations\",\n    \"\",\n    \"<examples>\",\n    '### User: \"What\\'s causing this error? https://my-org.sentry.io/issues/PROJECT-1Z43\"',\n    \"\",\n    \"```\",\n    \"analyze_issue_with_seer(issueUrl='https://my-org.sentry.io/issues/PROJECT-1Z43')\",\n    \"```\",\n    \"\",\n    '### User: \"Can you help me understand why this is failing in production?\"',\n    \"\",\n    \"```\",\n    \"analyze_issue_with_seer(organizationSlug='my-organization', issueId='ERROR-456')\",\n    \"```\",\n    \"</examples>\",\n    \"\",\n    \"<hints>\",\n    \"- Use this tool when you need deeper analysis beyond basic issue details\",\n    \"- If the user provides an issueUrl, extract it and use that parameter alone\",\n    \"- The analysis includes actual code snippets and fixes, not just error descriptions\",\n    \"- Results are cached - subsequent calls return instantly\",\n    \"</hints>\",\n  ].join(\"\\n\"),\n  inputSchema: {\n    organizationSlug: ParamOrganizationSlug.optional(),\n    regionUrl: ParamRegionUrl.optional(),\n    issueId: ParamIssueShortId.optional(),\n    issueUrl: ParamIssueUrl.optional(),\n    instruction: z\n      .string()\n      .describe(\"Optional custom instruction for the AI analysis\")\n      .optional(),\n  },\n  async handler(params, context: ServerContext) {\n    const apiService = apiServiceFromContext(context, {\n      regionUrl: params.regionUrl,\n    });\n    const { organizationSlug: orgSlug, issueId: parsedIssueId } =\n      parseIssueParams({\n        organizationSlug: params.organizationSlug,\n        issueId: params.issueId,\n        issueUrl: params.issueUrl,\n      });\n\n    setTag(\"organization.slug\", orgSlug);\n\n    let output = `# Seer AI Analysis for Issue ${parsedIssueId}\\n\\n`;\n\n    // Step 1: Check if analysis already exists\n    let autofixState = await retryWithBackoff(\n      () =>\n        apiService.getAutofixState({\n          organizationSlug: orgSlug,\n          issueId: parsedIssueId!,\n        }),\n      {\n        maxRetries: SEER_MAX_RETRIES,\n        initialDelay: SEER_INITIAL_RETRY_DELAY,\n        shouldRetry: (error) => {\n          // Retry on network errors or 5xx errors\n          if (error instanceof ApiError) {\n            return error.status >= 500;\n          }\n          // Retry on network/connection errors\n          return true;\n        },\n      },\n    );\n\n    // Step 2: Start analysis if none exists\n    if (!autofixState.autofix) {\n      output += `Starting new analysis...\\n\\n`;\n      const startResult = await apiService.startAutofix({\n        organizationSlug: orgSlug,\n        issueId: parsedIssueId,\n        instruction: params.instruction,\n      });\n      output += `Analysis started with Run ID: ${startResult.run_id}\\n\\n`;\n\n      // Give it a moment to initialize\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      // Refresh state with retry logic\n      autofixState = await retryWithBackoff(\n        () =>\n          apiService.getAutofixState({\n            organizationSlug: orgSlug,\n            issueId: parsedIssueId!,\n          }),\n        {\n          maxRetries: SEER_MAX_RETRIES,\n          initialDelay: SEER_INITIAL_RETRY_DELAY,\n          shouldRetry: (error) => {\n            if (error instanceof ApiError) {\n              return error.status >= 500;\n            }\n            return true;\n          },\n        },\n      );\n    } else {\n      output += `Found existing analysis (Run ID: ${autofixState.autofix.run_id})\\n\\n`;\n\n      // Check if existing analysis is already complete\n      const existingStatus = autofixState.autofix.status;\n      if (isTerminalStatus(existingStatus)) {\n        // Return results immediately, no polling needed\n        output += `## Analysis ${getStatusDisplayName(existingStatus)}\\n\\n`;\n\n        for (const step of autofixState.autofix.steps) {\n          output += getOutputForAutofixStep(step);\n          output += \"\\n\";\n        }\n\n        if (existingStatus !== \"COMPLETED\") {\n          output += `\\n**Status**: ${existingStatus}\\n`;\n          output += getHumanInterventionGuidance(existingStatus);\n          output += \"\\n\";\n        }\n\n        return output;\n      }\n    }\n\n    // Step 3: Poll until complete or timeout (only for non-terminal states)\n    const startTime = Date.now();\n    let lastStatus = \"\";\n    let consecutiveErrors = 0;\n\n    while (Date.now() - startTime < SEER_TIMEOUT) {\n      if (!autofixState.autofix) {\n        output += `Error: Analysis state lost. Please try again by running:\\n`;\n        output += `\\`\\`\\`\\n`;\n        output += params.issueUrl\n          ? `analyze_issue_with_seer(issueUrl=\"${params.issueUrl}\")`\n          : `analyze_issue_with_seer(organizationSlug=\"${orgSlug}\", issueId=\"${parsedIssueId}\")`;\n        output += `\\n\\`\\`\\`\\n`;\n        return output;\n      }\n\n      const status = autofixState.autofix.status;\n\n      // Check if completed (terminal state)\n      if (isTerminalStatus(status)) {\n        output += `## Analysis ${getStatusDisplayName(status)}\\n\\n`;\n\n        // Add all step outputs\n        for (const step of autofixState.autofix.steps) {\n          output += getOutputForAutofixStep(step);\n          output += \"\\n\";\n        }\n\n        if (status !== \"COMPLETED\") {\n          output += `\\n**Status**: ${status}\\n`;\n          output += getHumanInterventionGuidance(status);\n        }\n\n        return output;\n      }\n\n      // Update status if changed\n      if (status !== lastStatus) {\n        const activeStep = autofixState.autofix.steps.find(\n          (step) =>\n            step.status === \"PROCESSING\" || step.status === \"IN_PROGRESS\",\n        );\n        if (activeStep) {\n          output += `Processing: ${activeStep.title}...\\n`;\n        }\n        lastStatus = status;\n      }\n\n      // Wait before next poll\n      await new Promise((resolve) =>\n        setTimeout(resolve, SEER_POLLING_INTERVAL),\n      );\n\n      // Refresh state with error handling\n      try {\n        autofixState = await retryWithBackoff(\n          () =>\n            apiService.getAutofixState({\n              organizationSlug: orgSlug,\n              issueId: parsedIssueId!,\n            }),\n          {\n            maxRetries: SEER_MAX_RETRIES,\n            initialDelay: SEER_INITIAL_RETRY_DELAY,\n            shouldRetry: (error) => {\n              if (error instanceof ApiError) {\n                return error.status >= 500;\n              }\n              return true;\n            },\n          },\n        );\n        consecutiveErrors = 0; // Reset error counter on success\n      } catch (error) {\n        consecutiveErrors++;\n\n        // If we've had too many consecutive errors, give up\n        if (consecutiveErrors >= 3) {\n          output += `\\n## Error During Analysis\\n\\n`;\n          output += `Unable to retrieve analysis status after multiple attempts.\\n`;\n          output += `Error: ${error instanceof Error ? error.message : String(error)}\\n\\n`;\n          output += `You can check the status later by running the same command again:\\n`;\n          output += `\\`\\`\\`\\n`;\n          output += params.issueUrl\n            ? `analyze_issue_with_seer(issueUrl=\"${params.issueUrl}\")`\n            : `analyze_issue_with_seer(organizationSlug=\"${orgSlug}\", issueId=\"${parsedIssueId}\")`;\n          output += `\\n\\`\\`\\`\\n`;\n          return output;\n        }\n\n        // Log the error but continue polling\n        output += `Temporary error retrieving status (attempt ${consecutiveErrors}/3), retrying...\\n`;\n      }\n    }\n\n    // Show current progress\n    if (autofixState.autofix) {\n      output += `**Current Status**: ${getStatusDisplayName(autofixState.autofix.status)}\\n\\n`;\n      for (const step of autofixState.autofix.steps) {\n        output += getOutputForAutofixStep(step);\n        output += \"\\n\";\n      }\n    }\n\n    // Timeout reached\n    output += `\\n## Analysis Timed Out\\n\\n`;\n    output += `The analysis is taking longer than expected (>${SEER_TIMEOUT / 1000}s).\\n\\n`;\n\n    output += `\\nYou can check the status later by running the same command again:\\n`;\n    output += `\\`\\`\\`\\n`;\n    output += params.issueUrl\n      ? `analyze_issue_with_seer(issueUrl=\"${params.issueUrl}\")`\n      : `analyze_issue_with_seer(organizationSlug=\"${orgSlug}\", issueId=\"${parsedIssueId}\")`;\n    output += `\\n\\`\\`\\`\\n`;\n\n    return output;\n  },\n});\n"],"mappings":"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"}