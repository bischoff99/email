import "../../schema-xbTf44Hn.cjs";
import "../../types-DE-njuHe.cjs";
import { SentryApiService } from "../../client-DV68BdcS.cjs";
import "../../index-BPSCxsMC.cjs";
import "../../promptDefinitions-CVHtYaj8.cjs";
import { ServerContext } from "../../types-BV-G5sBp.cjs";

//#region src/tools/utils/api-utils.d.ts

/**
 * Create a Sentry API service from server context with optional region override
 * @param context - Server context containing host and access token
 * @param opts - Options object containing optional regionUrl override
 * @returns Configured SentryApiService instance (always uses HTTPS)
 * @throws {UserInputError} When regionUrl is provided but invalid
 */
declare function apiServiceFromContext(context: ServerContext, opts?: {
  regionUrl?: string;
}): SentryApiService;
/**
 * Maps API errors to user-friendly errors based on context
 * @param error - The error to handle
 * @param params - The parameters that were used in the API call
 * @returns Never - always throws an error
 * @throws {UserInputError} For 4xx errors that are likely user input issues
 * @throws {Error} For other errors
 */
declare function handleApiError(error: unknown, params?: Record<string, unknown>): never;
/**
 * Wraps an async API call with automatic error handling
 * @param fn - The async function to execute
 * @param params - The parameters that were used in the API call
 * @returns The result of the function
 * @throws {UserInputError} For user input errors
 * @throws {Error} For other errors
 */
declare function withApiErrorHandling<T>(fn: () => Promise<T>, params?: Record<string, unknown>): Promise<T>;
//# sourceMappingURL=api-utils.d.ts.map
//#endregion
export { apiServiceFromContext, handleApiError, withApiErrorHandling };
//# sourceMappingURL=api-utils.d.cts.map