import "../../schema-DWmx8lgm.js";
import "../../types-DRywojVB.js";
import { SentryApiService } from "../../client-DLkUGS7r.js";
import "../../index-DE1muTvw.js";
import "../../promptDefinitions-DehpwJfn.js";
import { ServerContext } from "../../types-C1Fih0eQ.js";

//#region src/tools/utils/api-utils.d.ts

/**
 * Create a Sentry API service from server context with optional region override
 * @param context - Server context containing host and access token
 * @param opts - Options object containing optional regionUrl override
 * @returns Configured SentryApiService instance (always uses HTTPS)
 * @throws {UserInputError} When regionUrl is provided but invalid
 */
declare function apiServiceFromContext(context: ServerContext, opts?: {
  regionUrl?: string;
}): SentryApiService;
/**
 * Maps API errors to user-friendly errors based on context
 * @param error - The error to handle
 * @param params - The parameters that were used in the API call
 * @returns Never - always throws an error
 * @throws {UserInputError} For 4xx errors that are likely user input issues
 * @throws {Error} For other errors
 */
declare function handleApiError(error: unknown, params?: Record<string, unknown>): never;
/**
 * Wraps an async API call with automatic error handling
 * @param fn - The async function to execute
 * @param params - The parameters that were used in the API call
 * @returns The result of the function
 * @throws {UserInputError} For user input errors
 * @throws {Error} For other errors
 */
declare function withApiErrorHandling<T>(fn: () => Promise<T>, params?: Record<string, unknown>): Promise<T>;
//# sourceMappingURL=api-utils.d.ts.map
//#endregion
export { apiServiceFromContext, handleApiError, withApiErrorHandling };
//# sourceMappingURL=api-utils.d.ts.map