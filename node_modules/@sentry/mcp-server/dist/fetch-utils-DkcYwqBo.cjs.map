{"version":3,"file":"fetch-utils-DkcYwqBo.cjs","names":["url: string | URL","options: RequestInit","fn: () => Promise<T>","error: unknown","lastError: unknown"],"sources":["../src/internal/fetch-utils.ts"],"sourcesContent":["/**\n * Fetch with timeout using AbortController\n * @param url - The URL to fetch\n * @param options - Standard fetch options\n * @param timeoutMs - Timeout in milliseconds (default: 30000)\n * @returns Promise<Response>\n * @throws Error if request times out\n */\nexport async function fetchWithTimeout(\n  url: string | URL,\n  options: RequestInit = {},\n  timeoutMs = 30000,\n): Promise<Response> {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n    });\n    return response;\n  } catch (error) {\n    if (error instanceof Error && error.name === \"AbortError\") {\n      throw new Error(`Request timeout after ${timeoutMs}ms`);\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n/**\n * Retry a function with exponential backoff\n * @param fn - The async function to retry\n * @param options - Retry options\n * @param options.maxRetries - Maximum number of retries (default: 3)\n * @param options.initialDelay - Initial delay in milliseconds (default: 1000)\n * @param options.shouldRetry - Predicate to determine if error should be retried (default: always retry)\n * @returns Promise with the function result\n * @throws The last error if all retries are exhausted\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  {\n    maxRetries = 3,\n    initialDelay = 1000,\n    shouldRetry = (error: unknown) => true,\n  }: {\n    maxRetries?: number;\n    initialDelay?: number;\n    shouldRetry?: (error: unknown) => boolean;\n  } = {},\n): Promise<T> {\n  let lastError: unknown;\n  let delay = initialDelay;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      // Don't retry if we've exhausted attempts or if the error is non-retryable\n      if (attempt === maxRetries || !shouldRetry(error)) {\n        throw error;\n      }\n\n      // Wait before retrying with exponential backoff\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      delay = Math.min(delay * 2, 30000); // Cap at 30 seconds\n    }\n  }\n\n  throw lastError;\n}\n"],"mappings":";;;;;;;;;;AAQA,eAAsB,iBACpBA,KACAC,UAAuB,CAAE,GACzB,YAAY,KACO;CACnB,MAAM,aAAa,IAAI;CACvB,MAAM,YAAY,WAAW,MAAM,WAAW,OAAO,EAAE,UAAU;AAEjE,KAAI;EACF,MAAM,WAAW,MAAM,MAAM,KAAK;GAChC,GAAG;GACH,QAAQ,WAAW;EACpB,EAAC;AACF,SAAO;CACR,SAAQ,OAAO;AACd,MAAI,iBAAiB,SAAS,MAAM,SAAS,aAC3C,OAAM,IAAI,OAAO,wBAAwB,UAAU;AAErD,QAAM;CACP,UAAS;AACR,eAAa,UAAU;CACxB;AACF;;;;;;;;;;;AAYD,eAAsB,iBACpBC,IACA,EACE,aAAa,GACb,eAAe,KACf,cAAc,CAACC,UAAmB,MAKnC,GAAG,CAAE,GACM;CACZ,IAAIC;CACJ,IAAI,QAAQ;AAEZ,MAAK,IAAI,UAAU,GAAG,WAAW,YAAY,UAC3C,KAAI;AACF,SAAO,MAAM,IAAI;CAClB,SAAQ,OAAO;AACd,cAAY;AAGZ,MAAI,YAAY,eAAe,YAAY,MAAM,CAC/C,OAAM;AAIR,QAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,MAAM;AACzD,UAAQ,KAAK,IAAI,QAAQ,GAAG,IAAM;CACnC;AAGH,OAAM;AACP"}