/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
/*! For license information please see server.js.LICENSE.txt */
import * as __WEBPACK_EXTERNAL_MODULE_fs__ from "fs";
import * as __WEBPACK_EXTERNAL_MODULE_fs_promises_400951f8__ from "fs/promises";
import * as __WEBPACK_EXTERNAL_MODULE_path__ from "path";
import * as __WEBPACK_EXTERNAL_MODULE_punycode__ from "punycode";
import * as __WEBPACK_EXTERNAL_MODULE_util__ from "util";
import * as __WEBPACK_EXTERNAL_MODULE_node_crypto_9ba42079__ from "node:crypto";
import * as __WEBPACK_EXTERNAL_MODULE_stream__ from "stream";
import * as __WEBPACK_EXTERNAL_MODULE_http__ from "http";
import * as __WEBPACK_EXTERNAL_MODULE_url__ from "url";
import * as __WEBPACK_EXTERNAL_MODULE_https__ from "https";
import * as __WEBPACK_EXTERNAL_MODULE_zlib__ from "zlib";
import * as __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_mcp_js_2c42c5d0__ from "@modelcontextprotocol/sdk/server/mcp.js";
import * as __WEBPACK_EXTERNAL_MODULE__agent_infra_logger_ddae3da2__ from "@agent-infra/logger";
import * as __WEBPACK_EXTERNAL_MODULE_crypto__ from "crypto";
import * as __WEBPACK_EXTERNAL_MODULE_puppeteer_core_17481843__ from "puppeteer-core";
import * as __WEBPACK_EXTERNAL_MODULE_node_fs_5ea92f0c__ from "node:fs";
import * as __WEBPACK_EXTERNAL_MODULE_node_os_74b4b876__ from "node:os";
import * as __WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__ from "node:path";
var __webpack_modules__ = {
    "../../../../node_modules/@langchain/core/node_modules/ansi-styles/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        module = __webpack_require__.nmd(module);
        const ANSI_BACKGROUND_OFFSET = 10;
        const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
        const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
        function assembleStyles() {
            const codes = new Map();
            const styles = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    overline: [
                        53,
                        55
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    blackBright: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            styles.color.gray = styles.color.blackBright;
            styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
            styles.color.grey = styles.color.blackBright;
            styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
            for (const [groupName, group] of Object.entries(styles)){
                for (const [styleName, style] of Object.entries(group)){
                    styles[styleName] = {
                        open: `\u001B[${style[0]}m`,
                        close: `\u001B[${style[1]}m`
                    };
                    group[styleName] = styles[styleName];
                    codes.set(style[0], style[1]);
                }
                Object.defineProperty(styles, groupName, {
                    value: group,
                    enumerable: false
                });
            }
            Object.defineProperty(styles, 'codes', {
                value: codes,
                enumerable: false
            });
            styles.color.close = '\u001B[39m';
            styles.bgColor.close = '\u001B[49m';
            styles.color.ansi256 = wrapAnsi256();
            styles.color.ansi16m = wrapAnsi16m();
            styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
            styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
            Object.defineProperties(styles, {
                rgbToAnsi256: {
                    value: (red, green, blue)=>{
                        if (red === green && green === blue) {
                            if (red < 8) return 16;
                            if (red > 248) return 231;
                            return Math.round((red - 8) / 247 * 24) + 232;
                        }
                        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
                    },
                    enumerable: false
                },
                hexToRgb: {
                    value: (hex)=>{
                        const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
                        if (!matches) return [
                            0,
                            0,
                            0
                        ];
                        let { colorString } = matches.groups;
                        if (3 === colorString.length) colorString = colorString.split('').map((character)=>character + character).join('');
                        const integer = Number.parseInt(colorString, 16);
                        return [
                            integer >> 16 & 0xFF,
                            integer >> 8 & 0xFF,
                            0xFF & integer
                        ];
                    },
                    enumerable: false
                },
                hexToAnsi256: {
                    value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
                    enumerable: false
                }
            });
            return styles;
        }
        Object.defineProperty(module, 'exports', {
            enumerable: true,
            get: assembleStyles
        });
    },
    "../../../../node_modules/camelcase/index.js": function(module) {
        const UPPERCASE = /[\p{Lu}]/u;
        const LOWERCASE = /[\p{Ll}]/u;
        const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
        const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
        const SEPARATORS = /[_.\- ]+/;
        const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
        const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
        const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');
        const preserveCamelCase = (string, toLowerCase, toUpperCase)=>{
            let isLastCharLower = false;
            let isLastCharUpper = false;
            let isLastLastCharUpper = false;
            for(let i = 0; i < string.length; i++){
                const character = string[i];
                if (isLastCharLower && UPPERCASE.test(character)) {
                    string = string.slice(0, i) + '-' + string.slice(i);
                    isLastCharLower = false;
                    isLastLastCharUpper = isLastCharUpper;
                    isLastCharUpper = true;
                    i++;
                } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
                    string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
                    isLastLastCharUpper = isLastCharUpper;
                    isLastCharUpper = false;
                    isLastCharLower = true;
                } else {
                    isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
                    isLastLastCharUpper = isLastCharUpper;
                    isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
                }
            }
            return string;
        };
        const preserveConsecutiveUppercase = (input, toLowerCase)=>{
            LEADING_CAPITAL.lastIndex = 0;
            return input.replace(LEADING_CAPITAL, (m1)=>toLowerCase(m1));
        };
        const postProcess = (input, toUpperCase)=>{
            SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
            NUMBERS_AND_IDENTIFIER.lastIndex = 0;
            return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier)=>toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m)=>toUpperCase(m));
        };
        const camelCase = (input, options)=>{
            if (!('string' == typeof input || Array.isArray(input))) throw new TypeError('Expected the input to be `string | string[]`');
            options = {
                pascalCase: false,
                preserveConsecutiveUppercase: false,
                ...options
            };
            input = Array.isArray(input) ? input.map((x)=>x.trim()).filter((x)=>x.length).join('-') : input.trim();
            if (0 === input.length) return '';
            const toLowerCase = false === options.locale ? (string)=>string.toLowerCase() : (string)=>string.toLocaleLowerCase(options.locale);
            const toUpperCase = false === options.locale ? (string)=>string.toUpperCase() : (string)=>string.toLocaleUpperCase(options.locale);
            if (1 === input.length) return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
            const hasUpperCase = input !== toLowerCase(input);
            if (hasUpperCase) input = preserveCamelCase(input, toLowerCase, toUpperCase);
            input = input.replace(LEADING_SEPARATORS, '');
            input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
            if (options.pascalCase) input = toUpperCase(input.charAt(0)) + input.slice(1);
            return postProcess(input, toUpperCase);
        };
        module.exports = camelCase;
        module.exports["default"] = camelCase;
    },
    "../../../../node_modules/cross-fetch/dist/node-ponyfill.js": function(module, exports, __webpack_require__) {
        const nodeFetch = __webpack_require__("../../../../node_modules/node-fetch/lib/index.mjs");
        const realFetch = nodeFetch.default || nodeFetch;
        const fetch1 = function(url, options) {
            if (/^\/\//.test(url)) url = 'https:' + url;
            return realFetch.call(this, url, options);
        };
        fetch1.ponyfill = true;
        module.exports = exports = fetch1;
        exports.fetch = fetch1;
        exports.Headers = nodeFetch.Headers;
        exports.Request = nodeFetch.Request;
        exports.Response = nodeFetch.Response;
        exports["default"] = fetch1;
    },
    "../../../../node_modules/decamelize/index.js": function(module) {
        module.exports = function(str, sep) {
            if ('string' != typeof str) throw new TypeError('Expected a string');
            sep = void 0 === sep ? '_' : sep;
            return str.replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2').replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2').toLowerCase();
        };
    },
    "../../../../node_modules/isexe/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        __webpack_require__("fs");
        var core;
        core = 'win32' === process.platform || global.TESTING_WINDOWS ? __webpack_require__("../../../../node_modules/isexe/windows.js") : __webpack_require__("../../../../node_modules/isexe/mode.js");
        module.exports = isexe;
        isexe.sync = sync;
        function isexe(path, options, cb) {
            if ('function' == typeof options) {
                cb = options;
                options = {};
            }
            if (!cb) {
                if ('function' != typeof Promise) throw new TypeError('callback not provided');
                return new Promise(function(resolve, reject) {
                    isexe(path, options || {}, function(er, is) {
                        if (er) reject(er);
                        else resolve(is);
                    });
                });
            }
            core(path, options || {}, function(er, is) {
                if (er) {
                    if ('EACCES' === er.code || options && options.ignoreErrors) {
                        er = null;
                        is = false;
                    }
                }
                cb(er, is);
            });
        }
        function sync(path, options) {
            try {
                return core.sync(path, options || {});
            } catch (er) {
                if (options && options.ignoreErrors || 'EACCES' === er.code) return false;
                throw er;
            }
        }
    },
    "../../../../node_modules/isexe/mode.js": function(module, __unused_webpack_exports, __webpack_require__) {
        module.exports = isexe;
        isexe.sync = sync;
        var fs = __webpack_require__("fs");
        function isexe(path, options, cb) {
            fs.stat(path, function(er, stat) {
                cb(er, er ? false : checkStat(stat, options));
            });
        }
        function sync(path, options) {
            return checkStat(fs.statSync(path), options);
        }
        function checkStat(stat, options) {
            return stat.isFile() && checkMode(stat, options);
        }
        function checkMode(stat, options) {
            var mod = stat.mode;
            var uid = stat.uid;
            var gid = stat.gid;
            var myUid = void 0 !== options.uid ? options.uid : process.getuid && process.getuid();
            var myGid = void 0 !== options.gid ? options.gid : process.getgid && process.getgid();
            var u = parseInt('100', 8);
            var g = parseInt('010', 8);
            var o = parseInt('001', 8);
            var ug = u | g;
            var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && 0 === myUid;
            return ret;
        }
    },
    "../../../../node_modules/isexe/windows.js": function(module, __unused_webpack_exports, __webpack_require__) {
        module.exports = isexe;
        isexe.sync = sync;
        var fs = __webpack_require__("fs");
        function checkPathExt(path, options) {
            var pathext = void 0 !== options.pathExt ? options.pathExt : process.env.PATHEXT;
            if (!pathext) return true;
            pathext = pathext.split(';');
            if (-1 !== pathext.indexOf('')) return true;
            for(var i = 0; i < pathext.length; i++){
                var p = pathext[i].toLowerCase();
                if (p && path.substr(-p.length).toLowerCase() === p) return true;
            }
            return false;
        }
        function checkStat(stat, path, options) {
            if (!stat.isSymbolicLink() && !stat.isFile()) return false;
            return checkPathExt(path, options);
        }
        function isexe(path, options, cb) {
            fs.stat(path, function(er, stat) {
                cb(er, er ? false : checkStat(stat, path, options));
            });
        }
        function sync(path, options) {
            return checkStat(fs.statSync(path), path, options);
        }
    },
    "../../../../node_modules/lodash.merge/index.js": function(module, exports, __webpack_require__) {
        module = __webpack_require__.nmd(module);
        var LARGE_ARRAY_SIZE = 200;
        var HASH_UNDEFINED = '__lodash_hash_undefined__';
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]';
        var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var freeGlobal = 'object' == typeof global && global && global.Object === Object && global;
        var freeSelf = 'object' == typeof self && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function('return this')();
        var freeExports = exports && !exports.nodeType && exports;
        var freeModule = freeExports && true && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
            try {
                var types = freeModule && freeModule.require && freeModule.require('util').types;
                if (types) return types;
                return freeProcess && freeProcess.binding && freeProcess.binding('util');
            } catch (e) {}
        }();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
            switch(args.length){
                case 0:
                    return func.call(thisArg);
                case 1:
                    return func.call(thisArg, args[0]);
                case 2:
                    return func.call(thisArg, args[0], args[1]);
                case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
        }
        function baseTimes(n, iteratee) {
            var index = -1, result = Array(n);
            while(++index < n)result[index] = iteratee(index);
            return result;
        }
        function baseUnary(func) {
            return function(value) {
                return func(value);
            };
        }
        function getValue(object, key) {
            return null == object ? void 0 : object[key];
        }
        function overArg(func, transform) {
            return function(arg) {
                return func(transform(arg));
            };
        }
        var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
        var coreJsData = root['__core-js_shared__'];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object);
        var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var Buffer1 = moduleExports ? root.Buffer : void 0, Symbol1 = root.Symbol, Uint8Array1 = root.Uint8Array, allocUnsafe = Buffer1 ? Buffer1.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol1 ? Symbol1.toStringTag : void 0;
        var defineProperty = function() {
            try {
                var func = getNative(Object, 'defineProperty');
                func({}, '', {});
                return func;
            } catch (e) {}
        }();
        var nativeIsBuffer = Buffer1 ? Buffer1.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
        var Map1 = getNative(root, 'Map'), nativeCreate = getNative(Object, 'create');
        var baseCreate = function() {
            function object() {}
            return function(proto) {
                if (!isObject(proto)) return {};
                if (objectCreate) return objectCreate(proto);
                object.prototype = proto;
                var result = new object;
                object.prototype = void 0;
                return result;
            };
        }();
        function Hash(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
        }
        function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
        }
        function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? void 0 : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : void 0;
        }
        function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && void 0 === value ? HASH_UNDEFINED : value;
            return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
        }
        function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) return false;
            var lastIndex = data.length - 1;
            if (index == lastIndex) data.pop();
            else splice.call(data, index, 1);
            --this.size;
            return true;
        }
        function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? void 0 : data[index][1];
        }
        function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
                ++this.size;
                data.push([
                    key,
                    value
                ]);
            } else data[index][1] = value;
            return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
                hash: new Hash,
                map: new (Map1 || ListCache),
                string: new Hash
            };
        }
        function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
        }
        function mapCacheGet(key) {
            return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
            return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
        }
        function stackClear() {
            this.__data__ = new ListCache;
            this.size = 0;
        }
        function stackDelete(key) {
            var data = this.__data__, result = data['delete'](key);
            this.size = data.size;
            return result;
        }
        function stackGet(key) {
            return this.__data__.get(key);
        }
        function stackHas(key) {
            return this.__data__.has(key);
        }
        function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
                var pairs = data.__data__;
                if (!Map1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([
                        key,
                        value
                    ]);
                    this.size = ++data.size;
                    return this;
                }
                data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ('length' == key || isBuff && ('offset' == key || 'parent' == key) || isType && ('buffer' == key || 'byteLength' == key || 'byteOffset' == key) || isIndex(key, length)))) result.push(key);
            return result;
        }
        function assignMergeValue(object, key, value) {
            if (void 0 !== value && !eq(object[key], value) || void 0 === value && !(key in object)) baseAssignValue(object, key, value);
        }
        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || void 0 === value && !(key in object)) baseAssignValue(object, key, value);
        }
        function assocIndexOf(array, key) {
            var length = array.length;
            while(length--)if (eq(array[length][0], key)) return length;
            return -1;
        }
        function baseAssignValue(object, key, value) {
            if ('__proto__' == key && defineProperty) defineProperty(object, key, {
                configurable: true,
                enumerable: true,
                value: value,
                writable: true
            });
            else object[key] = value;
        }
        var baseFor = createBaseFor();
        function baseGetTag(value) {
            if (null == value) return void 0 === value ? undefinedTag : nullTag;
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) return false;
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseKeysIn(object) {
            if (!isObject(object)) return nativeKeysIn(object);
            var isProto = isPrototype(object), result = [];
            for(var key in object)if (!('constructor' == key && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
            return result;
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) return;
            baseFor(source, function(srcValue, key) {
                stack || (stack = new Stack);
                if (isObject(srcValue)) baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                else {
                    var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : void 0;
                    if (void 0 === newValue) newValue = srcValue;
                    assignMergeValue(object, key, newValue);
                }
            }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
                assignMergeValue(object, key, stacked);
                return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : void 0;
            var isCommon = void 0 === newValue;
            if (isCommon) {
                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                newValue = srcValue;
                if (isArr || isBuff || isTyped) {
                    if (isArray(objValue)) newValue = objValue;
                    else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue);
                    else if (isBuff) {
                        isCommon = false;
                        newValue = cloneBuffer(srcValue, true);
                    } else if (isTyped) {
                        isCommon = false;
                        newValue = cloneTypedArray(srcValue, true);
                    } else newValue = [];
                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    newValue = objValue;
                    if (isArguments(objValue)) newValue = toPlainObject(objValue);
                    else if (!isObject(objValue) || isFunction(objValue)) newValue = initCloneObject(srcValue);
                } else isCommon = false;
            }
            if (isCommon) {
                stack.set(srcValue, newValue);
                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                stack['delete'](srcValue);
            }
            assignMergeValue(object, key, newValue);
        }
        function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
        }
        var baseSetToString = defineProperty ? function(func, string) {
            return defineProperty(func, 'toString', {
                configurable: true,
                enumerable: false,
                value: constant(string),
                writable: true
            });
        } : identity;
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
        }
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array1(result).set(new Uint8Array1(arrayBuffer));
            return result;
        }
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while(++index < length)array[index] = source[index];
            return array;
        }
        function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while(++index < length){
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                if (void 0 === newValue) newValue = source[key];
                if (isNew) baseAssignValue(object, key, newValue);
                else assignValue(object, key, newValue);
            }
            return object;
        }
        function createAssigner(assigner) {
            return baseRest(function(object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
                customizer = assigner.length > 3 && 'function' == typeof customizer ? (length--, customizer) : void 0;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? void 0 : customizer;
                    length = 1;
                }
                object = Object(object);
                while(++index < length){
                    var source = sources[index];
                    if (source) assigner(object, source, index, customizer);
                }
                return object;
            });
        }
        function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                while(length--){
                    var key = props[fromRight ? length : ++index];
                    if (false === iteratee(iterable[key], key, iterable)) break;
                }
                return object;
            };
        }
        function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data['string' == typeof key ? 'string' : 'hash'] : data.map;
        }
        function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : void 0;
        }
        function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = void 0;
                var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) {
                if (isOwn) value[symToStringTag] = tag;
                else delete value[symToStringTag];
            }
            return result;
        }
        function initCloneObject(object) {
            return 'function' != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
        }
        function isIndex(value, length) {
            var type = typeof value;
            length = null == length ? MAX_SAFE_INTEGER : length;
            return !!length && ('number' == type || 'symbol' != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) return false;
            var type = typeof index;
            if ('number' == type ? isArrayLike(object) && isIndex(index, object.length) : 'string' == type && index in object) return eq(object[index], value);
            return false;
        }
        function isKeyable(value) {
            var type = typeof value;
            return 'string' == type || 'number' == type || 'symbol' == type || 'boolean' == type ? '__proto__' !== value : null === value;
        }
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
            var Ctor = value && value.constructor, proto = 'function' == typeof Ctor && Ctor.prototype || objectProto;
            return value === proto;
        }
        function nativeKeysIn(object) {
            var result = [];
            if (null != object) for(var key in Object(object))result.push(key);
            return result;
        }
        function objectToString(value) {
            return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform) {
            start = nativeMax(void 0 === start ? func.length - 1 : start, 0);
            return function() {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                while(++index < length)array[index] = args[start + index];
                index = -1;
                var otherArgs = Array(start + 1);
                while(++index < start)otherArgs[index] = args[index];
                otherArgs[start] = transform(array);
                return apply(func, this, otherArgs);
            };
        }
        function safeGet(object, key) {
            if ('constructor' === key && 'function' == typeof object[key]) return;
            if ('__proto__' == key) return;
            return object[key];
        }
        var setToString = shortOut(baseSetToString);
        function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) return arguments[0];
                } else count = 0;
                return func.apply(void 0, arguments);
            };
        }
        function toSource(func) {
            if (null != func) {
                try {
                    return funcToString.call(func);
                } catch (e) {}
                try {
                    return func + '';
                } catch (e) {}
            }
            return '';
        }
        function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        var isArguments = baseIsArguments(function() {
            return arguments;
        }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        };
        var isArray = Array.isArray;
        function isArrayLike(value) {
            return null != value && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        function isFunction(value) {
            if (!isObject(value)) return false;
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isLength(value) {
            return 'number' == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
            var type = typeof value;
            return null != value && ('object' == type || 'function' == type);
        }
        function isObjectLike(value) {
            return null != value && 'object' == typeof value;
        }
        function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) return false;
            var proto = getPrototype(value);
            if (null === proto) return true;
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return 'function' == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function toPlainObject(value) {
            return copyObject(value, keysIn(value));
        }
        function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
        });
        function constant(value) {
            return function() {
                return value;
            };
        }
        function identity(value) {
            return value;
        }
        function stubFalse() {
            return false;
        }
        module.exports = merge;
    },
    "../../../../node_modules/mime-types/index.js": function(__unused_webpack_module, exports, __webpack_require__) {
        /*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var db = __webpack_require__("../../../../node_modules/mime-types/node_modules/mime-db/index.js");
        var extname = __webpack_require__("path").extname;
        var mimeScore = __webpack_require__("../../../../node_modules/mime-types/mimeScore.js");
        var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
        var TEXT_TYPE_REGEXP = /^text\//i;
        exports.charset = charset;
        exports.charsets = {
            lookup: charset
        };
        exports.contentType = contentType;
        exports.extension = extension;
        exports.extensions = Object.create(null);
        exports.lookup = lookup;
        exports.types = Object.create(null);
        exports._extensionConflicts = [];
        populateMaps(exports.extensions, exports.types);
        function charset(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var mime = match && db[match[1].toLowerCase()];
            if (mime && mime.charset) return mime.charset;
            if (match && TEXT_TYPE_REGEXP.test(match[1])) return 'UTF-8';
            return false;
        }
        function contentType(str) {
            if (!str || 'string' != typeof str) return false;
            var mime = -1 === str.indexOf('/') ? exports.lookup(str) : str;
            if (!mime) return false;
            if (-1 === mime.indexOf('charset')) {
                var charset = exports.charset(mime);
                if (charset) mime += '; charset=' + charset.toLowerCase();
            }
            return mime;
        }
        function extension(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var exts = match && exports.extensions[match[1].toLowerCase()];
            if (!exts || !exts.length) return false;
            return exts[0];
        }
        function lookup(path) {
            if (!path || 'string' != typeof path) return false;
            var extension = extname('x.' + path).toLowerCase().slice(1);
            if (!extension) return false;
            return exports.types[extension] || false;
        }
        function populateMaps(extensions, types) {
            Object.keys(db).forEach(function(type) {
                var mime = db[type];
                var exts = mime.extensions;
                if (!exts || !exts.length) return;
                extensions[type] = exts;
                for(var i = 0; i < exts.length; i++){
                    var extension = exts[i];
                    types[extension] = _preferredType(extension, types[extension], type);
                    const legacyType = _preferredTypeLegacy(extension, types[extension], type);
                    if (legacyType !== types[extension]) exports._extensionConflicts.push([
                        extension,
                        legacyType,
                        types[extension]
                    ]);
                }
            });
        }
        function _preferredType(ext, type0, type1) {
            var score0 = type0 ? mimeScore(type0, db[type0].source) : 0;
            var score1 = type1 ? mimeScore(type1, db[type1].source) : 0;
            return score0 > score1 ? type0 : type1;
        }
        function _preferredTypeLegacy(ext, type0, type1) {
            var SOURCE_RANK = [
                'nginx',
                'apache',
                void 0,
                'iana'
            ];
            var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
            var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
            if ('application/octet-stream' !== exports.types[extension] && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === 'application/')) return type0;
            return score0 > score1 ? type0 : type1;
        }
    },
    "../../../../node_modules/mime-types/mimeScore.js": function(module) {
        var FACET_SCORES = {
            'prs.': 100,
            'x-': 200,
            'x.': 300,
            'vnd.': 400,
            default: 900
        };
        var SOURCE_SCORES = {
            nginx: 10,
            apache: 20,
            iana: 40,
            default: 30
        };
        var TYPE_SCORES = {
            application: 1,
            font: 2,
            default: 0
        };
        module.exports = function(mimeType, source = 'default') {
            if ('application/octet-stream' === mimeType) return 0;
            const [type, subtype] = mimeType.split('/');
            const facet = subtype.replace(/(\.|x-).*/, '$1');
            const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
            const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
            const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
            const lengthScore = 1 - mimeType.length / 100;
            return facetScore + sourceScore + typeScore + lengthScore;
        };
    },
    "../../../../node_modules/mime-types/node_modules/mime-db/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        /*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = __webpack_require__("../../../../node_modules/mime-types/node_modules/mime-db/db.json");
    },
    "../../../../node_modules/node-fetch/node_modules/tr46/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        var punycode = __webpack_require__("punycode");
        var mappingTable = __webpack_require__("../../../../node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json");
        var PROCESSING_OPTIONS = {
            TRANSITIONAL: 0,
            NONTRANSITIONAL: 1
        };
        function normalize(str) {
            return str.split('\u0000').map(function(s) {
                return s.normalize('NFC');
            }).join('\u0000');
        }
        function findStatus(val) {
            var start = 0;
            var end = mappingTable.length - 1;
            while(start <= end){
                var mid = Math.floor((start + end) / 2);
                var target = mappingTable[mid];
                if (target[0][0] <= val && target[0][1] >= val) return target;
                if (target[0][0] > val) end = mid - 1;
                else start = mid + 1;
            }
            return null;
        }
        var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        function countSymbols(string) {
            return string.replace(regexAstralSymbols, '_').length;
        }
        function mapChars(domain_name, useSTD3, processing_option) {
            var hasError = false;
            var processed = "";
            var len = countSymbols(domain_name);
            for(var i = 0; i < len; ++i){
                var codePoint = domain_name.codePointAt(i);
                var status = findStatus(codePoint);
                switch(status[1]){
                    case "disallowed":
                        hasError = true;
                        processed += String.fromCodePoint(codePoint);
                        break;
                    case "ignored":
                        break;
                    case "mapped":
                        processed += String.fromCodePoint.apply(String, status[2]);
                        break;
                    case "deviation":
                        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) processed += String.fromCodePoint.apply(String, status[2]);
                        else processed += String.fromCodePoint(codePoint);
                        break;
                    case "valid":
                        processed += String.fromCodePoint(codePoint);
                        break;
                    case "disallowed_STD3_mapped":
                        if (useSTD3) {
                            hasError = true;
                            processed += String.fromCodePoint(codePoint);
                        } else processed += String.fromCodePoint.apply(String, status[2]);
                        break;
                    case "disallowed_STD3_valid":
                        if (useSTD3) hasError = true;
                        processed += String.fromCodePoint(codePoint);
                        break;
                }
            }
            return {
                string: processed,
                error: hasError
            };
        }
        var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
        function validateLabel(label, processing_option) {
            if ("xn--" === label.substr(0, 4)) {
                label = punycode.toUnicode(label);
                PROCESSING_OPTIONS.NONTRANSITIONAL;
            }
            var error = false;
            if (normalize(label) !== label || "-" === label[3] && "-" === label[4] || "-" === label[0] || "-" === label[label.length - 1] || -1 !== label.indexOf(".") || 0 === label.search(combiningMarksRegex)) error = true;
            var len = countSymbols(label);
            for(var i = 0; i < len; ++i){
                var status = findStatus(label.codePointAt(i));
                if (processing === PROCESSING_OPTIONS.TRANSITIONAL && "valid" !== status[1] || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && "valid" !== status[1] && "deviation" !== status[1]) {
                    error = true;
                    break;
                }
            }
            return {
                label: label,
                error: error
            };
        }
        function processing(domain_name, useSTD3, processing_option) {
            var result = mapChars(domain_name, useSTD3, processing_option);
            result.string = normalize(result.string);
            var labels = result.string.split(".");
            for(var i = 0; i < labels.length; ++i)try {
                var validation = validateLabel(labels[i]);
                labels[i] = validation.label;
                result.error = result.error || validation.error;
            } catch (e) {
                result.error = true;
            }
            return {
                string: labels.join("."),
                error: result.error
            };
        }
        module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
            var result = processing(domain_name, useSTD3, processing_option);
            var labels = result.string.split(".");
            labels = labels.map(function(l) {
                try {
                    return punycode.toASCII(l);
                } catch (e) {
                    result.error = true;
                    return l;
                }
            });
            if (verifyDnsLength) {
                var total = labels.slice(0, labels.length - 1).join(".").length;
                if (total.length > 253 || 0 === total.length) result.error = true;
                for(var i = 0; i < labels.length; ++i)if (labels.length > 63 || 0 === labels.length) {
                    result.error = true;
                    break;
                }
            }
            if (result.error) return null;
            return labels.join(".");
        };
        module.exports.toUnicode = function(domain_name, useSTD3) {
            var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
            return {
                domain: result.string,
                error: result.error
            };
        };
        module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
    },
    "../../../../node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js": function(module) {
        var conversions = {};
        module.exports = conversions;
        function sign(x) {
            return x < 0 ? -1 : 1;
        }
        function evenRound(x) {
            if (x % 1 === 0.5 && (1 & x) === 0) return Math.floor(x);
            return Math.round(x);
        }
        function createNumberConversion(bitLength, typeOpts) {
            if (!typeOpts.unsigned) --bitLength;
            const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
            const upperBound = Math.pow(2, bitLength) - 1;
            const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
            const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
            return function(V, opts) {
                if (!opts) opts = {};
                let x = +V;
                if (opts.enforceRange) {
                    if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite number");
                    x = sign(x) * Math.floor(Math.abs(x));
                    if (x < lowerBound || x > upperBound) throw new TypeError("Argument is not in byte range");
                    return x;
                }
                if (!isNaN(x) && opts.clamp) {
                    x = evenRound(x);
                    if (x < lowerBound) x = lowerBound;
                    if (x > upperBound) x = upperBound;
                    return x;
                }
                if (!Number.isFinite(x) || 0 === x) return 0;
                x = sign(x) * Math.floor(Math.abs(x));
                x %= moduloVal;
                if (!typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
                if (typeOpts.unsigned) {
                    if (x < 0) x += moduloVal;
                    else if (-0 === x) return 0;
                }
                return x;
            };
        }
        conversions["void"] = function() {};
        conversions["boolean"] = function(val) {
            return !!val;
        };
        conversions["byte"] = createNumberConversion(8, {
            unsigned: false
        });
        conversions["octet"] = createNumberConversion(8, {
            unsigned: true
        });
        conversions["short"] = createNumberConversion(16, {
            unsigned: false
        });
        conversions["unsigned short"] = createNumberConversion(16, {
            unsigned: true
        });
        conversions["long"] = createNumberConversion(32, {
            unsigned: false
        });
        conversions["unsigned long"] = createNumberConversion(32, {
            unsigned: true
        });
        conversions["long long"] = createNumberConversion(32, {
            unsigned: false,
            moduloBitLength: 64
        });
        conversions["unsigned long long"] = createNumberConversion(32, {
            unsigned: true,
            moduloBitLength: 64
        });
        conversions["double"] = function(V) {
            const x = +V;
            if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite floating-point value");
            return x;
        };
        conversions["unrestricted double"] = function(V) {
            const x = +V;
            if (isNaN(x)) throw new TypeError("Argument is NaN");
            return x;
        };
        conversions["float"] = conversions["double"];
        conversions["unrestricted float"] = conversions["unrestricted double"];
        conversions["DOMString"] = function(V, opts) {
            if (!opts) opts = {};
            if (opts.treatNullAsEmptyString && null === V) return "";
            return String(V);
        };
        conversions["ByteString"] = function(V, opts) {
            const x = String(V);
            let c;
            for(let i = 0; void 0 !== (c = x.codePointAt(i)); ++i)if (c > 255) throw new TypeError("Argument is not a valid bytestring");
            return x;
        };
        conversions["USVString"] = function(V) {
            const S = String(V);
            const n = S.length;
            const U = [];
            for(let i = 0; i < n; ++i){
                const c = S.charCodeAt(i);
                if (c < 0xD800 || c > 0xDFFF) U.push(String.fromCodePoint(c));
                else if (0xDC00 <= c && c <= 0xDFFF) U.push(String.fromCodePoint(0xFFFD));
                else if (i === n - 1) U.push(String.fromCodePoint(0xFFFD));
                else {
                    const d = S.charCodeAt(i + 1);
                    if (0xDC00 <= d && d <= 0xDFFF) {
                        const a = 0x3FF & c;
                        const b = 0x3FF & d;
                        U.push(String.fromCodePoint(65536 + 1024 * a + b));
                        ++i;
                    } else U.push(String.fromCodePoint(0xFFFD));
                }
            }
            return U.join('');
        };
        conversions["Date"] = function(V, opts) {
            if (!(V instanceof Date)) throw new TypeError("Argument is not a Date object");
            if (isNaN(V)) return;
            return V;
        };
        conversions["RegExp"] = function(V, opts) {
            if (!(V instanceof RegExp)) V = new RegExp(V);
            return V;
        };
    },
    "../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js": function(__unused_webpack_module, exports, __webpack_require__) {
        const usm = __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js");
        exports.implementation = class {
            constructor(constructorArgs){
                const url = constructorArgs[0];
                const base = constructorArgs[1];
                let parsedBase = null;
                if (void 0 !== base) {
                    parsedBase = usm.basicURLParse(base);
                    if ("failure" === parsedBase) throw new TypeError("Invalid base URL");
                }
                const parsedURL = usm.basicURLParse(url, {
                    baseURL: parsedBase
                });
                if ("failure" === parsedURL) throw new TypeError("Invalid URL");
                this._url = parsedURL;
            }
            get href() {
                return usm.serializeURL(this._url);
            }
            set href(v) {
                const parsedURL = usm.basicURLParse(v);
                if ("failure" === parsedURL) throw new TypeError("Invalid URL");
                this._url = parsedURL;
            }
            get origin() {
                return usm.serializeURLOrigin(this._url);
            }
            get protocol() {
                return this._url.scheme + ":";
            }
            set protocol(v) {
                usm.basicURLParse(v + ":", {
                    url: this._url,
                    stateOverride: "scheme start"
                });
            }
            get username() {
                return this._url.username;
            }
            set username(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                usm.setTheUsername(this._url, v);
            }
            get password() {
                return this._url.password;
            }
            set password(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                usm.setThePassword(this._url, v);
            }
            get host() {
                const url = this._url;
                if (null === url.host) return "";
                if (null === url.port) return usm.serializeHost(url.host);
                return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
            }
            set host(v) {
                if (this._url.cannotBeABaseURL) return;
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "host"
                });
            }
            get hostname() {
                if (null === this._url.host) return "";
                return usm.serializeHost(this._url.host);
            }
            set hostname(v) {
                if (this._url.cannotBeABaseURL) return;
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "hostname"
                });
            }
            get port() {
                if (null === this._url.port) return "";
                return usm.serializeInteger(this._url.port);
            }
            set port(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                if ("" === v) this._url.port = null;
                else usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "port"
                });
            }
            get pathname() {
                if (this._url.cannotBeABaseURL) return this._url.path[0];
                if (0 === this._url.path.length) return "";
                return "/" + this._url.path.join("/");
            }
            set pathname(v) {
                if (this._url.cannotBeABaseURL) return;
                this._url.path = [];
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "path start"
                });
            }
            get search() {
                if (null === this._url.query || "" === this._url.query) return "";
                return "?" + this._url.query;
            }
            set search(v) {
                const url = this._url;
                if ("" === v) {
                    url.query = null;
                    return;
                }
                const input = "?" === v[0] ? v.substring(1) : v;
                url.query = "";
                usm.basicURLParse(input, {
                    url,
                    stateOverride: "query"
                });
            }
            get hash() {
                if (null === this._url.fragment || "" === this._url.fragment) return "";
                return "#" + this._url.fragment;
            }
            set hash(v) {
                if ("" === v) {
                    this._url.fragment = null;
                    return;
                }
                const input = "#" === v[0] ? v.substring(1) : v;
                this._url.fragment = "";
                usm.basicURLParse(input, {
                    url: this._url,
                    stateOverride: "fragment"
                });
            }
            toJSON() {
                return this.href;
            }
        };
    },
    "../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const conversions = __webpack_require__("../../../../node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js");
        const utils = __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js");
        const Impl = __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js");
        const impl = utils.implSymbol;
        function URL1(url) {
            if (!this || this[impl] || !(this instanceof URL1)) throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
            if (arguments.length < 1) throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
            const args = [];
            for(let i = 0; i < arguments.length && i < 2; ++i)args[i] = arguments[i];
            args[0] = conversions["USVString"](args[0]);
            if (void 0 !== args[1]) args[1] = conversions["USVString"](args[1]);
            module.exports.setup(this, args);
        }
        URL1.prototype.toJSON = function() {
            if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
            const args = [];
            for(let i = 0; i < arguments.length && i < 0; ++i)args[i] = arguments[i];
            return this[impl].toJSON.apply(this[impl], args);
        };
        Object.defineProperty(URL1.prototype, "href", {
            get () {
                return this[impl].href;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].href = V;
            },
            enumerable: true,
            configurable: true
        });
        URL1.prototype.toString = function() {
            if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
            return this.href;
        };
        Object.defineProperty(URL1.prototype, "origin", {
            get () {
                return this[impl].origin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "protocol", {
            get () {
                return this[impl].protocol;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].protocol = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "username", {
            get () {
                return this[impl].username;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].username = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "password", {
            get () {
                return this[impl].password;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].password = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "host", {
            get () {
                return this[impl].host;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].host = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "hostname", {
            get () {
                return this[impl].hostname;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].hostname = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "port", {
            get () {
                return this[impl].port;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].port = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "pathname", {
            get () {
                return this[impl].pathname;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].pathname = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "search", {
            get () {
                return this[impl].search;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].search = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "hash", {
            get () {
                return this[impl].hash;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].hash = V;
            },
            enumerable: true,
            configurable: true
        });
        module.exports = {
            is (obj) {
                return !!obj && obj[impl] instanceof Impl.implementation;
            },
            create (constructorArgs, privateData) {
                let obj = Object.create(URL1.prototype);
                this.setup(obj, constructorArgs, privateData);
                return obj;
            },
            setup (obj, constructorArgs, privateData) {
                if (!privateData) privateData = {};
                privateData.wrapper = obj;
                obj[impl] = new Impl.implementation(constructorArgs, privateData);
                obj[impl][utils.wrapperSymbol] = obj;
            },
            interface: URL1,
            expose: {
                Window: {
                    URL: URL1
                },
                Worker: {
                    URL: URL1
                }
            }
        };
    },
    "../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js": function(__unused_webpack_module, exports, __webpack_require__) {
        exports.URL = __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js")["interface"];
        __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").serializeURL;
        __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").serializeURLOrigin;
        __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").basicURLParse;
        __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").setTheUsername;
        __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").setThePassword;
        __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").serializeHost;
        __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").serializeInteger;
        __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").parseURL;
    },
    "../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const punycode = __webpack_require__("punycode");
        const tr46 = __webpack_require__("../../../../node_modules/node-fetch/node_modules/tr46/index.js");
        const specialSchemes = {
            ftp: 21,
            file: null,
            gopher: 70,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        };
        const failure = Symbol("failure");
        function countSymbols(str) {
            return punycode.ucs2.decode(str).length;
        }
        function at(input, idx) {
            const c = input[idx];
            return isNaN(c) ? void 0 : String.fromCodePoint(c);
        }
        function isASCIIDigit(c) {
            return c >= 0x30 && c <= 0x39;
        }
        function isASCIIAlpha(c) {
            return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;
        }
        function isASCIIAlphanumeric(c) {
            return isASCIIAlpha(c) || isASCIIDigit(c);
        }
        function isASCIIHex(c) {
            return isASCIIDigit(c) || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;
        }
        function isSingleDot(buffer) {
            return "." === buffer || "%2e" === buffer.toLowerCase();
        }
        function isDoubleDot(buffer) {
            buffer = buffer.toLowerCase();
            return ".." === buffer || "%2e." === buffer || ".%2e" === buffer || "%2e%2e" === buffer;
        }
        function isWindowsDriveLetterCodePoints(cp1, cp2) {
            return isASCIIAlpha(cp1) && (58 === cp2 || 124 === cp2);
        }
        function isWindowsDriveLetterString(string) {
            return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && (":" === string[1] || "|" === string[1]);
        }
        function isNormalizedWindowsDriveLetterString(string) {
            return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && ":" === string[1];
        }
        function containsForbiddenHostCodePoint(string) {
            return -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/);
        }
        function containsForbiddenHostCodePointExcludingPercent(string) {
            return -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/);
        }
        function isSpecialScheme(scheme) {
            return void 0 !== specialSchemes[scheme];
        }
        function isSpecial(url) {
            return isSpecialScheme(url.scheme);
        }
        function defaultPort(scheme) {
            return specialSchemes[scheme];
        }
        function percentEncode(c) {
            let hex = c.toString(16).toUpperCase();
            if (1 === hex.length) hex = "0" + hex;
            return "%" + hex;
        }
        function utf8PercentEncode(c) {
            const buf = new Buffer(c);
            let str = "";
            for(let i = 0; i < buf.length; ++i)str += percentEncode(buf[i]);
            return str;
        }
        function utf8PercentDecode(str) {
            const input = new Buffer(str);
            const output = [];
            for(let i = 0; i < input.length; ++i)if (37 !== input[i]) output.push(input[i]);
            else if (37 === input[i] && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
                output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
                i += 2;
            } else output.push(input[i]);
            return new Buffer(output).toString();
        }
        function isC0ControlPercentEncode(c) {
            return c <= 0x1F || c > 0x7E;
        }
        const extraPathPercentEncodeSet = new Set([
            32,
            34,
            35,
            60,
            62,
            63,
            96,
            123,
            125
        ]);
        function isPathPercentEncode(c) {
            return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
        }
        const extraUserinfoPercentEncodeSet = new Set([
            47,
            58,
            59,
            61,
            64,
            91,
            92,
            93,
            94,
            124
        ]);
        function isUserinfoPercentEncode(c) {
            return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
        }
        function percentEncodeChar(c, encodeSetPredicate) {
            const cStr = String.fromCodePoint(c);
            if (encodeSetPredicate(c)) return utf8PercentEncode(cStr);
            return cStr;
        }
        function parseIPv4Number(input) {
            let R = 10;
            if (input.length >= 2 && "0" === input.charAt(0) && "x" === input.charAt(1).toLowerCase()) {
                input = input.substring(2);
                R = 16;
            } else if (input.length >= 2 && "0" === input.charAt(0)) {
                input = input.substring(1);
                R = 8;
            }
            if ("" === input) return 0;
            const regex = 10 === R ? /[^0-9]/ : 16 === R ? /[^0-9A-Fa-f]/ : /[^0-7]/;
            if (regex.test(input)) return failure;
            return parseInt(input, R);
        }
        function parseIPv4(input) {
            const parts = input.split(".");
            if ("" === parts[parts.length - 1]) {
                if (parts.length > 1) parts.pop();
            }
            if (parts.length > 4) return input;
            const numbers = [];
            for (const part of parts){
                if ("" === part) return input;
                const n = parseIPv4Number(part);
                if (n === failure) return input;
                numbers.push(n);
            }
            for(let i = 0; i < numbers.length - 1; ++i)if (numbers[i] > 255) return failure;
            if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) return failure;
            let ipv4 = numbers.pop();
            let counter = 0;
            for (const n of numbers){
                ipv4 += n * Math.pow(256, 3 - counter);
                ++counter;
            }
            return ipv4;
        }
        function serializeIPv4(address) {
            let output = "";
            let n = address;
            for(let i = 1; i <= 4; ++i){
                output = String(n % 256) + output;
                if (4 !== i) output = "." + output;
                n = Math.floor(n / 256);
            }
            return output;
        }
        function parseIPv6(input) {
            const address = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
            let pieceIndex = 0;
            let compress = null;
            let pointer = 0;
            input = punycode.ucs2.decode(input);
            if (58 === input[pointer]) {
                if (58 !== input[pointer + 1]) return failure;
                pointer += 2;
                ++pieceIndex;
                compress = pieceIndex;
            }
            while(pointer < input.length){
                if (8 === pieceIndex) return failure;
                if (58 === input[pointer]) {
                    if (null !== compress) return failure;
                    ++pointer;
                    ++pieceIndex;
                    compress = pieceIndex;
                    continue;
                }
                let value = 0;
                let length = 0;
                while(length < 4 && isASCIIHex(input[pointer])){
                    value = 0x10 * value + parseInt(at(input, pointer), 16);
                    ++pointer;
                    ++length;
                }
                if (46 === input[pointer]) {
                    if (0 === length) return failure;
                    pointer -= length;
                    if (pieceIndex > 6) return failure;
                    let numbersSeen = 0;
                    while(void 0 !== input[pointer]){
                        let ipv4Piece = null;
                        if (numbersSeen > 0) {
                            if (46 !== input[pointer] || !(numbersSeen < 4)) return failure;
                            ++pointer;
                        }
                        if (!isASCIIDigit(input[pointer])) return failure;
                        while(isASCIIDigit(input[pointer])){
                            const number = parseInt(at(input, pointer));
                            if (null === ipv4Piece) ipv4Piece = number;
                            else {
                                if (0 === ipv4Piece) return failure;
                                ipv4Piece = 10 * ipv4Piece + number;
                            }
                            if (ipv4Piece > 255) return failure;
                            ++pointer;
                        }
                        address[pieceIndex] = 0x100 * address[pieceIndex] + ipv4Piece;
                        ++numbersSeen;
                        if (2 === numbersSeen || 4 === numbersSeen) ++pieceIndex;
                    }
                    if (4 !== numbersSeen) return failure;
                    break;
                }
                if (58 === input[pointer]) {
                    ++pointer;
                    if (void 0 === input[pointer]) return failure;
                } else if (void 0 !== input[pointer]) return failure;
                address[pieceIndex] = value;
                ++pieceIndex;
            }
            if (null !== compress) {
                let swaps = pieceIndex - compress;
                pieceIndex = 7;
                while(0 !== pieceIndex && swaps > 0){
                    const temp = address[compress + swaps - 1];
                    address[compress + swaps - 1] = address[pieceIndex];
                    address[pieceIndex] = temp;
                    --pieceIndex;
                    --swaps;
                }
            } else if (null === compress && 8 !== pieceIndex) return failure;
            return address;
        }
        function serializeIPv6(address) {
            let output = "";
            const seqResult = findLongestZeroSequence(address);
            const compress = seqResult.idx;
            let ignore0 = false;
            for(let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex)if (!ignore0 || 0 !== address[pieceIndex]) {
                if (ignore0) ignore0 = false;
                if (compress === pieceIndex) {
                    const separator = 0 === pieceIndex ? "::" : ":";
                    output += separator;
                    ignore0 = true;
                    continue;
                }
                output += address[pieceIndex].toString(16);
                if (7 !== pieceIndex) output += ":";
            }
            return output;
        }
        function parseHost(input, isSpecialArg) {
            if ("[" === input[0]) {
                if ("]" !== input[input.length - 1]) return failure;
                return parseIPv6(input.substring(1, input.length - 1));
            }
            if (!isSpecialArg) return parseOpaqueHost(input);
            const domain = utf8PercentDecode(input);
            const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
            if (null === asciiDomain) return failure;
            if (containsForbiddenHostCodePoint(asciiDomain)) return failure;
            const ipv4Host = parseIPv4(asciiDomain);
            if ("number" == typeof ipv4Host || ipv4Host === failure) return ipv4Host;
            return asciiDomain;
        }
        function parseOpaqueHost(input) {
            if (containsForbiddenHostCodePointExcludingPercent(input)) return failure;
            let output = "";
            const decoded = punycode.ucs2.decode(input);
            for(let i = 0; i < decoded.length; ++i)output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
            return output;
        }
        function findLongestZeroSequence(arr) {
            let maxIdx = null;
            let maxLen = 1;
            let currStart = null;
            let currLen = 0;
            for(let i = 0; i < arr.length; ++i)if (0 !== arr[i]) {
                if (currLen > maxLen) {
                    maxIdx = currStart;
                    maxLen = currLen;
                }
                currStart = null;
                currLen = 0;
            } else {
                if (null === currStart) currStart = i;
                ++currLen;
            }
            if (currLen > maxLen) {
                maxIdx = currStart;
                maxLen = currLen;
            }
            return {
                idx: maxIdx,
                len: maxLen
            };
        }
        function serializeHost(host) {
            if ("number" == typeof host) return serializeIPv4(host);
            if (host instanceof Array) return "[" + serializeIPv6(host) + "]";
            return host;
        }
        function trimControlChars(url) {
            return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
        }
        function trimTabAndNewline(url) {
            return url.replace(/\u0009|\u000A|\u000D/g, "");
        }
        function shortenPath(url) {
            const path = url.path;
            if (0 === path.length) return;
            if ("file" === url.scheme && 1 === path.length && isNormalizedWindowsDriveLetter(path[0])) return;
            path.pop();
        }
        function includesCredentials(url) {
            return "" !== url.username || "" !== url.password;
        }
        function cannotHaveAUsernamePasswordPort(url) {
            return null === url.host || "" === url.host || url.cannotBeABaseURL || "file" === url.scheme;
        }
        function isNormalizedWindowsDriveLetter(string) {
            return /^[A-Za-z]:$/.test(string);
        }
        function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
            this.pointer = 0;
            this.input = input;
            this.base = base || null;
            this.encodingOverride = encodingOverride || "utf-8";
            this.stateOverride = stateOverride;
            this.url = url;
            this.failure = false;
            this.parseError = false;
            if (!this.url) {
                this.url = {
                    scheme: "",
                    username: "",
                    password: "",
                    host: null,
                    port: null,
                    path: [],
                    query: null,
                    fragment: null,
                    cannotBeABaseURL: false
                };
                const res = trimControlChars(this.input);
                if (res !== this.input) this.parseError = true;
                this.input = res;
            }
            const res = trimTabAndNewline(this.input);
            if (res !== this.input) this.parseError = true;
            this.input = res;
            this.state = stateOverride || "scheme start";
            this.buffer = "";
            this.atFlag = false;
            this.arrFlag = false;
            this.passwordTokenSeenFlag = false;
            this.input = punycode.ucs2.decode(this.input);
            for(; this.pointer <= this.input.length; ++this.pointer){
                const c = this.input[this.pointer];
                const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
                const ret = this["parse " + this.state](c, cStr);
                if (ret) {
                    if (ret === failure) {
                        this.failure = true;
                        break;
                    }
                } else break;
            }
        }
        URLStateMachine.prototype["parse scheme start"] = function(c, cStr) {
            if (isASCIIAlpha(c)) {
                this.buffer += cStr.toLowerCase();
                this.state = "scheme";
            } else if (this.stateOverride) {
                this.parseError = true;
                return failure;
            } else {
                this.state = "no scheme";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse scheme"] = function(c, cStr) {
            if (isASCIIAlphanumeric(c) || 43 === c || 45 === c || 46 === c) this.buffer += cStr.toLowerCase();
            else if (58 === c) {
                if (this.stateOverride) {
                    if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) return false;
                    if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) return false;
                    if ((includesCredentials(this.url) || null !== this.url.port) && "file" === this.buffer) return false;
                    if ("file" === this.url.scheme && ("" === this.url.host || null === this.url.host)) return false;
                }
                this.url.scheme = this.buffer;
                this.buffer = "";
                if (this.stateOverride) return false;
                if ("file" === this.url.scheme) {
                    if (47 !== this.input[this.pointer + 1] || 47 !== this.input[this.pointer + 2]) this.parseError = true;
                    this.state = "file";
                } else if (isSpecial(this.url) && null !== this.base && this.base.scheme === this.url.scheme) this.state = "special relative or authority";
                else if (isSpecial(this.url)) this.state = "special authority slashes";
                else if (47 === this.input[this.pointer + 1]) {
                    this.state = "path or authority";
                    ++this.pointer;
                } else {
                    this.url.cannotBeABaseURL = true;
                    this.url.path.push("");
                    this.state = "cannot-be-a-base-URL path";
                }
            } else if (this.stateOverride) {
                this.parseError = true;
                return failure;
            } else {
                this.buffer = "";
                this.state = "no scheme";
                this.pointer = -1;
            }
            return true;
        };
        URLStateMachine.prototype["parse no scheme"] = function(c) {
            if (null === this.base || this.base.cannotBeABaseURL && 35 !== c) return failure;
            if (this.base.cannotBeABaseURL && 35 === c) {
                this.url.scheme = this.base.scheme;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.url.cannotBeABaseURL = true;
                this.state = "fragment";
            } else if ("file" === this.base.scheme) {
                this.state = "file";
                --this.pointer;
            } else {
                this.state = "relative";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special relative or authority"] = function(c) {
            if (47 === c && 47 === this.input[this.pointer + 1]) {
                this.state = "special authority ignore slashes";
                ++this.pointer;
            } else {
                this.parseError = true;
                this.state = "relative";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse path or authority"] = function(c) {
            if (47 === c) this.state = "authority";
            else {
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse relative"] = function(c) {
            this.url.scheme = this.base.scheme;
            if (isNaN(c)) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
            } else if (47 === c) this.state = "relative slash";
            else if (63 === c) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = "";
                this.state = "query";
            } else if (35 === c) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.state = "fragment";
            } else if (isSpecial(this.url) && 92 === c) {
                this.parseError = true;
                this.state = "relative slash";
            } else {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice(0, this.base.path.length - 1);
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse relative slash"] = function(c) {
            if (isSpecial(this.url) && (47 === c || 92 === c)) {
                if (92 === c) this.parseError = true;
                this.state = "special authority ignore slashes";
            } else if (47 === c) this.state = "authority";
            else {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special authority slashes"] = function(c) {
            if (47 === c && 47 === this.input[this.pointer + 1]) {
                this.state = "special authority ignore slashes";
                ++this.pointer;
            } else {
                this.parseError = true;
                this.state = "special authority ignore slashes";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special authority ignore slashes"] = function(c) {
            if (47 !== c && 92 !== c) {
                this.state = "authority";
                --this.pointer;
            } else this.parseError = true;
            return true;
        };
        URLStateMachine.prototype["parse authority"] = function(c, cStr) {
            if (64 === c) {
                this.parseError = true;
                if (this.atFlag) this.buffer = "%40" + this.buffer;
                this.atFlag = true;
                const len = countSymbols(this.buffer);
                for(let pointer = 0; pointer < len; ++pointer){
                    const codePoint = this.buffer.codePointAt(pointer);
                    if (58 === codePoint && !this.passwordTokenSeenFlag) {
                        this.passwordTokenSeenFlag = true;
                        continue;
                    }
                    const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
                    if (this.passwordTokenSeenFlag) this.url.password += encodedCodePoints;
                    else this.url.username += encodedCodePoints;
                }
                this.buffer = "";
            } else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
                if (this.atFlag && "" === this.buffer) {
                    this.parseError = true;
                    return failure;
                }
                this.pointer -= countSymbols(this.buffer) + 1;
                this.buffer = "";
                this.state = "host";
            } else this.buffer += cStr;
            return true;
        };
        URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function(c, cStr) {
            if (this.stateOverride && "file" === this.url.scheme) {
                --this.pointer;
                this.state = "file host";
            } else if (58 !== c || this.arrFlag) {
                if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
                    --this.pointer;
                    if (isSpecial(this.url) && "" === this.buffer) {
                        this.parseError = true;
                        return failure;
                    }
                    if (this.stateOverride && "" === this.buffer && (includesCredentials(this.url) || null !== this.url.port)) {
                        this.parseError = true;
                        return false;
                    }
                    const host = parseHost(this.buffer, isSpecial(this.url));
                    if (host === failure) return failure;
                    this.url.host = host;
                    this.buffer = "";
                    this.state = "path start";
                    if (this.stateOverride) return false;
                } else {
                    if (91 === c) this.arrFlag = true;
                    else if (93 === c) this.arrFlag = false;
                    this.buffer += cStr;
                }
            } else {
                if ("" === this.buffer) {
                    this.parseError = true;
                    return failure;
                }
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) return failure;
                this.url.host = host;
                this.buffer = "";
                this.state = "port";
                if ("hostname" === this.stateOverride) return false;
            }
            return true;
        };
        URLStateMachine.prototype["parse port"] = function(c, cStr) {
            if (isASCIIDigit(c)) this.buffer += cStr;
            else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c || this.stateOverride) {
                if ("" !== this.buffer) {
                    const port = parseInt(this.buffer);
                    if (port > Math.pow(2, 16) - 1) {
                        this.parseError = true;
                        return failure;
                    }
                    this.url.port = port === defaultPort(this.url.scheme) ? null : port;
                    this.buffer = "";
                }
                if (this.stateOverride) return false;
                this.state = "path start";
                --this.pointer;
            } else {
                this.parseError = true;
                return failure;
            }
            return true;
        };
        const fileOtherwiseCodePoints = new Set([
            47,
            92,
            63,
            35
        ]);
        URLStateMachine.prototype["parse file"] = function(c) {
            this.url.scheme = "file";
            if (47 === c || 92 === c) {
                if (92 === c) this.parseError = true;
                this.state = "file slash";
            } else if (null !== this.base && "file" === this.base.scheme) {
                if (isNaN(c)) {
                    this.url.host = this.base.host;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                } else if (63 === c) {
                    this.url.host = this.base.host;
                    this.url.path = this.base.path.slice();
                    this.url.query = "";
                    this.state = "query";
                } else if (35 === c) {
                    this.url.host = this.base.host;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                    this.url.fragment = "";
                    this.state = "fragment";
                } else {
                    if (this.input.length - this.pointer - 1 !== 0 && isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) && (!(this.input.length - this.pointer - 1 >= 2) || fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) this.parseError = true;
                    else {
                        this.url.host = this.base.host;
                        this.url.path = this.base.path.slice();
                        shortenPath(this.url);
                    }
                    this.state = "path";
                    --this.pointer;
                }
            } else {
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse file slash"] = function(c) {
            if (47 === c || 92 === c) {
                if (92 === c) this.parseError = true;
                this.state = "file host";
            } else {
                if (null !== this.base && "file" === this.base.scheme) {
                    if (isNormalizedWindowsDriveLetterString(this.base.path[0])) this.url.path.push(this.base.path[0]);
                    else this.url.host = this.base.host;
                }
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse file host"] = function(c, cStr) {
            if (isNaN(c) || 47 === c || 92 === c || 63 === c || 35 === c) {
                --this.pointer;
                if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
                    this.parseError = true;
                    this.state = "path";
                } else if ("" === this.buffer) {
                    this.url.host = "";
                    if (this.stateOverride) return false;
                    this.state = "path start";
                } else {
                    let host = parseHost(this.buffer, isSpecial(this.url));
                    if (host === failure) return failure;
                    if ("localhost" === host) host = "";
                    this.url.host = host;
                    if (this.stateOverride) return false;
                    this.buffer = "";
                    this.state = "path start";
                }
            } else this.buffer += cStr;
            return true;
        };
        URLStateMachine.prototype["parse path start"] = function(c) {
            if (isSpecial(this.url)) {
                if (92 === c) this.parseError = true;
                this.state = "path";
                if (47 !== c && 92 !== c) --this.pointer;
            } else if (this.stateOverride || 63 !== c) {
                if (this.stateOverride || 35 !== c) {
                    if (void 0 !== c) {
                        this.state = "path";
                        if (47 !== c) --this.pointer;
                    }
                } else {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                this.url.query = "";
                this.state = "query";
            }
            return true;
        };
        URLStateMachine.prototype["parse path"] = function(c) {
            if (isNaN(c) || 47 === c || isSpecial(this.url) && 92 === c || !this.stateOverride && (63 === c || 35 === c)) {
                if (isSpecial(this.url) && 92 === c) this.parseError = true;
                if (isDoubleDot(this.buffer)) {
                    shortenPath(this.url);
                    if (47 !== c && !(isSpecial(this.url) && 92 === c)) this.url.path.push("");
                } else if (isSingleDot(this.buffer) && 47 !== c && !(isSpecial(this.url) && 92 === c)) this.url.path.push("");
                else if (!isSingleDot(this.buffer)) {
                    if ("file" === this.url.scheme && 0 === this.url.path.length && isWindowsDriveLetterString(this.buffer)) {
                        if ("" !== this.url.host && null !== this.url.host) {
                            this.parseError = true;
                            this.url.host = "";
                        }
                        this.buffer = this.buffer[0] + ":";
                    }
                    this.url.path.push(this.buffer);
                }
                this.buffer = "";
                if ("file" === this.url.scheme && (void 0 === c || 63 === c || 35 === c)) while(this.url.path.length > 1 && "" === this.url.path[0]){
                    this.parseError = true;
                    this.url.path.shift();
                }
                if (63 === c) {
                    this.url.query = "";
                    this.state = "query";
                }
                if (35 === c) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.buffer += percentEncodeChar(c, isPathPercentEncode);
            }
            return true;
        };
        URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function(c) {
            if (63 === c) {
                this.url.query = "";
                this.state = "query";
            } else if (35 === c) {
                this.url.fragment = "";
                this.state = "fragment";
            } else {
                if (!isNaN(c) && 37 !== c) this.parseError = true;
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                if (!isNaN(c)) this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
            }
            return true;
        };
        URLStateMachine.prototype["parse query"] = function(c, cStr) {
            if (isNaN(c) || !this.stateOverride && 35 === c) {
                if (!isSpecial(this.url) || "ws" === this.url.scheme || "wss" === this.url.scheme) this.encodingOverride = "utf-8";
                const buffer = new Buffer(this.buffer);
                for(let i = 0; i < buffer.length; ++i)if (buffer[i] < 0x21 || buffer[i] > 0x7E || 0x22 === buffer[i] || 0x23 === buffer[i] || 0x3C === buffer[i] || 0x3E === buffer[i]) this.url.query += percentEncode(buffer[i]);
                else this.url.query += String.fromCodePoint(buffer[i]);
                this.buffer = "";
                if (35 === c) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.buffer += cStr;
            }
            return true;
        };
        URLStateMachine.prototype["parse fragment"] = function(c) {
            if (isNaN(c)) ;
            else if (0x0 === c) this.parseError = true;
            else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
            }
            return true;
        };
        function serializeURL(url, excludeFragment) {
            let output = url.scheme + ":";
            if (null !== url.host) {
                output += "//";
                if ("" !== url.username || "" !== url.password) {
                    output += url.username;
                    if ("" !== url.password) output += ":" + url.password;
                    output += "@";
                }
                output += serializeHost(url.host);
                if (null !== url.port) output += ":" + url.port;
            } else if (null === url.host && "file" === url.scheme) output += "//";
            if (url.cannotBeABaseURL) output += url.path[0];
            else for (const string of url.path)output += "/" + string;
            if (null !== url.query) output += "?" + url.query;
            if (!excludeFragment && null !== url.fragment) output += "#" + url.fragment;
            return output;
        }
        function serializeOrigin(tuple) {
            let result = tuple.scheme + "://";
            result += serializeHost(tuple.host);
            if (null !== tuple.port) result += ":" + tuple.port;
            return result;
        }
        module.exports.serializeURL = serializeURL;
        module.exports.serializeURLOrigin = function(url) {
            switch(url.scheme){
                case "blob":
                    try {
                        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
                    } catch (e) {
                        return "null";
                    }
                case "ftp":
                case "gopher":
                case "http":
                case "https":
                case "ws":
                case "wss":
                    return serializeOrigin({
                        scheme: url.scheme,
                        host: url.host,
                        port: url.port
                    });
                case "file":
                    return "file://";
                default:
                    return "null";
            }
        };
        module.exports.basicURLParse = function(input, options) {
            if (void 0 === options) options = {};
            const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
            if (usm.failure) return "failure";
            return usm.url;
        };
        module.exports.setTheUsername = function(url, username) {
            url.username = "";
            const decoded = punycode.ucs2.decode(username);
            for(let i = 0; i < decoded.length; ++i)url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        };
        module.exports.setThePassword = function(url, password) {
            url.password = "";
            const decoded = punycode.ucs2.decode(password);
            for(let i = 0; i < decoded.length; ++i)url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        };
        module.exports.serializeHost = serializeHost;
        module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
        module.exports.serializeInteger = function(integer) {
            return String(integer);
        };
        module.exports.parseURL = function(input, options) {
            if (void 0 === options) options = {};
            return module.exports.basicURLParse(input, {
                baseURL: options.baseURL,
                encodingOverride: options.encodingOverride
            });
        };
    },
    "../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js": function(module) {
        module.exports.mixin = function(target, source) {
            const keys = Object.getOwnPropertyNames(source);
            for(let i = 0; i < keys.length; ++i)Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
        };
        module.exports.wrapperSymbol = Symbol("wrapper");
        module.exports.implSymbol = Symbol("impl");
        module.exports.wrapperForImpl = function(impl) {
            return impl[module.exports.wrapperSymbol];
        };
        module.exports.implForWrapper = function(wrapper) {
            return wrapper[module.exports.implSymbol];
        };
    },
    "../../../../node_modules/p-finally/index.js": function(module) {
        module.exports = (promise, onFinally)=>{
            onFinally = onFinally || (()=>{});
            return promise.then((val)=>new Promise((resolve)=>{
                    resolve(onFinally());
                }).then(()=>val), (err)=>new Promise((resolve)=>{
                    resolve(onFinally());
                }).then(()=>{
                    throw err;
                }));
        };
    },
    "../../../../node_modules/p-queue/dist/index.js": function(__unused_webpack_module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const EventEmitter = __webpack_require__("../../../../node_modules/p-queue/node_modules/eventemitter3/index.js");
        const p_timeout_1 = __webpack_require__("../../../../node_modules/p-timeout/index.js");
        const priority_queue_1 = __webpack_require__("../../../../node_modules/p-queue/dist/priority-queue.js");
        const empty = ()=>{};
        const timeoutError = new p_timeout_1.TimeoutError();
        class PQueue extends EventEmitter {
            constructor(options){
                var _a, _b, _c, _d;
                super();
                this._intervalCount = 0;
                this._intervalEnd = 0;
                this._pendingCount = 0;
                this._resolveEmpty = empty;
                this._resolveIdle = empty;
                options = Object.assign({
                    carryoverConcurrencyCount: false,
                    intervalCap: 1 / 0,
                    interval: 0,
                    concurrency: 1 / 0,
                    autoStart: true,
                    queueClass: priority_queue_1.default
                }, options);
                if (!('number' == typeof options.intervalCap && options.intervalCap >= 1)) throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${null !== (_b = null === (_a = options.intervalCap) || void 0 === _a ? void 0 : _a.toString()) && void 0 !== _b ? _b : ''}\` (${typeof options.intervalCap})`);
                if (void 0 === options.interval || !(Number.isFinite(options.interval) && options.interval >= 0)) throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${null !== (_d = null === (_c = options.interval) || void 0 === _c ? void 0 : _c.toString()) && void 0 !== _d ? _d : ''}\` (${typeof options.interval})`);
                this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
                this._isIntervalIgnored = options.intervalCap === 1 / 0 || 0 === options.interval;
                this._intervalCap = options.intervalCap;
                this._interval = options.interval;
                this._queue = new options.queueClass();
                this._queueClass = options.queueClass;
                this.concurrency = options.concurrency;
                this._timeout = options.timeout;
                this._throwOnTimeout = true === options.throwOnTimeout;
                this._isPaused = false === options.autoStart;
            }
            get _doesIntervalAllowAnother() {
                return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
            }
            get _doesConcurrentAllowAnother() {
                return this._pendingCount < this._concurrency;
            }
            _next() {
                this._pendingCount--;
                this._tryToStartAnother();
                this.emit('next');
            }
            _resolvePromises() {
                this._resolveEmpty();
                this._resolveEmpty = empty;
                if (0 === this._pendingCount) {
                    this._resolveIdle();
                    this._resolveIdle = empty;
                    this.emit('idle');
                }
            }
            _onResumeInterval() {
                this._onInterval();
                this._initializeIntervalIfNeeded();
                this._timeoutId = void 0;
            }
            _isIntervalPaused() {
                const now = Date.now();
                if (void 0 === this._intervalId) {
                    const delay = this._intervalEnd - now;
                    if (delay < 0) this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
                    else {
                        if (void 0 === this._timeoutId) this._timeoutId = setTimeout(()=>{
                            this._onResumeInterval();
                        }, delay);
                        return true;
                    }
                }
                return false;
            }
            _tryToStartAnother() {
                if (0 === this._queue.size) {
                    if (this._intervalId) clearInterval(this._intervalId);
                    this._intervalId = void 0;
                    this._resolvePromises();
                    return false;
                }
                if (!this._isPaused) {
                    const canInitializeInterval = !this._isIntervalPaused();
                    if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
                        const job = this._queue.dequeue();
                        if (!job) return false;
                        this.emit('active');
                        job();
                        if (canInitializeInterval) this._initializeIntervalIfNeeded();
                        return true;
                    }
                }
                return false;
            }
            _initializeIntervalIfNeeded() {
                if (this._isIntervalIgnored || void 0 !== this._intervalId) return;
                this._intervalId = setInterval(()=>{
                    this._onInterval();
                }, this._interval);
                this._intervalEnd = Date.now() + this._interval;
            }
            _onInterval() {
                if (0 === this._intervalCount && 0 === this._pendingCount && this._intervalId) {
                    clearInterval(this._intervalId);
                    this._intervalId = void 0;
                }
                this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
                this._processQueue();
            }
            _processQueue() {
                while(this._tryToStartAnother());
            }
            get concurrency() {
                return this._concurrency;
            }
            set concurrency(newConcurrency) {
                if (!('number' == typeof newConcurrency && newConcurrency >= 1)) throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
                this._concurrency = newConcurrency;
                this._processQueue();
            }
            async add(fn, options = {}) {
                return new Promise((resolve, reject)=>{
                    const run = async ()=>{
                        this._pendingCount++;
                        this._intervalCount++;
                        try {
                            const operation = void 0 === this._timeout && void 0 === options.timeout ? fn() : p_timeout_1.default(Promise.resolve(fn()), void 0 === options.timeout ? this._timeout : options.timeout, ()=>{
                                if (void 0 === options.throwOnTimeout ? this._throwOnTimeout : options.throwOnTimeout) reject(timeoutError);
                            });
                            resolve(await operation);
                        } catch (error) {
                            reject(error);
                        }
                        this._next();
                    };
                    this._queue.enqueue(run, options);
                    this._tryToStartAnother();
                    this.emit('add');
                });
            }
            async addAll(functions, options) {
                return Promise.all(functions.map(async (function_)=>this.add(function_, options)));
            }
            start() {
                if (!this._isPaused) return this;
                this._isPaused = false;
                this._processQueue();
                return this;
            }
            pause() {
                this._isPaused = true;
            }
            clear() {
                this._queue = new this._queueClass();
            }
            async onEmpty() {
                if (0 === this._queue.size) return;
                return new Promise((resolve)=>{
                    const existingResolve = this._resolveEmpty;
                    this._resolveEmpty = ()=>{
                        existingResolve();
                        resolve();
                    };
                });
            }
            async onIdle() {
                if (0 === this._pendingCount && 0 === this._queue.size) return;
                return new Promise((resolve)=>{
                    const existingResolve = this._resolveIdle;
                    this._resolveIdle = ()=>{
                        existingResolve();
                        resolve();
                    };
                });
            }
            get size() {
                return this._queue.size;
            }
            sizeBy(options) {
                return this._queue.filter(options).length;
            }
            get pending() {
                return this._pendingCount;
            }
            get isPaused() {
                return this._isPaused;
            }
            get timeout() {
                return this._timeout;
            }
            set timeout(milliseconds) {
                this._timeout = milliseconds;
            }
        }
        exports["default"] = PQueue;
    },
    "../../../../node_modules/p-queue/dist/lower-bound.js": function(__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function lowerBound(array, value, comparator) {
            let first = 0;
            let count = array.length;
            while(count > 0){
                const step = count / 2 | 0;
                let it = first + step;
                if (comparator(array[it], value) <= 0) {
                    first = ++it;
                    count -= step + 1;
                } else count = step;
            }
            return first;
        }
        exports["default"] = lowerBound;
    },
    "../../../../node_modules/p-queue/dist/priority-queue.js": function(__unused_webpack_module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const lower_bound_1 = __webpack_require__("../../../../node_modules/p-queue/dist/lower-bound.js");
        class PriorityQueue {
            constructor(){
                this._queue = [];
            }
            enqueue(run, options) {
                options = Object.assign({
                    priority: 0
                }, options);
                const element = {
                    priority: options.priority,
                    run
                };
                if (this.size && this._queue[this.size - 1].priority >= options.priority) {
                    this._queue.push(element);
                    return;
                }
                const index = lower_bound_1.default(this._queue, element, (a, b)=>b.priority - a.priority);
                this._queue.splice(index, 0, element);
            }
            dequeue() {
                const item = this._queue.shift();
                return null == item ? void 0 : item.run;
            }
            filter(options) {
                return this._queue.filter((element)=>element.priority === options.priority).map((element)=>element.run);
            }
            get size() {
                return this._queue.length;
            }
        }
        exports["default"] = PriorityQueue;
    },
    "../../../../node_modules/p-queue/node_modules/eventemitter3/index.js": function(module) {
        var has = Object.prototype.hasOwnProperty, prefix = '~';
        function Events() {}
        if (Object.create) {
            Events.prototype = Object.create(null);
            if (!new Events().__proto__) prefix = false;
        }
        function EE(fn, context, once) {
            this.fn = fn;
            this.context = context;
            this.once = once || false;
        }
        function addListener(emitter, event, fn, context, once) {
            if ('function' != typeof fn) throw new TypeError('The listener must be a function');
            var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
            if (emitter._events[evt]) {
                if (emitter._events[evt].fn) emitter._events[evt] = [
                    emitter._events[evt],
                    listener
                ];
                else emitter._events[evt].push(listener);
            } else emitter._events[evt] = listener, emitter._eventsCount++;
            return emitter;
        }
        function clearEvent(emitter, evt) {
            if (0 === --emitter._eventsCount) emitter._events = new Events();
            else delete emitter._events[evt];
        }
        function EventEmitter() {
            this._events = new Events();
            this._eventsCount = 0;
        }
        EventEmitter.prototype.eventNames = function() {
            var names = [], events, name;
            if (0 === this._eventsCount) return names;
            for(name in events = this._events)if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
            if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
            return names;
        };
        EventEmitter.prototype.listeners = function(event) {
            var evt = prefix ? prefix + event : event, handlers = this._events[evt];
            if (!handlers) return [];
            if (handlers.fn) return [
                handlers.fn
            ];
            for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;
            return ee;
        };
        EventEmitter.prototype.listenerCount = function(event) {
            var evt = prefix ? prefix + event : event, listeners = this._events[evt];
            if (!listeners) return 0;
            if (listeners.fn) return 1;
            return listeners.length;
        };
        EventEmitter.prototype.emit = function(event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return false;
            var listeners = this._events[evt], len = arguments.length, args, i;
            if (listeners.fn) {
                if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
                switch(len){
                    case 1:
                        return listeners.fn.call(listeners.context), true;
                    case 2:
                        return listeners.fn.call(listeners.context, a1), true;
                    case 3:
                        return listeners.fn.call(listeners.context, a1, a2), true;
                    case 4:
                        return listeners.fn.call(listeners.context, a1, a2, a3), true;
                    case 5:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                    case 6:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                }
                for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];
                listeners.fn.apply(listeners.context, args);
            } else {
                var length = listeners.length, j;
                for(i = 0; i < length; i++){
                    if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
                    switch(len){
                        case 1:
                            listeners[i].fn.call(listeners[i].context);
                            break;
                        case 2:
                            listeners[i].fn.call(listeners[i].context, a1);
                            break;
                        case 3:
                            listeners[i].fn.call(listeners[i].context, a1, a2);
                            break;
                        case 4:
                            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                            break;
                        default:
                            if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];
                            listeners[i].fn.apply(listeners[i].context, args);
                    }
                }
            }
            return true;
        };
        EventEmitter.prototype.on = function(event, fn, context) {
            return addListener(this, event, fn, context, false);
        };
        EventEmitter.prototype.once = function(event, fn, context) {
            return addListener(this, event, fn, context, true);
        };
        EventEmitter.prototype.removeListener = function(event, fn, context, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return this;
            if (!fn) {
                clearEvent(this, evt);
                return this;
            }
            var listeners = this._events[evt];
            if (listeners.fn) {
                if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
            } else {
                for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
                if (events.length) this._events[evt] = 1 === events.length ? events[0] : events;
                else clearEvent(this, evt);
            }
            return this;
        };
        EventEmitter.prototype.removeAllListeners = function(event) {
            var evt;
            if (event) {
                evt = prefix ? prefix + event : event;
                if (this._events[evt]) clearEvent(this, evt);
            } else {
                this._events = new Events();
                this._eventsCount = 0;
            }
            return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.addListener = EventEmitter.prototype.on;
        EventEmitter.prefixed = prefix;
        EventEmitter.EventEmitter = EventEmitter;
        module.exports = EventEmitter;
    },
    "../../../../node_modules/p-retry/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const retry = __webpack_require__("../../../../node_modules/retry/index.js");
        const networkErrorMsgs = [
            'Failed to fetch',
            'NetworkError when attempting to fetch resource.',
            'The Internet connection appears to be offline.',
            'Network request failed'
        ];
        class AbortError extends Error {
            constructor(message){
                super();
                if (message instanceof Error) {
                    this.originalError = message;
                    ({ message } = message);
                } else {
                    this.originalError = new Error(message);
                    this.originalError.stack = this.stack;
                }
                this.name = 'AbortError';
                this.message = message;
            }
        }
        const decorateErrorWithCounts = (error, attemptNumber, options)=>{
            const retriesLeft = options.retries - (attemptNumber - 1);
            error.attemptNumber = attemptNumber;
            error.retriesLeft = retriesLeft;
            return error;
        };
        const isNetworkError = (errorMessage)=>networkErrorMsgs.includes(errorMessage);
        const pRetry = (input, options)=>new Promise((resolve, reject)=>{
                options = {
                    onFailedAttempt: ()=>{},
                    retries: 10,
                    ...options
                };
                const operation = retry.operation(options);
                operation.attempt(async (attemptNumber)=>{
                    try {
                        resolve(await input(attemptNumber));
                    } catch (error) {
                        if (!(error instanceof Error)) {
                            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
                            return;
                        }
                        if (error instanceof AbortError) {
                            operation.stop();
                            reject(error.originalError);
                        } else if (error instanceof TypeError && !isNetworkError(error.message)) {
                            operation.stop();
                            reject(error);
                        } else {
                            decorateErrorWithCounts(error, attemptNumber, options);
                            try {
                                await options.onFailedAttempt(error);
                            } catch (error) {
                                reject(error);
                                return;
                            }
                            if (!operation.retry(error)) reject(operation.mainError());
                        }
                    }
                });
            });
        module.exports = pRetry;
        module.exports["default"] = pRetry;
        module.exports.AbortError = AbortError;
    },
    "../../../../node_modules/p-timeout/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const pFinally = __webpack_require__("../../../../node_modules/p-finally/index.js");
        class TimeoutError extends Error {
            constructor(message){
                super(message);
                this.name = 'TimeoutError';
            }
        }
        const pTimeout = (promise, milliseconds, fallback)=>new Promise((resolve, reject)=>{
                if ('number' != typeof milliseconds || milliseconds < 0) throw new TypeError('Expected `milliseconds` to be a positive number');
                if (milliseconds === 1 / 0) {
                    resolve(promise);
                    return;
                }
                const timer = setTimeout(()=>{
                    if ('function' == typeof fallback) {
                        try {
                            resolve(fallback());
                        } catch (error) {
                            reject(error);
                        }
                        return;
                    }
                    const message = 'string' == typeof fallback ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
                    const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
                    if ('function' == typeof promise.cancel) promise.cancel();
                    reject(timeoutError);
                }, milliseconds);
                pFinally(promise.then(resolve, reject), ()=>{
                    clearTimeout(timer);
                });
            });
        module.exports = pTimeout;
        module.exports["default"] = pTimeout;
        module.exports.TimeoutError = TimeoutError;
    },
    "../../../../node_modules/retry/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        module.exports = __webpack_require__("../../../../node_modules/retry/lib/retry.js");
    },
    "../../../../node_modules/retry/lib/retry.js": function(__unused_webpack_module, exports, __webpack_require__) {
        var RetryOperation = __webpack_require__("../../../../node_modules/retry/lib/retry_operation.js");
        exports.operation = function(options) {
            var timeouts = exports.timeouts(options);
            return new RetryOperation(timeouts, {
                forever: options && (options.forever || options.retries === 1 / 0),
                unref: options && options.unref,
                maxRetryTime: options && options.maxRetryTime
            });
        };
        exports.timeouts = function(options) {
            if (options instanceof Array) return [].concat(options);
            var opts = {
                retries: 10,
                factor: 2,
                minTimeout: 1000,
                maxTimeout: 1 / 0,
                randomize: false
            };
            for(var key in options)opts[key] = options[key];
            if (opts.minTimeout > opts.maxTimeout) throw new Error('minTimeout is greater than maxTimeout');
            var timeouts = [];
            for(var i = 0; i < opts.retries; i++)timeouts.push(this.createTimeout(i, opts));
            if (options && options.forever && !timeouts.length) timeouts.push(this.createTimeout(i, opts));
            timeouts.sort(function(a, b) {
                return a - b;
            });
            return timeouts;
        };
        exports.createTimeout = function(attempt, opts) {
            var random = opts.randomize ? Math.random() + 1 : 1;
            var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
            timeout = Math.min(timeout, opts.maxTimeout);
            return timeout;
        };
        exports.wrap = function(obj, options, methods) {
            if (options instanceof Array) {
                methods = options;
                options = null;
            }
            if (!methods) {
                methods = [];
                for(var key in obj)if ('function' == typeof obj[key]) methods.push(key);
            }
            for(var i = 0; i < methods.length; i++){
                var method = methods[i];
                var original = obj[method];
                obj[method] = (function(original) {
                    var op = exports.operation(options);
                    var args = Array.prototype.slice.call(arguments, 1);
                    var callback = args.pop();
                    args.push(function(err) {
                        if (op.retry(err)) return;
                        if (err) arguments[0] = op.mainError();
                        callback.apply(this, arguments);
                    });
                    op.attempt(function() {
                        original.apply(obj, args);
                    });
                }).bind(obj, original);
                obj[method].options = options;
            }
        };
    },
    "../../../../node_modules/retry/lib/retry_operation.js": function(module) {
        function RetryOperation(timeouts, options) {
            if ('boolean' == typeof options) options = {
                forever: options
            };
            this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
            this._timeouts = timeouts;
            this._options = options || {};
            this._maxRetryTime = options && options.maxRetryTime || 1 / 0;
            this._fn = null;
            this._errors = [];
            this._attempts = 1;
            this._operationTimeout = null;
            this._operationTimeoutCb = null;
            this._timeout = null;
            this._operationStart = null;
            this._timer = null;
            if (this._options.forever) this._cachedTimeouts = this._timeouts.slice(0);
        }
        module.exports = RetryOperation;
        RetryOperation.prototype.reset = function() {
            this._attempts = 1;
            this._timeouts = this._originalTimeouts.slice(0);
        };
        RetryOperation.prototype.stop = function() {
            if (this._timeout) clearTimeout(this._timeout);
            if (this._timer) clearTimeout(this._timer);
            this._timeouts = [];
            this._cachedTimeouts = null;
        };
        RetryOperation.prototype.retry = function(err) {
            if (this._timeout) clearTimeout(this._timeout);
            if (!err) return false;
            var currentTime = new Date().getTime();
            if (err && currentTime - this._operationStart >= this._maxRetryTime) {
                this._errors.push(err);
                this._errors.unshift(new Error('RetryOperation timeout occurred'));
                return false;
            }
            this._errors.push(err);
            var timeout = this._timeouts.shift();
            if (void 0 === timeout) {
                if (!this._cachedTimeouts) return false;
                this._errors.splice(0, this._errors.length - 1);
                timeout = this._cachedTimeouts.slice(-1);
            }
            var self1 = this;
            this._timer = setTimeout(function() {
                self1._attempts++;
                if (self1._operationTimeoutCb) {
                    self1._timeout = setTimeout(function() {
                        self1._operationTimeoutCb(self1._attempts);
                    }, self1._operationTimeout);
                    if (self1._options.unref) self1._timeout.unref();
                }
                self1._fn(self1._attempts);
            }, timeout);
            if (this._options.unref) this._timer.unref();
            return true;
        };
        RetryOperation.prototype.attempt = function(fn, timeoutOps) {
            this._fn = fn;
            if (timeoutOps) {
                if (timeoutOps.timeout) this._operationTimeout = timeoutOps.timeout;
                if (timeoutOps.cb) this._operationTimeoutCb = timeoutOps.cb;
            }
            var self1 = this;
            if (this._operationTimeoutCb) this._timeout = setTimeout(function() {
                self1._operationTimeoutCb();
            }, self1._operationTimeout);
            this._operationStart = new Date().getTime();
            this._fn(this._attempts);
        };
        RetryOperation.prototype.try = function(fn) {
            console.log('Using RetryOperation.try() is deprecated');
            this.attempt(fn);
        };
        RetryOperation.prototype.start = function(fn) {
            console.log('Using RetryOperation.start() is deprecated');
            this.attempt(fn);
        };
        RetryOperation.prototype.start = RetryOperation.prototype.try;
        RetryOperation.prototype.errors = function() {
            return this._errors;
        };
        RetryOperation.prototype.attempts = function() {
            return this._attempts;
        };
        RetryOperation.prototype.mainError = function() {
            if (0 === this._errors.length) return null;
            var counts = {};
            var mainError = null;
            var mainErrorCount = 0;
            for(var i = 0; i < this._errors.length; i++){
                var error = this._errors[i];
                var message = error.message;
                var count = (counts[message] || 0) + 1;
                counts[message] = count;
                if (count >= mainErrorCount) {
                    mainError = error;
                    mainErrorCount = count;
                }
            }
            return mainError;
        };
    },
    "../../../../node_modules/semver/classes/comparator.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const ANY = Symbol('SemVer ANY');
        class Comparator {
            static get ANY() {
                return ANY;
            }
            constructor(comp, options){
                options = parseOptions(options);
                if (comp instanceof Comparator) {
                    if (!!options.loose === comp.loose) return comp;
                    comp = comp.value;
                }
                comp = comp.trim().split(/\s+/).join(' ');
                debug('comparator', comp, options);
                this.options = options;
                this.loose = !!options.loose;
                this.parse(comp);
                if (this.semver === ANY) this.value = '';
                else this.value = this.operator + this.semver.version;
                debug('comp', this);
            }
            parse(comp) {
                const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
                const m = comp.match(r);
                if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
                this.operator = void 0 !== m[1] ? m[1] : '';
                if ('=' === this.operator) this.operator = '';
                if (m[2]) this.semver = new SemVer(m[2], this.options.loose);
                else this.semver = ANY;
            }
            toString() {
                return this.value;
            }
            test(version) {
                debug('Comparator.test', version, this.options.loose);
                if (this.semver === ANY || version === ANY) return true;
                if ('string' == typeof version) try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
                return cmp(version, this.operator, this.semver, this.options);
            }
            intersects(comp, options) {
                if (!(comp instanceof Comparator)) throw new TypeError('a Comparator is required');
                if ('' === this.operator) {
                    if ('' === this.value) return true;
                    return new Range(comp.value, options).test(this.value);
                }
                if ('' === comp.operator) {
                    if ('' === comp.value) return true;
                    return new Range(this.value, options).test(comp.semver);
                }
                options = parseOptions(options);
                if (options.includePrerelease && ('<0.0.0-0' === this.value || '<0.0.0-0' === comp.value)) return false;
                if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) return false;
                if (this.operator.startsWith('>') && comp.operator.startsWith('>')) return true;
                if (this.operator.startsWith('<') && comp.operator.startsWith('<')) return true;
                if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) return true;
                if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) return true;
                if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) return true;
                return false;
            }
        }
        module.exports = Comparator;
        const parseOptions = __webpack_require__("../../../../node_modules/semver/internal/parse-options.js");
        const { safeRe: re, t } = __webpack_require__("../../../../node_modules/semver/internal/re.js");
        const cmp = __webpack_require__("../../../../node_modules/semver/functions/cmp.js");
        const debug = __webpack_require__("../../../../node_modules/semver/internal/debug.js");
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
    },
    "../../../../node_modules/semver/classes/range.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SPACE_CHARACTERS = /\s+/g;
        class Range {
            constructor(range, options){
                options = parseOptions(options);
                if (range instanceof Range) {
                    if (!!options.loose === range.loose && !!options.includePrerelease === range.includePrerelease) return range;
                    return new Range(range.raw, options);
                }
                if (range instanceof Comparator) {
                    this.raw = range.value;
                    this.set = [
                        [
                            range
                        ]
                    ];
                    this.formatted = void 0;
                    return this;
                }
                this.options = options;
                this.loose = !!options.loose;
                this.includePrerelease = !!options.includePrerelease;
                this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
                this.set = this.raw.split('||').map((r)=>this.parseRange(r.trim())).filter((c)=>c.length);
                if (!this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
                if (this.set.length > 1) {
                    const first = this.set[0];
                    this.set = this.set.filter((c)=>!isNullSet(c[0]));
                    if (0 === this.set.length) this.set = [
                        first
                    ];
                    else if (this.set.length > 1) {
                        for (const c of this.set)if (1 === c.length && isAny(c[0])) {
                            this.set = [
                                c
                            ];
                            break;
                        }
                    }
                }
                this.formatted = void 0;
            }
            get range() {
                if (void 0 === this.formatted) {
                    this.formatted = '';
                    for(let i = 0; i < this.set.length; i++){
                        if (i > 0) this.formatted += '||';
                        const comps = this.set[i];
                        for(let k = 0; k < comps.length; k++){
                            if (k > 0) this.formatted += ' ';
                            this.formatted += comps[k].toString().trim();
                        }
                    }
                }
                return this.formatted;
            }
            format() {
                return this.range;
            }
            toString() {
                return this.range;
            }
            parseRange(range) {
                const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
                const memoKey = memoOpts + ':' + range;
                const cached = cache1.get(memoKey);
                if (cached) return cached;
                const loose = this.options.loose;
                const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
                range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
                debug('hyphen replace', range);
                range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
                debug('comparator trim', range);
                range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
                debug('tilde trim', range);
                range = range.replace(re[t.CARETTRIM], caretTrimReplace);
                debug('caret trim', range);
                let rangeList = range.split(' ').map((comp)=>parseComparator(comp, this.options)).join(' ').split(/\s+/).map((comp)=>replaceGTE0(comp, this.options));
                if (loose) rangeList = rangeList.filter((comp)=>{
                    debug('loose invalid filter', comp, this.options);
                    return !!comp.match(re[t.COMPARATORLOOSE]);
                });
                debug('range list', rangeList);
                const rangeMap = new Map();
                const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
                for (const comp of comparators){
                    if (isNullSet(comp)) return [
                        comp
                    ];
                    rangeMap.set(comp.value, comp);
                }
                if (rangeMap.size > 1 && rangeMap.has('')) rangeMap.delete('');
                const result = [
                    ...rangeMap.values()
                ];
                cache1.set(memoKey, result);
                return result;
            }
            intersects(range, options) {
                if (!(range instanceof Range)) throw new TypeError('a Range is required');
                return this.set.some((thisComparators)=>isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>rangeComparators.every((rangeComparator)=>thisComparator.intersects(rangeComparator, options)))));
            }
            test(version) {
                if (!version) return false;
                if ('string' == typeof version) try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
                for(let i = 0; i < this.set.length; i++)if (testSet(this.set[i], version, this.options)) return true;
                return false;
            }
        }
        module.exports = Range;
        const LRU = __webpack_require__("../../../../node_modules/semver/internal/lrucache.js");
        const cache1 = new LRU();
        const parseOptions = __webpack_require__("../../../../node_modules/semver/internal/parse-options.js");
        const Comparator = __webpack_require__("../../../../node_modules/semver/classes/comparator.js");
        const debug = __webpack_require__("../../../../node_modules/semver/internal/debug.js");
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __webpack_require__("../../../../node_modules/semver/internal/re.js");
        const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__("../../../../node_modules/semver/internal/constants.js");
        const isNullSet = (c)=>'<0.0.0-0' === c.value;
        const isAny = (c)=>'' === c.value;
        const isSatisfiable = (comparators, options)=>{
            let result = true;
            const remainingComparators = comparators.slice();
            let testComparator = remainingComparators.pop();
            while(result && remainingComparators.length){
                result = remainingComparators.every((otherComparator)=>testComparator.intersects(otherComparator, options));
                testComparator = remainingComparators.pop();
            }
            return result;
        };
        const parseComparator = (comp, options)=>{
            debug('comp', comp, options);
            comp = replaceCarets(comp, options);
            debug('caret', comp);
            comp = replaceTildes(comp, options);
            debug('tildes', comp);
            comp = replaceXRanges(comp, options);
            debug('xrange', comp);
            comp = replaceStars(comp, options);
            debug('stars', comp);
            return comp;
        };
        const isX = (id)=>!id || 'x' === id.toLowerCase() || '*' === id;
        const replaceTildes = (comp, options)=>comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(' ');
        const replaceTilde = (comp, options)=>{
            const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
            return comp.replace(r, (_, M, m, p, pr)=>{
                debug('tilde', comp, _, M, m, p, pr);
                let ret;
                if (isX(M)) ret = '';
                else if (isX(m)) ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
                else if (isX(p)) ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
                else if (pr) {
                    debug('replaceTilde pr', pr);
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
                } else ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
                debug('tilde return', ret);
                return ret;
            });
        };
        const replaceCarets = (comp, options)=>comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(' ');
        const replaceCaret = (comp, options)=>{
            debug('caret', comp, options);
            const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
            const z = options.includePrerelease ? '-0' : '';
            return comp.replace(r, (_, M, m, p, pr)=>{
                debug('caret', comp, _, M, m, p, pr);
                let ret;
                if (isX(M)) ret = '';
                else if (isX(m)) ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
                else if (isX(p)) ret = '0' === M ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
                else if (pr) {
                    debug('replaceCaret pr', pr);
                    ret = '0' === M ? '0' === m ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
                } else {
                    debug('no pr');
                    ret = '0' === M ? '0' === m ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
                }
                debug('caret return', ret);
                return ret;
            });
        };
        const replaceXRanges = (comp, options)=>{
            debug('replaceXRanges', comp, options);
            return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(' ');
        };
        const replaceXRange = (comp, options)=>{
            comp = comp.trim();
            const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
            return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
                debug('xRange', comp, ret, gtlt, M, m, p, pr);
                const xM = isX(M);
                const xm = xM || isX(m);
                const xp = xm || isX(p);
                const anyX = xp;
                if ('=' === gtlt && anyX) gtlt = '';
                pr = options.includePrerelease ? '-0' : '';
                if (xM) ret = '>' === gtlt || '<' === gtlt ? '<0.0.0-0' : '*';
                else if (gtlt && anyX) {
                    if (xm) m = 0;
                    p = 0;
                    if ('>' === gtlt) {
                        gtlt = '>=';
                        if (xm) {
                            M = +M + 1;
                            m = 0;
                            p = 0;
                        } else {
                            m = +m + 1;
                            p = 0;
                        }
                    } else if ('<=' === gtlt) {
                        gtlt = '<';
                        if (xm) M = +M + 1;
                        else m = +m + 1;
                    }
                    if ('<' === gtlt) pr = '-0';
                    ret = `${gtlt + M}.${m}.${p}${pr}`;
                } else if (xm) ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
                else if (xp) ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
                debug('xRange return', ret);
                return ret;
            });
        };
        const replaceStars = (comp, options)=>{
            debug('replaceStars', comp, options);
            return comp.trim().replace(re[t.STAR], '');
        };
        const replaceGTE0 = (comp, options)=>{
            debug('replaceGTE0', comp, options);
            return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
        };
        const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr)=>{
                from = isX(fM) ? '' : isX(fm) ? `>=${fM}.0.0${incPr ? '-0' : ''}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? '-0' : ''}` : fpr ? `>=${from}` : `>=${from}${incPr ? '-0' : ''}`;
                to = isX(tM) ? '' : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`;
                return `${from} ${to}`.trim();
            };
        const testSet = (set, version, options)=>{
            for(let i = 0; i < set.length; i++)if (!set[i].test(version)) return false;
            if (version.prerelease.length && !options.includePrerelease) {
                for(let i = 0; i < set.length; i++){
                    debug(set[i].semver);
                    if (set[i].semver !== Comparator.ANY) {
                        if (set[i].semver.prerelease.length > 0) {
                            const allowed = set[i].semver;
                            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
                        }
                    }
                }
                return false;
            }
            return true;
        };
    },
    "../../../../node_modules/semver/classes/semver.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const debug = __webpack_require__("../../../../node_modules/semver/internal/debug.js");
        const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__("../../../../node_modules/semver/internal/constants.js");
        const { safeRe: re, t } = __webpack_require__("../../../../node_modules/semver/internal/re.js");
        const parseOptions = __webpack_require__("../../../../node_modules/semver/internal/parse-options.js");
        const { compareIdentifiers } = __webpack_require__("../../../../node_modules/semver/internal/identifiers.js");
        class SemVer {
            constructor(version, options){
                options = parseOptions(options);
                if (version instanceof SemVer) {
                    if (!!options.loose === version.loose && !!options.includePrerelease === version.includePrerelease) return version;
                    version = version.version;
                } else if ('string' != typeof version) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
                if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
                debug('SemVer', version, options);
                this.options = options;
                this.loose = !!options.loose;
                this.includePrerelease = !!options.includePrerelease;
                const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
                if (!m) throw new TypeError(`Invalid Version: ${version}`);
                this.raw = version;
                this.major = +m[1];
                this.minor = +m[2];
                this.patch = +m[3];
                if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');
                if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');
                if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');
                if (m[4]) this.prerelease = m[4].split('.').map((id)=>{
                    if (/^[0-9]+$/.test(id)) {
                        const num = +id;
                        if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
                    }
                    return id;
                });
                else this.prerelease = [];
                this.build = m[5] ? m[5].split('.') : [];
                this.format();
            }
            format() {
                this.version = `${this.major}.${this.minor}.${this.patch}`;
                if (this.prerelease.length) this.version += `-${this.prerelease.join('.')}`;
                return this.version;
            }
            toString() {
                return this.version;
            }
            compare(other) {
                debug('SemVer.compare', this.version, this.options, other);
                if (!(other instanceof SemVer)) {
                    if ('string' == typeof other && other === this.version) return 0;
                    other = new SemVer(other, this.options);
                }
                if (other.version === this.version) return 0;
                return this.compareMain(other) || this.comparePre(other);
            }
            compareMain(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
            }
            comparePre(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                if (this.prerelease.length && !other.prerelease.length) return -1;
                if (!this.prerelease.length && other.prerelease.length) return 1;
                if (!this.prerelease.length && !other.prerelease.length) return 0;
                let i = 0;
                do {
                    const a = this.prerelease[i];
                    const b = other.prerelease[i];
                    debug('prerelease compare', i, a, b);
                    if (void 0 === a && void 0 === b) return 0;
                    if (void 0 === b) return 1;
                    if (void 0 === a) return -1;
                    else if (a === b) continue;
                    else return compareIdentifiers(a, b);
                }while (++i);
            }
            compareBuild(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                let i = 0;
                do {
                    const a = this.build[i];
                    const b = other.build[i];
                    debug('build compare', i, a, b);
                    if (void 0 === a && void 0 === b) return 0;
                    if (void 0 === b) return 1;
                    if (void 0 === a) return -1;
                    else if (a === b) continue;
                    else return compareIdentifiers(a, b);
                }while (++i);
            }
            inc(release, identifier, identifierBase) {
                if (release.startsWith('pre')) {
                    if (!identifier && false === identifierBase) throw new Error('invalid increment argument: identifier is empty');
                    if (identifier) {
                        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                        if (!match || match[1] !== identifier) throw new Error(`invalid identifier: ${identifier}`);
                    }
                }
                switch(release){
                    case 'premajor':
                        this.prerelease.length = 0;
                        this.patch = 0;
                        this.minor = 0;
                        this.major++;
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'preminor':
                        this.prerelease.length = 0;
                        this.patch = 0;
                        this.minor++;
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'prepatch':
                        this.prerelease.length = 0;
                        this.inc('patch', identifier, identifierBase);
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'prerelease':
                        if (0 === this.prerelease.length) this.inc('patch', identifier, identifierBase);
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'release':
                        if (0 === this.prerelease.length) throw new Error(`version ${this.raw} is not a prerelease`);
                        this.prerelease.length = 0;
                        break;
                    case 'major':
                        if (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) this.major++;
                        this.minor = 0;
                        this.patch = 0;
                        this.prerelease = [];
                        break;
                    case 'minor':
                        if (0 !== this.patch || 0 === this.prerelease.length) this.minor++;
                        this.patch = 0;
                        this.prerelease = [];
                        break;
                    case 'patch':
                        if (0 === this.prerelease.length) this.patch++;
                        this.prerelease = [];
                        break;
                    case 'pre':
                        {
                            const base = Number(identifierBase) ? 1 : 0;
                            if (0 === this.prerelease.length) this.prerelease = [
                                base
                            ];
                            else {
                                let i = this.prerelease.length;
                                while(--i >= 0)if ('number' == typeof this.prerelease[i]) {
                                    this.prerelease[i]++;
                                    i = -2;
                                }
                                if (-1 === i) {
                                    if (identifier === this.prerelease.join('.') && false === identifierBase) throw new Error('invalid increment argument: identifier already exists');
                                    this.prerelease.push(base);
                                }
                            }
                            if (identifier) {
                                let prerelease = [
                                    identifier,
                                    base
                                ];
                                if (false === identifierBase) prerelease = [
                                    identifier
                                ];
                                if (0 === compareIdentifiers(this.prerelease[0], identifier)) {
                                    if (isNaN(this.prerelease[1])) this.prerelease = prerelease;
                                } else this.prerelease = prerelease;
                            }
                            break;
                        }
                    default:
                        throw new Error(`invalid increment argument: ${release}`);
                }
                this.raw = this.format();
                if (this.build.length) this.raw += `+${this.build.join('.')}`;
                return this;
            }
        }
        module.exports = SemVer;
    },
    "../../../../node_modules/semver/functions/clean.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const parse = __webpack_require__("../../../../node_modules/semver/functions/parse.js");
        const clean = (version, options)=>{
            const s = parse(version.trim().replace(/^[=v]+/, ''), options);
            return s ? s.version : null;
        };
        module.exports = clean;
    },
    "../../../../node_modules/semver/functions/cmp.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const eq = __webpack_require__("../../../../node_modules/semver/functions/eq.js");
        const neq = __webpack_require__("../../../../node_modules/semver/functions/neq.js");
        const gt = __webpack_require__("../../../../node_modules/semver/functions/gt.js");
        const gte = __webpack_require__("../../../../node_modules/semver/functions/gte.js");
        const lt = __webpack_require__("../../../../node_modules/semver/functions/lt.js");
        const lte = __webpack_require__("../../../../node_modules/semver/functions/lte.js");
        const cmp = (a, op, b, loose)=>{
            switch(op){
                case '===':
                    if ('object' == typeof a) a = a.version;
                    if ('object' == typeof b) b = b.version;
                    return a === b;
                case '!==':
                    if ('object' == typeof a) a = a.version;
                    if ('object' == typeof b) b = b.version;
                    return a !== b;
                case '':
                case '=':
                case '==':
                    return eq(a, b, loose);
                case '!=':
                    return neq(a, b, loose);
                case '>':
                    return gt(a, b, loose);
                case '>=':
                    return gte(a, b, loose);
                case '<':
                    return lt(a, b, loose);
                case '<=':
                    return lte(a, b, loose);
                default:
                    throw new TypeError(`Invalid operator: ${op}`);
            }
        };
        module.exports = cmp;
    },
    "../../../../node_modules/semver/functions/coerce.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const parse = __webpack_require__("../../../../node_modules/semver/functions/parse.js");
        const { safeRe: re, t } = __webpack_require__("../../../../node_modules/semver/internal/re.js");
        const coerce = (version, options)=>{
            if (version instanceof SemVer) return version;
            if ('number' == typeof version) version = String(version);
            if ('string' != typeof version) return null;
            options = options || {};
            let match = null;
            if (options.rtl) {
                const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
                let next;
                while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
                    if (!match || next.index + next[0].length !== match.index + match[0].length) match = next;
                    coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
                }
                coerceRtlRegex.lastIndex = -1;
            } else match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
            if (null === match) return null;
            const major = match[2];
            const minor = match[3] || '0';
            const patch = match[4] || '0';
            const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
            const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
            return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
        };
        module.exports = coerce;
    },
    "../../../../node_modules/semver/functions/compare-build.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const compareBuild = (a, b, loose)=>{
            const versionA = new SemVer(a, loose);
            const versionB = new SemVer(b, loose);
            return versionA.compare(versionB) || versionA.compareBuild(versionB);
        };
        module.exports = compareBuild;
    },
    "../../../../node_modules/semver/functions/compare-loose.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const compareLoose = (a, b)=>compare(a, b, true);
        module.exports = compareLoose;
    },
    "../../../../node_modules/semver/functions/compare.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
        module.exports = compare;
    },
    "../../../../node_modules/semver/functions/diff.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const parse = __webpack_require__("../../../../node_modules/semver/functions/parse.js");
        const diff = (version1, version2)=>{
            const v1 = parse(version1, null, true);
            const v2 = parse(version2, null, true);
            const comparison = v1.compare(v2);
            if (0 === comparison) return null;
            const v1Higher = comparison > 0;
            const highVersion = v1Higher ? v1 : v2;
            const lowVersion = v1Higher ? v2 : v1;
            const highHasPre = !!highVersion.prerelease.length;
            const lowHasPre = !!lowVersion.prerelease.length;
            if (lowHasPre && !highHasPre) {
                if (!lowVersion.patch && !lowVersion.minor) return 'major';
                if (0 === lowVersion.compareMain(highVersion)) {
                    if (lowVersion.minor && !lowVersion.patch) return 'minor';
                    return 'patch';
                }
            }
            const prefix = highHasPre ? 'pre' : '';
            if (v1.major !== v2.major) return prefix + 'major';
            if (v1.minor !== v2.minor) return prefix + 'minor';
            if (v1.patch !== v2.patch) return prefix + 'patch';
            return 'prerelease';
        };
        module.exports = diff;
    },
    "../../../../node_modules/semver/functions/eq.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const eq = (a, b, loose)=>0 === compare(a, b, loose);
        module.exports = eq;
    },
    "../../../../node_modules/semver/functions/gt.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const gt = (a, b, loose)=>compare(a, b, loose) > 0;
        module.exports = gt;
    },
    "../../../../node_modules/semver/functions/gte.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
        module.exports = gte;
    },
    "../../../../node_modules/semver/functions/inc.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const inc = (version, release, options, identifier, identifierBase)=>{
            if ('string' == typeof options) {
                identifierBase = identifier;
                identifier = options;
                options = void 0;
            }
            try {
                return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
            } catch (er) {
                return null;
            }
        };
        module.exports = inc;
    },
    "../../../../node_modules/semver/functions/lt.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const lt = (a, b, loose)=>compare(a, b, loose) < 0;
        module.exports = lt;
    },
    "../../../../node_modules/semver/functions/lte.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
        module.exports = lte;
    },
    "../../../../node_modules/semver/functions/major.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const major = (a, loose)=>new SemVer(a, loose).major;
        module.exports = major;
    },
    "../../../../node_modules/semver/functions/minor.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const minor = (a, loose)=>new SemVer(a, loose).minor;
        module.exports = minor;
    },
    "../../../../node_modules/semver/functions/neq.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const neq = (a, b, loose)=>0 !== compare(a, b, loose);
        module.exports = neq;
    },
    "../../../../node_modules/semver/functions/parse.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const parse = (version, options, throwErrors = false)=>{
            if (version instanceof SemVer) return version;
            try {
                return new SemVer(version, options);
            } catch (er) {
                if (!throwErrors) return null;
                throw er;
            }
        };
        module.exports = parse;
    },
    "../../../../node_modules/semver/functions/patch.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const patch = (a, loose)=>new SemVer(a, loose).patch;
        module.exports = patch;
    },
    "../../../../node_modules/semver/functions/prerelease.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const parse = __webpack_require__("../../../../node_modules/semver/functions/parse.js");
        const prerelease = (version, options)=>{
            const parsed = parse(version, options);
            return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        };
        module.exports = prerelease;
    },
    "../../../../node_modules/semver/functions/rcompare.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const rcompare = (a, b, loose)=>compare(b, a, loose);
        module.exports = rcompare;
    },
    "../../../../node_modules/semver/functions/rsort.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compareBuild = __webpack_require__("../../../../node_modules/semver/functions/compare-build.js");
        const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
        module.exports = rsort;
    },
    "../../../../node_modules/semver/functions/satisfies.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const satisfies = (version, range, options)=>{
            try {
                range = new Range(range, options);
            } catch (er) {
                return false;
            }
            return range.test(version);
        };
        module.exports = satisfies;
    },
    "../../../../node_modules/semver/functions/sort.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compareBuild = __webpack_require__("../../../../node_modules/semver/functions/compare-build.js");
        const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
        module.exports = sort;
    },
    "../../../../node_modules/semver/functions/valid.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const parse = __webpack_require__("../../../../node_modules/semver/functions/parse.js");
        const valid = (version, options)=>{
            const v = parse(version, options);
            return v ? v.version : null;
        };
        module.exports = valid;
    },
    "../../../../node_modules/semver/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const internalRe = __webpack_require__("../../../../node_modules/semver/internal/re.js");
        const constants = __webpack_require__("../../../../node_modules/semver/internal/constants.js");
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const identifiers = __webpack_require__("../../../../node_modules/semver/internal/identifiers.js");
        const parse = __webpack_require__("../../../../node_modules/semver/functions/parse.js");
        const valid = __webpack_require__("../../../../node_modules/semver/functions/valid.js");
        const clean = __webpack_require__("../../../../node_modules/semver/functions/clean.js");
        const inc = __webpack_require__("../../../../node_modules/semver/functions/inc.js");
        const diff = __webpack_require__("../../../../node_modules/semver/functions/diff.js");
        const major = __webpack_require__("../../../../node_modules/semver/functions/major.js");
        const minor = __webpack_require__("../../../../node_modules/semver/functions/minor.js");
        const patch = __webpack_require__("../../../../node_modules/semver/functions/patch.js");
        const prerelease = __webpack_require__("../../../../node_modules/semver/functions/prerelease.js");
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const rcompare = __webpack_require__("../../../../node_modules/semver/functions/rcompare.js");
        const compareLoose = __webpack_require__("../../../../node_modules/semver/functions/compare-loose.js");
        const compareBuild = __webpack_require__("../../../../node_modules/semver/functions/compare-build.js");
        const sort = __webpack_require__("../../../../node_modules/semver/functions/sort.js");
        const rsort = __webpack_require__("../../../../node_modules/semver/functions/rsort.js");
        const gt = __webpack_require__("../../../../node_modules/semver/functions/gt.js");
        const lt = __webpack_require__("../../../../node_modules/semver/functions/lt.js");
        const eq = __webpack_require__("../../../../node_modules/semver/functions/eq.js");
        const neq = __webpack_require__("../../../../node_modules/semver/functions/neq.js");
        const gte = __webpack_require__("../../../../node_modules/semver/functions/gte.js");
        const lte = __webpack_require__("../../../../node_modules/semver/functions/lte.js");
        const cmp = __webpack_require__("../../../../node_modules/semver/functions/cmp.js");
        const coerce = __webpack_require__("../../../../node_modules/semver/functions/coerce.js");
        const Comparator = __webpack_require__("../../../../node_modules/semver/classes/comparator.js");
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const satisfies = __webpack_require__("../../../../node_modules/semver/functions/satisfies.js");
        const toComparators = __webpack_require__("../../../../node_modules/semver/ranges/to-comparators.js");
        const maxSatisfying = __webpack_require__("../../../../node_modules/semver/ranges/max-satisfying.js");
        const minSatisfying = __webpack_require__("../../../../node_modules/semver/ranges/min-satisfying.js");
        const minVersion = __webpack_require__("../../../../node_modules/semver/ranges/min-version.js");
        const validRange = __webpack_require__("../../../../node_modules/semver/ranges/valid.js");
        const outside = __webpack_require__("../../../../node_modules/semver/ranges/outside.js");
        const gtr = __webpack_require__("../../../../node_modules/semver/ranges/gtr.js");
        const ltr = __webpack_require__("../../../../node_modules/semver/ranges/ltr.js");
        const intersects = __webpack_require__("../../../../node_modules/semver/ranges/intersects.js");
        const simplifyRange = __webpack_require__("../../../../node_modules/semver/ranges/simplify.js");
        const subset = __webpack_require__("../../../../node_modules/semver/ranges/subset.js");
        module.exports = {
            parse,
            valid,
            clean,
            inc,
            diff,
            major,
            minor,
            patch,
            prerelease,
            compare,
            rcompare,
            compareLoose,
            compareBuild,
            sort,
            rsort,
            gt,
            lt,
            eq,
            neq,
            gte,
            lte,
            cmp,
            coerce,
            Comparator,
            Range,
            satisfies,
            toComparators,
            maxSatisfying,
            minSatisfying,
            minVersion,
            validRange,
            outside,
            gtr,
            ltr,
            intersects,
            simplifyRange,
            subset,
            SemVer,
            re: internalRe.re,
            src: internalRe.src,
            tokens: internalRe.t,
            SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
            RELEASE_TYPES: constants.RELEASE_TYPES,
            compareIdentifiers: identifiers.compareIdentifiers,
            rcompareIdentifiers: identifiers.rcompareIdentifiers
        };
    },
    "../../../../node_modules/semver/internal/constants.js": function(module) {
        const SEMVER_SPEC_VERSION = '2.0.0';
        const MAX_LENGTH = 256;
        const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        const MAX_SAFE_COMPONENT_LENGTH = 16;
        const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
        const RELEASE_TYPES = [
            'major',
            'premajor',
            'minor',
            'preminor',
            'patch',
            'prepatch',
            'prerelease'
        ];
        module.exports = {
            MAX_LENGTH,
            MAX_SAFE_COMPONENT_LENGTH,
            MAX_SAFE_BUILD_LENGTH,
            MAX_SAFE_INTEGER,
            RELEASE_TYPES,
            SEMVER_SPEC_VERSION,
            FLAG_INCLUDE_PRERELEASE: 1,
            FLAG_LOOSE: 2
        };
    },
    "../../../../node_modules/semver/internal/debug.js": function(module) {
        const debug = 'object' == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args)=>console.error('SEMVER', ...args) : ()=>{};
        module.exports = debug;
    },
    "../../../../node_modules/semver/internal/identifiers.js": function(module) {
        const numeric = /^[0-9]+$/;
        const compareIdentifiers = (a, b)=>{
            const anum = numeric.test(a);
            const bnum = numeric.test(b);
            if (anum && bnum) {
                a *= 1;
                b *= 1;
            }
            return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        };
        const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
        module.exports = {
            compareIdentifiers,
            rcompareIdentifiers
        };
    },
    "../../../../node_modules/semver/internal/lrucache.js": function(module) {
        class LRUCache {
            constructor(){
                this.max = 1000;
                this.map = new Map();
            }
            get(key) {
                const value = this.map.get(key);
                if (void 0 === value) return;
                this.map.delete(key);
                this.map.set(key, value);
                return value;
            }
            delete(key) {
                return this.map.delete(key);
            }
            set(key, value) {
                const deleted = this.delete(key);
                if (!deleted && void 0 !== value) {
                    if (this.map.size >= this.max) {
                        const firstKey = this.map.keys().next().value;
                        this.delete(firstKey);
                    }
                    this.map.set(key, value);
                }
                return this;
            }
        }
        module.exports = LRUCache;
    },
    "../../../../node_modules/semver/internal/parse-options.js": function(module) {
        const looseOption = Object.freeze({
            loose: true
        });
        const emptyOpts = Object.freeze({});
        const parseOptions = (options)=>{
            if (!options) return emptyOpts;
            if ('object' != typeof options) return looseOption;
            return options;
        };
        module.exports = parseOptions;
    },
    "../../../../node_modules/semver/internal/re.js": function(module, exports, __webpack_require__) {
        const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __webpack_require__("../../../../node_modules/semver/internal/constants.js");
        const debug = __webpack_require__("../../../../node_modules/semver/internal/debug.js");
        exports = module.exports = {};
        const re = exports.re = [];
        const safeRe = exports.safeRe = [];
        const src = exports.src = [];
        const safeSrc = exports.safeSrc = [];
        const t = exports.t = {};
        let R = 0;
        const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
        const safeRegexReplacements = [
            [
                '\\s',
                1
            ],
            [
                '\\d',
                MAX_LENGTH
            ],
            [
                LETTERDASHNUMBER,
                MAX_SAFE_BUILD_LENGTH
            ]
        ];
        const makeSafeRegex = (value)=>{
            for (const [token, max] of safeRegexReplacements)value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
            return value;
        };
        const createToken = (name, value, isGlobal)=>{
            const safe = makeSafeRegex(value);
            const index = R++;
            debug(name, index, value);
            t[name] = index;
            src[index] = value;
            safeSrc[index] = safe;
            re[index] = new RegExp(value, isGlobal ? 'g' : void 0);
            safeRe[index] = new RegExp(safe, isGlobal ? 'g' : void 0);
        };
        createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
        createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
        createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
        createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
        createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
        createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
        createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
        createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
        createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
        createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
        createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
        createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
        createToken('FULL', `^${src[t.FULLPLAIN]}$`);
        createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
        createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
        createToken('GTLT', '((?:<|>)?=?)');
        createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
        createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
        createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
        createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
        createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
        createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('COERCEPLAIN', `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
        createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
        createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + "(?:$|[^\\d])");
        createToken('COERCERTL', src[t.COERCE], true);
        createToken('COERCERTLFULL', src[t.COERCEFULL], true);
        createToken('LONETILDE', '(?:~>?)');
        createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
        exports.tildeTrimReplace = '$1~';
        createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
        createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('LONECARET', '(?:\\^)');
        createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
        exports.caretTrimReplace = '$1^';
        createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
        createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
        createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
        createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
        exports.comparatorTrimReplace = '$1$2$3';
        createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*\$`);
        createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*\$`);
        createToken('STAR', '(<|>)?=?\\s*\\*');
        createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
        createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
    },
    "../../../../node_modules/semver/ranges/gtr.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const outside = __webpack_require__("../../../../node_modules/semver/ranges/outside.js");
        const gtr = (version, range, options)=>outside(version, range, '>', options);
        module.exports = gtr;
    },
    "../../../../node_modules/semver/ranges/intersects.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const intersects = (r1, r2, options)=>{
            r1 = new Range(r1, options);
            r2 = new Range(r2, options);
            return r1.intersects(r2, options);
        };
        module.exports = intersects;
    },
    "../../../../node_modules/semver/ranges/ltr.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const outside = __webpack_require__("../../../../node_modules/semver/ranges/outside.js");
        const ltr = (version, range, options)=>outside(version, range, '<', options);
        module.exports = ltr;
    },
    "../../../../node_modules/semver/ranges/max-satisfying.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const maxSatisfying = (versions, range, options)=>{
            let max = null;
            let maxSV = null;
            let rangeObj = null;
            try {
                rangeObj = new Range(range, options);
            } catch (er) {
                return null;
            }
            versions.forEach((v)=>{
                if (rangeObj.test(v)) {
                    if (!max || -1 === maxSV.compare(v)) {
                        max = v;
                        maxSV = new SemVer(max, options);
                    }
                }
            });
            return max;
        };
        module.exports = maxSatisfying;
    },
    "../../../../node_modules/semver/ranges/min-satisfying.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const minSatisfying = (versions, range, options)=>{
            let min = null;
            let minSV = null;
            let rangeObj = null;
            try {
                rangeObj = new Range(range, options);
            } catch (er) {
                return null;
            }
            versions.forEach((v)=>{
                if (rangeObj.test(v)) {
                    if (!min || 1 === minSV.compare(v)) {
                        min = v;
                        minSV = new SemVer(min, options);
                    }
                }
            });
            return min;
        };
        module.exports = minSatisfying;
    },
    "../../../../node_modules/semver/ranges/min-version.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const gt = __webpack_require__("../../../../node_modules/semver/functions/gt.js");
        const minVersion = (range, loose)=>{
            range = new Range(range, loose);
            let minver = new SemVer('0.0.0');
            if (range.test(minver)) return minver;
            minver = new SemVer('0.0.0-0');
            if (range.test(minver)) return minver;
            minver = null;
            for(let i = 0; i < range.set.length; ++i){
                const comparators = range.set[i];
                let setMin = null;
                comparators.forEach((comparator)=>{
                    const compver = new SemVer(comparator.semver.version);
                    switch(comparator.operator){
                        case '>':
                            if (0 === compver.prerelease.length) compver.patch++;
                            else compver.prerelease.push(0);
                            compver.raw = compver.format();
                        case '':
                        case '>=':
                            if (!setMin || gt(compver, setMin)) setMin = compver;
                            break;
                        case '<':
                        case '<=':
                            break;
                        default:
                            throw new Error(`Unexpected operation: ${comparator.operator}`);
                    }
                });
                if (setMin && (!minver || gt(minver, setMin))) minver = setMin;
            }
            if (minver && range.test(minver)) return minver;
            return null;
        };
        module.exports = minVersion;
    },
    "../../../../node_modules/semver/ranges/outside.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../../node_modules/semver/classes/semver.js");
        const Comparator = __webpack_require__("../../../../node_modules/semver/classes/comparator.js");
        const { ANY } = Comparator;
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const satisfies = __webpack_require__("../../../../node_modules/semver/functions/satisfies.js");
        const gt = __webpack_require__("../../../../node_modules/semver/functions/gt.js");
        const lt = __webpack_require__("../../../../node_modules/semver/functions/lt.js");
        const lte = __webpack_require__("../../../../node_modules/semver/functions/lte.js");
        const gte = __webpack_require__("../../../../node_modules/semver/functions/gte.js");
        const outside = (version, range, hilo, options)=>{
            version = new SemVer(version, options);
            range = new Range(range, options);
            let gtfn, ltefn, ltfn, comp, ecomp;
            switch(hilo){
                case '>':
                    gtfn = gt;
                    ltefn = lte;
                    ltfn = lt;
                    comp = '>';
                    ecomp = '>=';
                    break;
                case '<':
                    gtfn = lt;
                    ltefn = gte;
                    ltfn = gt;
                    comp = '<';
                    ecomp = '<=';
                    break;
                default:
                    throw new TypeError('Must provide a hilo val of "<" or ">"');
            }
            if (satisfies(version, range, options)) return false;
            for(let i = 0; i < range.set.length; ++i){
                const comparators = range.set[i];
                let high = null;
                let low = null;
                comparators.forEach((comparator)=>{
                    if (comparator.semver === ANY) comparator = new Comparator('>=0.0.0');
                    high = high || comparator;
                    low = low || comparator;
                    if (gtfn(comparator.semver, high.semver, options)) high = comparator;
                    else if (ltfn(comparator.semver, low.semver, options)) low = comparator;
                });
                if (high.operator === comp || high.operator === ecomp) return false;
                if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return false;
                if (low.operator === ecomp && ltfn(version, low.semver)) return false;
            }
            return true;
        };
        module.exports = outside;
    },
    "../../../../node_modules/semver/ranges/simplify.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const satisfies = __webpack_require__("../../../../node_modules/semver/functions/satisfies.js");
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        module.exports = (versions, range, options)=>{
            const set = [];
            let first = null;
            let prev = null;
            const v = versions.sort((a, b)=>compare(a, b, options));
            for (const version of v){
                const included = satisfies(version, range, options);
                if (included) {
                    prev = version;
                    if (!first) first = version;
                } else {
                    if (prev) set.push([
                        first,
                        prev
                    ]);
                    prev = null;
                    first = null;
                }
            }
            if (first) set.push([
                first,
                null
            ]);
            const ranges = [];
            for (const [min, max] of set)if (min === max) ranges.push(min);
            else if (max || min !== v[0]) {
                if (max) {
                    if (min === v[0]) ranges.push(`<=${max}`);
                    else ranges.push(`${min} - ${max}`);
                } else ranges.push(`>=${min}`);
            } else ranges.push('*');
            const simplified = ranges.join(' || ');
            const original = 'string' == typeof range.raw ? range.raw : String(range);
            return simplified.length < original.length ? simplified : range;
        };
    },
    "../../../../node_modules/semver/ranges/subset.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const Comparator = __webpack_require__("../../../../node_modules/semver/classes/comparator.js");
        const { ANY } = Comparator;
        const satisfies = __webpack_require__("../../../../node_modules/semver/functions/satisfies.js");
        const compare = __webpack_require__("../../../../node_modules/semver/functions/compare.js");
        const subset = (sub, dom, options = {})=>{
            if (sub === dom) return true;
            sub = new Range(sub, options);
            dom = new Range(dom, options);
            let sawNonNull = false;
            OUTER: for (const simpleSub of sub.set){
                for (const simpleDom of dom.set){
                    const isSub = simpleSubset(simpleSub, simpleDom, options);
                    sawNonNull = sawNonNull || null !== isSub;
                    if (isSub) continue OUTER;
                }
                if (sawNonNull) return false;
            }
            return true;
        };
        const minimumVersionWithPreRelease = [
            new Comparator('>=0.0.0-0')
        ];
        const minimumVersion = [
            new Comparator('>=0.0.0')
        ];
        const simpleSubset = (sub, dom, options)=>{
            if (sub === dom) return true;
            if (1 === sub.length && sub[0].semver === ANY) {
                if (1 === dom.length && dom[0].semver === ANY) return true;
                sub = options.includePrerelease ? minimumVersionWithPreRelease : minimumVersion;
            }
            if (1 === dom.length && dom[0].semver === ANY) {
                if (options.includePrerelease) return true;
                dom = minimumVersion;
            }
            const eqSet = new Set();
            let gt, lt;
            for (const c of sub)if ('>' === c.operator || '>=' === c.operator) gt = higherGT(gt, c, options);
            else if ('<' === c.operator || '<=' === c.operator) lt = lowerLT(lt, c, options);
            else eqSet.add(c.semver);
            if (eqSet.size > 1) return null;
            let gtltComp;
            if (gt && lt) {
                gtltComp = compare(gt.semver, lt.semver, options);
                if (gtltComp > 0) return null;
                if (0 === gtltComp && ('>=' !== gt.operator || '<=' !== lt.operator)) return null;
            }
            for (const eq of eqSet){
                if (gt && !satisfies(eq, String(gt), options)) return null;
                if (lt && !satisfies(eq, String(lt), options)) return null;
                for (const c of dom)if (!satisfies(eq, String(c), options)) return false;
                return true;
            }
            let higher, lower;
            let hasDomLT, hasDomGT;
            let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
            let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
            if (needDomLTPre && 1 === needDomLTPre.prerelease.length && '<' === lt.operator && 0 === needDomLTPre.prerelease[0]) needDomLTPre = false;
            for (const c of dom){
                hasDomGT = hasDomGT || '>' === c.operator || '>=' === c.operator;
                hasDomLT = hasDomLT || '<' === c.operator || '<=' === c.operator;
                if (gt) {
                    if (needDomGTPre) {
                        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) needDomGTPre = false;
                    }
                    if ('>' === c.operator || '>=' === c.operator) {
                        higher = higherGT(gt, c, options);
                        if (higher === c && higher !== gt) return false;
                    } else if ('>=' === gt.operator && !satisfies(gt.semver, String(c), options)) return false;
                }
                if (lt) {
                    if (needDomLTPre) {
                        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) needDomLTPre = false;
                    }
                    if ('<' === c.operator || '<=' === c.operator) {
                        lower = lowerLT(lt, c, options);
                        if (lower === c && lower !== lt) return false;
                    } else if ('<=' === lt.operator && !satisfies(lt.semver, String(c), options)) return false;
                }
                if (!c.operator && (lt || gt) && 0 !== gtltComp) return false;
            }
            if (gt && hasDomLT && !lt && 0 !== gtltComp) return false;
            if (lt && hasDomGT && !gt && 0 !== gtltComp) return false;
            if (needDomGTPre || needDomLTPre) return false;
            return true;
        };
        const higherGT = (a, b, options)=>{
            if (!a) return b;
            const comp = compare(a.semver, b.semver, options);
            return comp > 0 ? a : comp < 0 ? b : '>' === b.operator && '>=' === a.operator ? b : a;
        };
        const lowerLT = (a, b, options)=>{
            if (!a) return b;
            const comp = compare(a.semver, b.semver, options);
            return comp < 0 ? a : comp > 0 ? b : '<' === b.operator && '<=' === a.operator ? b : a;
        };
        module.exports = subset;
    },
    "../../../../node_modules/semver/ranges/to-comparators.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(' ').trim().split(' '));
        module.exports = toComparators;
    },
    "../../../../node_modules/semver/ranges/valid.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const Range = __webpack_require__("../../../../node_modules/semver/classes/range.js");
        const validRange = (range, options)=>{
            try {
                return new Range(range, options).range || '*';
            } catch (er) {
                return null;
            }
        };
        module.exports = validRange;
    },
    "../../../../node_modules/which/which.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const isWindows = 'win32' === process.platform || 'cygwin' === process.env.OSTYPE || 'msys' === process.env.OSTYPE;
        const path = __webpack_require__("path");
        const COLON = isWindows ? ';' : ':';
        const isexe = __webpack_require__("../../../../node_modules/isexe/index.js");
        const getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
                code: 'ENOENT'
            });
        const getPathInfo = (cmd, opt)=>{
            const colon = opt.colon || COLON;
            const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
                ''
            ] : [
                ...isWindows ? [
                    process.cwd()
                ] : [],
                ...(opt.path || process.env.PATH || '').split(colon)
            ];
            const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';
            const pathExt = isWindows ? pathExtExe.split(colon) : [
                ''
            ];
            if (isWindows) {
                if (-1 !== cmd.indexOf('.') && '' !== pathExt[0]) pathExt.unshift('');
            }
            return {
                pathEnv,
                pathExt,
                pathExtExe
            };
        };
        const which = (cmd, opt, cb)=>{
            if ('function' == typeof opt) {
                cb = opt;
                opt = {};
            }
            if (!opt) opt = {};
            const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
            const found = [];
            const step = (i)=>new Promise((resolve, reject)=>{
                    if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
                    const ppRaw = pathEnv[i];
                    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
                    const pCmd = path.join(pathPart, cmd);
                    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
                    resolve(subStep(p, i, 0));
                });
            const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
                    if (ii === pathExt.length) return resolve(step(i + 1));
                    const ext = pathExt[ii];
                    isexe(p + ext, {
                        pathExt: pathExtExe
                    }, (er, is)=>{
                        if (!er && is) {
                            if (!opt.all) return resolve(p + ext);
                            found.push(p + ext);
                        }
                        return resolve(subStep(p, i, ii + 1));
                    });
                });
            return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
        };
        const whichSync = (cmd, opt)=>{
            opt = opt || {};
            const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
            const found = [];
            for(let i = 0; i < pathEnv.length; i++){
                const ppRaw = pathEnv[i];
                const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
                const pCmd = path.join(pathPart, cmd);
                const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
                for(let j = 0; j < pathExt.length; j++){
                    const cur = p + pathExt[j];
                    try {
                        const is = isexe.sync(cur, {
                            pathExt: pathExtExe
                        });
                        if (is) {
                            if (!opt.all) return cur;
                            found.push(cur);
                        }
                    } catch (ex) {}
                }
            }
            if (opt.all && found.length) return found;
            if (opt.nothrow) return null;
            throw getNotFoundError(cmd);
        };
        module.exports = which;
        which.sync = whichSync;
    },
    "../../browser/node_modules/which/lib/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const { isexe, sync: isexeSync } = __webpack_require__("../../browser/node_modules/isexe/dist/cjs/index.js");
        const { join, delimiter, sep, posix } = __webpack_require__("path");
        const isWindows = 'win32' === process.platform;
        const rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? '' : sep}]`.replace(/(\\)/g, '\\$1'));
        const rRel = new RegExp(`^\\.${rSlash.source}`);
        const getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
                code: 'ENOENT'
            });
        const getPathInfo = (cmd, { path: optPath = process.env.PATH, pathExt: optPathExt = process.env.PATHEXT, delimiter: optDelimiter = delimiter })=>{
            const pathEnv = cmd.match(rSlash) ? [
                ''
            ] : [
                ...isWindows ? [
                    process.cwd()
                ] : [],
                ...(optPath || '').split(optDelimiter)
            ];
            if (isWindows) {
                const pathExtExe = optPathExt || [
                    '.EXE',
                    '.CMD',
                    '.BAT',
                    '.COM'
                ].join(optDelimiter);
                const pathExt = pathExtExe.split(optDelimiter).flatMap((item)=>[
                        item,
                        item.toLowerCase()
                    ]);
                if (cmd.includes('.') && '' !== pathExt[0]) pathExt.unshift('');
                return {
                    pathEnv,
                    pathExt,
                    pathExtExe
                };
            }
            return {
                pathEnv,
                pathExt: [
                    ''
                ]
            };
        };
        const getPathPart = (raw, cmd)=>{
            const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
            const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : '';
            return prefix + join(pathPart, cmd);
        };
        const which = async (cmd, opt = {})=>{
            const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
            const found = [];
            for (const envPart of pathEnv){
                const p = getPathPart(envPart, cmd);
                for (const ext of pathExt){
                    const withExt = p + ext;
                    const is = await isexe(withExt, {
                        pathExt: pathExtExe,
                        ignoreErrors: true
                    });
                    if (is) {
                        if (!opt.all) return withExt;
                        found.push(withExt);
                    }
                }
            }
            if (opt.all && found.length) return found;
            if (opt.nothrow) return null;
            throw getNotFoundError(cmd);
        };
        const whichSync = (cmd, opt = {})=>{
            const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
            const found = [];
            for (const pathEnvPart of pathEnv){
                const p = getPathPart(pathEnvPart, cmd);
                for (const ext of pathExt){
                    const withExt = p + ext;
                    const is = isexeSync(withExt, {
                        pathExt: pathExtExe,
                        ignoreErrors: true
                    });
                    if (is) {
                        if (!opt.all) return withExt;
                        found.push(withExt);
                    }
                }
            }
            if (opt.all && found.length) return found;
            if (opt.nothrow) return null;
            throw getNotFoundError(cmd);
        };
        module.exports = which;
        which.sync = whichSync;
    },
    "./node_modules/isbinaryfile/lib/index.js": function(__unused_webpack_module, exports, __webpack_require__) {
        exports.isBinaryFile = void 0;
        const fs = __webpack_require__("fs");
        const util_1 = __webpack_require__("util");
        const statAsync = (0, util_1.promisify)(fs.stat);
        const openAsync = (0, util_1.promisify)(fs.open);
        const closeAsync = (0, util_1.promisify)(fs.close);
        const MAX_BYTES = 512;
        class Reader {
            fileBuffer;
            size;
            offset;
            error;
            constructor(fileBuffer, size){
                this.fileBuffer = fileBuffer;
                this.size = size;
                this.offset = 0;
                this.error = false;
            }
            hasError() {
                return this.error;
            }
            nextByte() {
                if (this.offset === this.size || this.hasError()) {
                    this.error = true;
                    return 0xff;
                }
                return this.fileBuffer[this.offset++];
            }
            next(len) {
                const n = new Array();
                for(let i = 0; i < len; i++)n[i] = this.nextByte();
                return n;
            }
        }
        function readProtoVarInt(reader) {
            let idx = 0;
            let varInt = 0;
            while(!reader.hasError()){
                const b = reader.nextByte();
                varInt |= (0x7f & b) << 7 * idx;
                if ((0x80 & b) === 0) break;
                idx++;
            }
            return varInt;
        }
        function readProtoMessage(reader) {
            const varInt = readProtoVarInt(reader);
            const wireType = 0x7 & varInt;
            switch(wireType){
                case 0:
                    readProtoVarInt(reader);
                    return true;
                case 1:
                    reader.next(8);
                    return true;
                case 2:
                    const len = readProtoVarInt(reader);
                    reader.next(len);
                    return true;
                case 5:
                    reader.next(4);
                    return true;
            }
            return false;
        }
        function isBinaryProto(fileBuffer, totalBytes) {
            const reader = new Reader(fileBuffer, totalBytes);
            let numMessages = 0;
            while(true){
                if (!readProtoMessage(reader) && !reader.hasError()) return false;
                if (reader.hasError()) break;
                numMessages++;
            }
            return numMessages > 0;
        }
        async function isBinaryFile(file, size) {
            if (isString(file)) {
                const stat = await statAsync(file);
                isStatFile(stat);
                const fileDescriptor = await openAsync(file, 'r');
                const allocBuffer = Buffer.alloc(MAX_BYTES);
                return new Promise((fulfill, reject)=>{
                    fs.read(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0, (err, bytesRead, _)=>{
                        closeAsync(fileDescriptor);
                        if (err) reject(err);
                        else fulfill(isBinaryCheck(allocBuffer, bytesRead));
                    });
                });
            }
            if (void 0 === size) size = file.length;
            return isBinaryCheck(file, size);
        }
        exports.isBinaryFile = isBinaryFile;
        function isBinaryCheck(fileBuffer, bytesRead) {
            if (0 === bytesRead) return false;
            let suspiciousBytes = 0;
            const totalBytes = Math.min(bytesRead, MAX_BYTES);
            if (bytesRead >= 3 && 0xef === fileBuffer[0] && 0xbb === fileBuffer[1] && 0xbf === fileBuffer[2]) return false;
            if (bytesRead >= 4 && 0x00 === fileBuffer[0] && 0x00 === fileBuffer[1] && 0xfe === fileBuffer[2] && 0xff === fileBuffer[3]) return false;
            if (bytesRead >= 4 && 0xff === fileBuffer[0] && 0xfe === fileBuffer[1] && 0x00 === fileBuffer[2] && 0x00 === fileBuffer[3]) return false;
            if (bytesRead >= 4 && 0x84 === fileBuffer[0] && 0x31 === fileBuffer[1] && 0x95 === fileBuffer[2] && 0x33 === fileBuffer[3]) return false;
            if (totalBytes >= 5 && '%PDF-' === fileBuffer.slice(0, 5).toString()) return true;
            if (bytesRead >= 2 && 0xfe === fileBuffer[0] && 0xff === fileBuffer[1]) return false;
            if (bytesRead >= 2 && 0xff === fileBuffer[0] && 0xfe === fileBuffer[1]) return false;
            for(let i = 0; i < totalBytes; i++){
                if (0 === fileBuffer[i]) return true;
                if ((fileBuffer[i] < 7 || fileBuffer[i] > 14) && (fileBuffer[i] < 32 || fileBuffer[i] > 127)) {
                    if (fileBuffer[i] >= 0xc0 && fileBuffer[i] <= 0xdf && i + 1 < totalBytes) {
                        i++;
                        if (fileBuffer[i] >= 0x80 && fileBuffer[i] <= 0xbf) continue;
                    } else if (fileBuffer[i] >= 0xe0 && fileBuffer[i] <= 0xef && i + 2 < totalBytes) {
                        i++;
                        if (fileBuffer[i] >= 0x80 && fileBuffer[i] <= 0xbf && fileBuffer[i + 1] >= 0x80 && fileBuffer[i + 1] <= 0xbf) {
                            i++;
                            continue;
                        }
                    } else if (fileBuffer[i] >= 0xf0 && fileBuffer[i] <= 0xf7 && i + 3 < totalBytes) {
                        i++;
                        if (fileBuffer[i] >= 0x80 && fileBuffer[i] <= 0xbf && fileBuffer[i + 1] >= 0x80 && fileBuffer[i + 1] <= 0xbf && fileBuffer[i + 2] >= 0x80 && fileBuffer[i + 2] <= 0xbf) {
                            i += 2;
                            continue;
                        }
                    }
                    suspiciousBytes++;
                    if (i >= 32 && 100 * suspiciousBytes / totalBytes > 10) return true;
                }
            }
            if (100 * suspiciousBytes / totalBytes > 10) return true;
            if (suspiciousBytes > 1 && isBinaryProto(fileBuffer, totalBytes)) return true;
            return false;
        }
        function isString(x) {
            return 'string' == typeof x;
        }
        function isStatFile(stat) {
            if (!stat.isFile()) throw new Error("Path provided was not a file!");
        }
    },
    fs: function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_fs__;
    },
    "fs/promises": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_fs_promises_400951f8__;
    },
    path: function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_path__;
    },
    punycode: function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_punycode__;
    },
    util: function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_util__;
    },
    "../../browser/node_modules/isexe/dist/cjs/index.js": function(__unused_webpack_module, exports, __webpack_require__) {
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __exportStar = this && this.__exportStar || function(m, exports) {
            for(var p in m)if ("default" !== p && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
        };
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.sync = exports.isexe = exports.posix = exports.win32 = void 0;
        const posix = __importStar(__webpack_require__("../../browser/node_modules/isexe/dist/cjs/posix.js"));
        exports.posix = posix;
        const win32 = __importStar(__webpack_require__("../../browser/node_modules/isexe/dist/cjs/win32.js"));
        exports.win32 = win32;
        __exportStar(__webpack_require__("../../browser/node_modules/isexe/dist/cjs/options.js"), exports);
        const platform = process.env._ISEXE_TEST_PLATFORM_ || process.platform;
        const impl = 'win32' === platform ? win32 : posix;
        exports.isexe = impl.isexe;
        exports.sync = impl.sync;
    },
    "../../browser/node_modules/isexe/dist/cjs/options.js": function(__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
    },
    "../../browser/node_modules/isexe/dist/cjs/posix.js": function(__unused_webpack_module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.sync = exports.isexe = void 0;
        const fs_1 = __webpack_require__("fs");
        const promises_1 = __webpack_require__("fs/promises");
        const isexe = async (path, options = {})=>{
            const { ignoreErrors = false } = options;
            try {
                return checkStat(await (0, promises_1.stat)(path), options);
            } catch (e) {
                const er = e;
                if (ignoreErrors || 'EACCES' === er.code) return false;
                throw er;
            }
        };
        exports.isexe = isexe;
        const sync = (path, options = {})=>{
            const { ignoreErrors = false } = options;
            try {
                return checkStat((0, fs_1.statSync)(path), options);
            } catch (e) {
                const er = e;
                if (ignoreErrors || 'EACCES' === er.code) return false;
                throw er;
            }
        };
        exports.sync = sync;
        const checkStat = (stat, options)=>stat.isFile() && checkMode(stat, options);
        const checkMode = (stat, options)=>{
            const myUid = options.uid ?? process.getuid?.();
            const myGroups = options.groups ?? process.getgroups?.() ?? [];
            const myGid = options.gid ?? process.getgid?.() ?? myGroups[0];
            if (void 0 === myUid || void 0 === myGid) throw new Error('cannot get uid or gid');
            const groups = new Set([
                myGid,
                ...myGroups
            ]);
            const mod = stat.mode;
            const uid = stat.uid;
            const gid = stat.gid;
            const u = parseInt('100', 8);
            const g = parseInt('010', 8);
            const o = parseInt('001', 8);
            const ug = u | g;
            return !!(mod & o || mod & g && groups.has(gid) || mod & u && uid === myUid || mod & ug && 0 === myUid);
        };
    },
    "../../browser/node_modules/isexe/dist/cjs/win32.js": function(__unused_webpack_module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.sync = exports.isexe = void 0;
        const fs_1 = __webpack_require__("fs");
        const promises_1 = __webpack_require__("fs/promises");
        const isexe = async (path, options = {})=>{
            const { ignoreErrors = false } = options;
            try {
                return checkStat(await (0, promises_1.stat)(path), path, options);
            } catch (e) {
                const er = e;
                if (ignoreErrors || 'EACCES' === er.code) return false;
                throw er;
            }
        };
        exports.isexe = isexe;
        const sync = (path, options = {})=>{
            const { ignoreErrors = false } = options;
            try {
                return checkStat((0, fs_1.statSync)(path), path, options);
            } catch (e) {
                const er = e;
                if (ignoreErrors || 'EACCES' === er.code) return false;
                throw er;
            }
        };
        exports.sync = sync;
        const checkPathExt = (path, options)=>{
            const { pathExt = process.env.PATHEXT || '' } = options;
            const peSplit = pathExt.split(';');
            if (-1 !== peSplit.indexOf('')) return true;
            for(let i = 0; i < peSplit.length; i++){
                const p = peSplit[i].toLowerCase();
                const ext = path.substring(path.length - p.length).toLowerCase();
                if (p && ext === p) return true;
            }
            return false;
        };
        const checkStat = (stat, path, options)=>stat.isFile() && checkPathExt(path, options);
    },
    "../../../../node_modules/@langchain/core/dist/errors/index.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            r: ()=>addLangChainErrorFields
        });
        function addLangChainErrorFields(error, lc_error_code) {
            error.lc_error_code = lc_error_code;
            error.message = `${error.message}\n\nTroubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/\n`;
            return error;
        }
    },
    "../../../../node_modules/@langchain/core/dist/load/serializable.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            j: ()=>get_lc_unique_name,
            i: ()=>Serializable
        });
        var decamelize = __webpack_require__("../../../../node_modules/decamelize/index.js");
        __webpack_require__("../../../../node_modules/camelcase/index.js");
        function keyToJson(key, map) {
            return map?.[key] || decamelize(key);
        }
        function mapKeys(fields, mapper, map) {
            const mapped = {};
            for(const key in fields)if (Object.hasOwn(fields, key)) mapped[mapper(key, map)] = fields[key];
            return mapped;
        }
        function shallowCopy(obj) {
            return Array.isArray(obj) ? [
                ...obj
            ] : {
                ...obj
            };
        }
        function replaceSecrets(root, secretsMap) {
            const result = shallowCopy(root);
            for (const [path, secretId] of Object.entries(secretsMap)){
                const [last, ...partsReverse] = path.split(".").reverse();
                let current = result;
                for (const part of partsReverse.reverse()){
                    if (void 0 === current[part]) break;
                    current[part] = shallowCopy(current[part]);
                    current = current[part];
                }
                if (void 0 !== current[last]) current[last] = {
                    lc: 1,
                    type: "secret",
                    id: [
                        secretId
                    ]
                };
            }
            return result;
        }
        function get_lc_unique_name(serializableClass) {
            const parentClass = Object.getPrototypeOf(serializableClass);
            const lcNameIsSubclassed = "function" == typeof serializableClass.lc_name && ("function" != typeof parentClass.lc_name || serializableClass.lc_name() !== parentClass.lc_name());
            if (lcNameIsSubclassed) return serializableClass.lc_name();
            return serializableClass.name;
        }
        class Serializable {
            static lc_name() {
                return this.name;
            }
            get lc_id() {
                return [
                    ...this.lc_namespace,
                    get_lc_unique_name(this.constructor)
                ];
            }
            get lc_secrets() {}
            get lc_attributes() {}
            get lc_aliases() {}
            get lc_serializable_keys() {}
            constructor(kwargs, ..._args){
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "lc_kwargs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                if (void 0 !== this.lc_serializable_keys) this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key])=>this.lc_serializable_keys?.includes(key)));
                else this.lc_kwargs = kwargs ?? {};
            }
            toJSON() {
                if (!this.lc_serializable) return this.toJSONNotImplemented();
                if (this.lc_kwargs instanceof Serializable || "object" != typeof this.lc_kwargs || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
                const aliases = {};
                const secrets = {};
                const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key)=>{
                    acc[key] = key in this ? this[key] : this.lc_kwargs[key];
                    return acc;
                }, {});
                for(let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)){
                    Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
                    Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
                    Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
                }
                Object.keys(secrets).forEach((keyPath)=>{
                    let read = this;
                    let write = kwargs;
                    const [last, ...partsReverse] = keyPath.split(".").reverse();
                    for (const key of partsReverse.reverse()){
                        if (!(key in read) || void 0 === read[key]) return;
                        if (!(key in write) || void 0 === write[key]) {
                            if ("object" == typeof read[key] && null != read[key]) write[key] = {};
                            else if (Array.isArray(read[key])) write[key] = [];
                        }
                        read = read[key];
                        write = write[key];
                    }
                    if (last in read && void 0 !== read[last]) write[last] = write[last] || read[last];
                });
                return {
                    lc: 1,
                    type: "constructor",
                    id: this.lc_id,
                    kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases)
                };
            }
            toJSONNotImplemented() {
                return {
                    lc: 1,
                    type: "not_implemented",
                    id: this.lc_id
                };
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/messages/ai.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            GC: ()=>AIMessageChunk,
            gY: ()=>AIMessage
        });
        function parsePartialJson(s) {
            if (void 0 === s) return null;
            try {
                return JSON.parse(s);
            } catch (error) {}
            let new_s = "";
            const stack = [];
            let isInsideString = false;
            let escaped = false;
            for (let char of s){
                if (isInsideString) {
                    if ('"' !== char || escaped) {
                        if ("\n" !== char || escaped) escaped = "\\" === char ? !escaped : false;
                        else char = "\\n";
                    } else isInsideString = false;
                } else if ('"' === char) {
                    isInsideString = true;
                    escaped = false;
                } else if ("{" === char) stack.push("}");
                else if ("[" === char) stack.push("]");
                else if ("}" === char || "]" === char) {
                    if (!stack || stack[stack.length - 1] !== char) return null;
                    stack.pop();
                }
                new_s += char;
            }
            if (isInsideString) new_s += '"';
            for(let i = stack.length - 1; i >= 0; i -= 1)new_s += stack[i];
            try {
                return JSON.parse(new_s);
            } catch (error) {
                return null;
            }
        }
        var base = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/base.js");
        var tool = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/tool.js");
        class AIMessage extends base.ku {
            get lc_aliases() {
                return {
                    ...super.lc_aliases,
                    tool_calls: "tool_calls",
                    invalid_tool_calls: "invalid_tool_calls"
                };
            }
            constructor(fields, kwargs){
                let initParams;
                if ("string" == typeof fields) initParams = {
                    content: fields,
                    tool_calls: [],
                    invalid_tool_calls: [],
                    additional_kwargs: kwargs ?? {}
                };
                else {
                    initParams = fields;
                    const rawToolCalls = initParams.additional_kwargs?.tool_calls;
                    const toolCalls = initParams.tool_calls;
                    if (null != rawToolCalls && rawToolCalls.length > 0 && (void 0 === toolCalls || 0 === toolCalls.length)) console.warn("New LangChain packages are available that more efficiently handle tool calling.\n\nPlease upgrade your packages to versions that set message tool calls. e.g., `yarn add @langchain/anthropic`, yarn add @langchain/openai`, etc.");
                    try {
                        if (null != rawToolCalls && void 0 === toolCalls) {
                            const [toolCalls, invalidToolCalls] = (0, tool.jC)(rawToolCalls);
                            initParams.tool_calls = toolCalls ?? [];
                            initParams.invalid_tool_calls = invalidToolCalls ?? [];
                        } else {
                            initParams.tool_calls = initParams.tool_calls ?? [];
                            initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];
                        }
                    } catch (e) {
                        initParams.tool_calls = [];
                        initParams.invalid_tool_calls = [];
                    }
                }
                super(initParams);
                Object.defineProperty(this, "tool_calls", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "invalid_tool_calls", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "usage_metadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                if ("string" != typeof initParams) {
                    this.tool_calls = initParams.tool_calls ?? this.tool_calls;
                    this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
                }
                this.usage_metadata = initParams.usage_metadata;
            }
            static lc_name() {
                return "AIMessage";
            }
            _getType() {
                return "ai";
            }
            get _printableFields() {
                return {
                    ...super._printableFields,
                    tool_calls: this.tool_calls,
                    invalid_tool_calls: this.invalid_tool_calls,
                    usage_metadata: this.usage_metadata
                };
            }
        }
        class AIMessageChunk extends base.$k {
            constructor(fields){
                let initParams;
                if ("string" == typeof fields) initParams = {
                    content: fields,
                    tool_calls: [],
                    invalid_tool_calls: [],
                    tool_call_chunks: []
                };
                else if (void 0 === fields.tool_call_chunks) initParams = {
                    ...fields,
                    tool_calls: fields.tool_calls ?? [],
                    invalid_tool_calls: [],
                    tool_call_chunks: [],
                    usage_metadata: void 0 !== fields.usage_metadata ? fields.usage_metadata : void 0
                };
                else {
                    const toolCalls = [];
                    const invalidToolCalls = [];
                    for (const toolCallChunk of fields.tool_call_chunks){
                        let parsedArgs = {};
                        try {
                            parsedArgs = parsePartialJson(toolCallChunk.args || "{}");
                            if (null === parsedArgs || "object" != typeof parsedArgs || Array.isArray(parsedArgs)) throw new Error("Malformed tool call chunk args.");
                            toolCalls.push({
                                name: toolCallChunk.name ?? "",
                                args: parsedArgs,
                                id: toolCallChunk.id,
                                type: "tool_call"
                            });
                        } catch (e) {
                            invalidToolCalls.push({
                                name: toolCallChunk.name,
                                args: toolCallChunk.args,
                                id: toolCallChunk.id,
                                error: "Malformed args.",
                                type: "invalid_tool_call"
                            });
                        }
                    }
                    initParams = {
                        ...fields,
                        tool_calls: toolCalls,
                        invalid_tool_calls: invalidToolCalls,
                        usage_metadata: void 0 !== fields.usage_metadata ? fields.usage_metadata : void 0
                    };
                }
                super(initParams);
                Object.defineProperty(this, "tool_calls", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "invalid_tool_calls", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "tool_call_chunks", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "usage_metadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.tool_call_chunks = initParams.tool_call_chunks ?? this.tool_call_chunks;
                this.tool_calls = initParams.tool_calls ?? this.tool_calls;
                this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
                this.usage_metadata = initParams.usage_metadata;
            }
            get lc_aliases() {
                return {
                    ...super.lc_aliases,
                    tool_calls: "tool_calls",
                    invalid_tool_calls: "invalid_tool_calls",
                    tool_call_chunks: "tool_call_chunks"
                };
            }
            static lc_name() {
                return "AIMessageChunk";
            }
            _getType() {
                return "ai";
            }
            get _printableFields() {
                return {
                    ...super._printableFields,
                    tool_calls: this.tool_calls,
                    tool_call_chunks: this.tool_call_chunks,
                    invalid_tool_calls: this.invalid_tool_calls,
                    usage_metadata: this.usage_metadata
                };
            }
            concat(chunk) {
                const combinedFields = {
                    content: (0, base.Wf)(this.content, chunk.content),
                    additional_kwargs: (0, base.wv)(this.additional_kwargs, chunk.additional_kwargs),
                    response_metadata: (0, base.wv)(this.response_metadata, chunk.response_metadata),
                    tool_call_chunks: [],
                    id: this.id ?? chunk.id
                };
                if (void 0 !== this.tool_call_chunks || void 0 !== chunk.tool_call_chunks) {
                    const rawToolCalls = (0, base.eL)(this.tool_call_chunks, chunk.tool_call_chunks);
                    if (void 0 !== rawToolCalls && rawToolCalls.length > 0) combinedFields.tool_call_chunks = rawToolCalls;
                }
                if (void 0 !== this.usage_metadata || void 0 !== chunk.usage_metadata) {
                    const inputTokenDetails = {
                        ...(this.usage_metadata?.input_token_details?.audio !== void 0 || chunk.usage_metadata?.input_token_details?.audio !== void 0) && {
                            audio: (this.usage_metadata?.input_token_details?.audio ?? 0) + (chunk.usage_metadata?.input_token_details?.audio ?? 0)
                        },
                        ...(this.usage_metadata?.input_token_details?.cache_read !== void 0 || chunk.usage_metadata?.input_token_details?.cache_read !== void 0) && {
                            cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) + (chunk.usage_metadata?.input_token_details?.cache_read ?? 0)
                        },
                        ...(this.usage_metadata?.input_token_details?.cache_creation !== void 0 || chunk.usage_metadata?.input_token_details?.cache_creation !== void 0) && {
                            cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) + (chunk.usage_metadata?.input_token_details?.cache_creation ?? 0)
                        }
                    };
                    const outputTokenDetails = {
                        ...(this.usage_metadata?.output_token_details?.audio !== void 0 || chunk.usage_metadata?.output_token_details?.audio !== void 0) && {
                            audio: (this.usage_metadata?.output_token_details?.audio ?? 0) + (chunk.usage_metadata?.output_token_details?.audio ?? 0)
                        },
                        ...(this.usage_metadata?.output_token_details?.reasoning !== void 0 || chunk.usage_metadata?.output_token_details?.reasoning !== void 0) && {
                            reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) + (chunk.usage_metadata?.output_token_details?.reasoning ?? 0)
                        }
                    };
                    const left = this.usage_metadata ?? {
                        input_tokens: 0,
                        output_tokens: 0,
                        total_tokens: 0
                    };
                    const right = chunk.usage_metadata ?? {
                        input_tokens: 0,
                        output_tokens: 0,
                        total_tokens: 0
                    };
                    const usage_metadata = {
                        input_tokens: left.input_tokens + right.input_tokens,
                        output_tokens: left.output_tokens + right.output_tokens,
                        total_tokens: left.total_tokens + right.total_tokens,
                        ...Object.keys(inputTokenDetails).length > 0 && {
                            input_token_details: inputTokenDetails
                        },
                        ...Object.keys(outputTokenDetails).length > 0 && {
                            output_token_details: outputTokenDetails
                        }
                    };
                    combinedFields.usage_metadata = usage_metadata;
                }
                return new AIMessageChunk(combinedFields);
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/messages/base.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            $k: ()=>BaseMessageChunk,
            QW: ()=>isBaseMessage,
            Wf: ()=>mergeContent,
            eL: ()=>_mergeLists,
            gQ: ()=>_isMessageFieldWithRole,
            ku: ()=>BaseMessage,
            n4: ()=>_mergeStatus,
            wv: ()=>_mergeDicts,
            x: ()=>_mergeObj
        });
        var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/load/serializable.js");
        function mergeContent(firstContent, secondContent) {
            if ("string" == typeof firstContent) {
                if ("" === firstContent) return secondContent;
                if ("string" == typeof secondContent) return firstContent + secondContent;
                return [
                    {
                        type: "text",
                        text: firstContent
                    },
                    ...secondContent
                ];
            }
            if (Array.isArray(secondContent)) return _mergeLists(firstContent, secondContent) ?? [
                ...firstContent,
                ...secondContent
            ];
            if ("" === secondContent) return firstContent;
            return [
                ...firstContent,
                {
                    type: "text",
                    text: secondContent
                }
            ];
        }
        function _mergeStatus(left, right) {
            if ("error" === left || "error" === right) return "error";
            return "success";
        }
        function stringifyWithDepthLimit(obj, depthLimit) {
            function helper(obj, currentDepth) {
                if ("object" != typeof obj || null == obj) return obj;
                if (currentDepth >= depthLimit) {
                    if (Array.isArray(obj)) return "[Array]";
                    return "[Object]";
                }
                if (Array.isArray(obj)) return obj.map((item)=>helper(item, currentDepth + 1));
                const result = {};
                for (const key of Object.keys(obj))result[key] = helper(obj[key], currentDepth + 1);
                return result;
            }
            return JSON.stringify(helper(obj, 0), null, 2);
        }
        class BaseMessage extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.i {
            get lc_aliases() {
                return {
                    additional_kwargs: "additional_kwargs",
                    response_metadata: "response_metadata"
                };
            }
            get text() {
                return "string" == typeof this.content ? this.content : "";
            }
            getType() {
                return this._getType();
            }
            constructor(fields, kwargs){
                if ("string" == typeof fields) fields = {
                    content: fields,
                    additional_kwargs: kwargs,
                    response_metadata: {}
                };
                if (!fields.additional_kwargs) fields.additional_kwargs = {};
                if (!fields.response_metadata) fields.response_metadata = {};
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "messages"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "content", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "additional_kwargs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "response_metadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "id", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.name = fields.name;
                this.content = fields.content;
                this.additional_kwargs = fields.additional_kwargs;
                this.response_metadata = fields.response_metadata;
                this.id = fields.id;
            }
            toDict() {
                return {
                    type: this._getType(),
                    data: this.toJSON().kwargs
                };
            }
            static lc_name() {
                return "BaseMessage";
            }
            get _printableFields() {
                return {
                    id: this.id,
                    content: this.content,
                    name: this.name,
                    additional_kwargs: this.additional_kwargs,
                    response_metadata: this.response_metadata
                };
            }
            _updateId(value) {
                this.id = value;
                this.lc_kwargs.id = value;
            }
            get [Symbol.toStringTag]() {
                return this.constructor.lc_name();
            }
            [Symbol.for("nodejs.util.inspect.custom")](depth) {
                if (null === depth) return this;
                const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
                return `${this.constructor.lc_name()} ${printable}`;
            }
        }
        function _mergeDicts(left, right) {
            const merged = {
                ...left
            };
            for (const [key, value] of Object.entries(right))if (null == merged[key]) merged[key] = value;
            else if (null == value) continue;
            else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value)) throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);
            else if ("string" == typeof merged[key]) {
                if ("type" === key) continue;
                merged[key] += value;
            } else if ("object" != typeof merged[key] || Array.isArray(merged[key])) {
                if (Array.isArray(merged[key])) merged[key] = _mergeLists(merged[key], value);
                else {
                    if (merged[key] === value) continue;
                    console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);
                }
            } else merged[key] = _mergeDicts(merged[key], value);
            return merged;
        }
        function _mergeLists(left, right) {
            if (void 0 === left && void 0 === right) return;
            if (void 0 === left || void 0 === right) return left || right;
            {
                const merged = [
                    ...left
                ];
                for (const item of right)if ("object" == typeof item && "index" in item && "number" == typeof item.index) {
                    const toMerge = merged.findIndex((leftItem)=>leftItem.index === item.index);
                    if (-1 !== toMerge) merged[toMerge] = _mergeDicts(merged[toMerge], item);
                    else merged.push(item);
                } else {
                    if ("object" == typeof item && "text" in item && "" === item.text) continue;
                    merged.push(item);
                }
                return merged;
            }
        }
        function _mergeObj(left, right) {
            if (!left && !right) throw new Error("Cannot merge two undefined objects.");
            if (!left || !right) return left || right;
            if (typeof left !== typeof right) throw new Error(`Cannot merge objects of different types.\nLeft ${typeof left}\nRight ${typeof right}`);
            if ("string" == typeof left && "string" == typeof right) return left + right;
            if (Array.isArray(left) && Array.isArray(right)) return _mergeLists(left, right);
            if ("object" == typeof left && "object" == typeof right) return _mergeDicts(left, right);
            else if (left === right) return left;
            else throw new Error(`Can not merge objects of different types.\nLeft ${left}\nRight ${right}`);
        }
        class BaseMessageChunk extends BaseMessage {
        }
        function _isMessageFieldWithRole(x) {
            return "string" == typeof x.role;
        }
        function isBaseMessage(messageLike) {
            return "function" == typeof messageLike?._getType;
        }
    },
    "../../../../node_modules/@langchain/core/dist/messages/chat.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            J: ()=>ChatMessage
        });
        var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/base.js");
        class ChatMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.ku {
            static lc_name() {
                return "ChatMessage";
            }
            static _chatMessageClass() {
                return ChatMessage;
            }
            constructor(fields, role){
                if ("string" == typeof fields) fields = {
                    content: fields,
                    role: role
                };
                super(fields);
                Object.defineProperty(this, "role", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.role = fields.role;
            }
            _getType() {
                return "generic";
            }
            static isInstance(message) {
                return "generic" === message._getType();
            }
            get _printableFields() {
                return {
                    ...super._printableFields,
                    role: this.role
                };
            }
        }
        class ChatMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.$k {
            static lc_name() {
                return "ChatMessageChunk";
            }
            constructor(fields, role){
                if ("string" == typeof fields) fields = {
                    content: fields,
                    role: role
                };
                super(fields);
                Object.defineProperty(this, "role", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.role = fields.role;
            }
            _getType() {
                return "generic";
            }
            concat(chunk) {
                return new ChatMessageChunk({
                    content: (0, _base_js__WEBPACK_IMPORTED_MODULE_0__.Wf)(this.content, chunk.content),
                    additional_kwargs: (0, _base_js__WEBPACK_IMPORTED_MODULE_0__.wv)(this.additional_kwargs, chunk.additional_kwargs),
                    response_metadata: (0, _base_js__WEBPACK_IMPORTED_MODULE_0__.wv)(this.response_metadata, chunk.response_metadata),
                    role: this.role,
                    id: this.id ?? chunk.id
                });
            }
            get _printableFields() {
                return {
                    ...super._printableFields,
                    role: this.role
                };
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/messages/function.js": function(__unused_webpack___webpack_module__, __unused_webpack___webpack_exports__, __webpack_require__) {
        var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/base.js");
        _base_js__WEBPACK_IMPORTED_MODULE_0__.ku;
    },
    "../../../../node_modules/@langchain/core/dist/messages/human.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            xk: ()=>HumanMessage
        });
        var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/base.js");
        class HumanMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.ku {
            static lc_name() {
                return "HumanMessage";
            }
            _getType() {
                return "human";
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/messages/index.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            xk: ()=>human.xk,
            jN: ()=>system.jN,
            gY: ()=>ai.gY,
            Cq: ()=>tool.Cq,
            QW: ()=>base.QW,
            E1: ()=>utils.E1,
            J: ()=>chat.J,
            ku: ()=>base.ku
        });
        var ai = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/ai.js");
        var base = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/base.js");
        var chat = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/chat.js");
        __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/function.js");
        var human = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/human.js");
        var system = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/system.js");
        var utils = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/utils.js");
        __webpack_require__("../../../../node_modules/@langchain/core/dist/runnables/base.js");
        base.ku;
        var tool = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/tool.js");
    },
    "../../../../node_modules/@langchain/core/dist/messages/system.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            jN: ()=>SystemMessage
        });
        var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/base.js");
        class SystemMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.ku {
            static lc_name() {
                return "SystemMessage";
            }
            _getType() {
                return "system";
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/messages/tool.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Cq: ()=>ToolMessage,
            jC: ()=>defaultToolCallParser
        });
        var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/base.js");
        class ToolMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.ku {
            static lc_name() {
                return "ToolMessage";
            }
            get lc_aliases() {
                return {
                    tool_call_id: "tool_call_id"
                };
            }
            constructor(fields, tool_call_id, name){
                if ("string" == typeof fields) fields = {
                    content: fields,
                    name,
                    tool_call_id: tool_call_id
                };
                super(fields);
                Object.defineProperty(this, "lc_direct_tool_output", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "status", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "tool_call_id", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "artifact", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.tool_call_id = fields.tool_call_id;
                this.artifact = fields.artifact;
                this.status = fields.status;
            }
            _getType() {
                return "tool";
            }
            static isInstance(message) {
                return "tool" === message._getType();
            }
            get _printableFields() {
                return {
                    ...super._printableFields,
                    tool_call_id: this.tool_call_id,
                    artifact: this.artifact
                };
            }
        }
        class ToolMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.$k {
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "tool_call_id", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "status", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "artifact", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.tool_call_id = fields.tool_call_id;
                this.artifact = fields.artifact;
                this.status = fields.status;
            }
            static lc_name() {
                return "ToolMessageChunk";
            }
            _getType() {
                return "tool";
            }
            concat(chunk) {
                return new ToolMessageChunk({
                    content: (0, _base_js__WEBPACK_IMPORTED_MODULE_0__.Wf)(this.content, chunk.content),
                    additional_kwargs: (0, _base_js__WEBPACK_IMPORTED_MODULE_0__.wv)(this.additional_kwargs, chunk.additional_kwargs),
                    response_metadata: (0, _base_js__WEBPACK_IMPORTED_MODULE_0__.wv)(this.response_metadata, chunk.response_metadata),
                    artifact: (0, _base_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.artifact, chunk.artifact),
                    tool_call_id: this.tool_call_id,
                    id: this.id ?? chunk.id,
                    status: (0, _base_js__WEBPACK_IMPORTED_MODULE_0__.n4)(this.status, chunk.status)
                });
            }
            get _printableFields() {
                return {
                    ...super._printableFields,
                    tool_call_id: this.tool_call_id,
                    artifact: this.artifact
                };
            }
        }
        function defaultToolCallParser(rawToolCalls) {
            const toolCalls = [];
            const invalidToolCalls = [];
            for (const toolCall of rawToolCalls)if (!!toolCall.function) {
                const functionName = toolCall.function.name;
                try {
                    const functionArgs = JSON.parse(toolCall.function.arguments);
                    const parsed = {
                        name: functionName || "",
                        args: functionArgs || {},
                        id: toolCall.id
                    };
                    toolCalls.push(parsed);
                } catch (error) {
                    invalidToolCalls.push({
                        name: functionName,
                        args: toolCall.function.arguments,
                        id: toolCall.id,
                        error: "Malformed args."
                    });
                }
            }
            return [
                toolCalls,
                invalidToolCalls
            ];
        }
    },
    "../../../../node_modules/@langchain/core/dist/messages/utils.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            E1: ()=>coerceMessageLikeToMessage,
            zs: ()=>getBufferString
        });
        var _errors_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/errors/index.js");
        var _tools_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/tools/utils.js");
        var _ai_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/ai.js");
        var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/base.js");
        __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/chat.js");
        __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/function.js");
        var _human_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/human.js");
        var _system_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/system.js");
        var _tool_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/tool.js");
        function _coerceToolCall(toolCall) {
            if ((0, _tools_utils_js__WEBPACK_IMPORTED_MODULE_1__.u)(toolCall)) return toolCall;
            if ("string" == typeof toolCall.id && "function" === toolCall.type && "object" == typeof toolCall.function && null !== toolCall.function && "arguments" in toolCall.function && "string" == typeof toolCall.function.arguments && "name" in toolCall.function && "string" == typeof toolCall.function.name) return {
                id: toolCall.id,
                args: JSON.parse(toolCall.function.arguments),
                name: toolCall.function.name,
                type: "tool_call"
            };
            return toolCall;
        }
        function isSerializedConstructor(x) {
            return "object" == typeof x && null != x && 1 === x.lc && Array.isArray(x.id) && null != x.kwargs && "object" == typeof x.kwargs;
        }
        function _constructMessageFromParams(params) {
            let type;
            let rest;
            if (isSerializedConstructor(params)) {
                const className = params.id.at(-1);
                type = "HumanMessage" === className || "HumanMessageChunk" === className ? "user" : "AIMessage" === className || "AIMessageChunk" === className ? "assistant" : "SystemMessage" === className || "SystemMessageChunk" === className ? "system" : "FunctionMessage" === className || "FunctionMessageChunk" === className ? "function" : "ToolMessage" === className || "ToolMessageChunk" === className ? "tool" : "unknown";
                rest = params.kwargs;
            } else {
                const { type: extractedType, ...otherParams } = params;
                type = extractedType;
                rest = otherParams;
            }
            if ("human" === type || "user" === type) return new _human_js__WEBPACK_IMPORTED_MODULE_6__.xk(rest);
            if ("ai" === type || "assistant" === type) {
                const { tool_calls: rawToolCalls, ...other } = rest;
                if (!Array.isArray(rawToolCalls)) return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.gY(rest);
                const tool_calls = rawToolCalls.map(_coerceToolCall);
                return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.gY({
                    ...other,
                    tool_calls
                });
            }
            if ("system" === type) return new _system_js__WEBPACK_IMPORTED_MODULE_7__.jN(rest);
            {
                if ("developer" === type) return new _system_js__WEBPACK_IMPORTED_MODULE_7__.jN({
                    ...rest,
                    additional_kwargs: {
                        ...rest.additional_kwargs,
                        __openai_role__: "developer"
                    }
                });
                if ("tool" === type && "tool_call_id" in rest) return new _tool_js__WEBPACK_IMPORTED_MODULE_8__.Cq({
                    ...rest,
                    content: rest.content,
                    tool_call_id: rest.tool_call_id,
                    name: rest.name
                });
                const error = (0, _errors_index_js__WEBPACK_IMPORTED_MODULE_0__.r)(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\n\nReceived: ${JSON.stringify(params, null, 2)}`), "MESSAGE_COERCION_FAILURE");
                throw error;
            }
        }
        function coerceMessageLikeToMessage(messageLike) {
            if ("string" == typeof messageLike) return new _human_js__WEBPACK_IMPORTED_MODULE_6__.xk(messageLike);
            if ((0, _base_js__WEBPACK_IMPORTED_MODULE_3__.QW)(messageLike)) return messageLike;
            if (Array.isArray(messageLike)) {
                const [type, content] = messageLike;
                return _constructMessageFromParams({
                    type,
                    content
                });
            }
            if (!(0, _base_js__WEBPACK_IMPORTED_MODULE_3__.gQ)(messageLike)) return _constructMessageFromParams(messageLike);
            {
                const { role: type, ...rest } = messageLike;
                return _constructMessageFromParams({
                    ...rest,
                    type
                });
            }
        }
        function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
            const string_messages = [];
            for (const m of messages){
                let role;
                if ("human" === m._getType()) role = humanPrefix;
                else if ("ai" === m._getType()) role = aiPrefix;
                else if ("system" === m._getType()) role = "System";
                else if ("function" === m._getType()) role = "Function";
                else if ("tool" === m._getType()) role = "Tool";
                else if ("generic" === m._getType()) role = m.role;
                else throw new Error(`Got unsupported message type: ${m._getType()}`);
                const nameStr = m.name ? `${m.name}, ` : "";
                const readableContent = "string" == typeof m.content ? m.content : JSON.stringify(m.content, null, 2);
                string_messages.push(`${role}: ${nameStr}${readableContent}`);
            }
            return string_messages.join("\n");
        }
    },
    "../../../../node_modules/@langchain/core/dist/prompt_values.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            GU: ()=>ChatPromptValue,
            Nn: ()=>ImagePromptValue,
            nw: ()=>StringPromptValue
        });
        var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/load/serializable.js");
        var _messages_human_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/human.js");
        var _messages_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/utils.js");
        class BasePromptValue extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.i {
        }
        class StringPromptValue extends BasePromptValue {
            static lc_name() {
                return "StringPromptValue";
            }
            constructor(value){
                super({
                    value
                });
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "prompt_values"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "value", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.value = value;
            }
            toString() {
                return this.value;
            }
            toChatMessages() {
                return [
                    new _messages_human_js__WEBPACK_IMPORTED_MODULE_1__.xk(this.value)
                ];
            }
        }
        class ChatPromptValue extends BasePromptValue {
            static lc_name() {
                return "ChatPromptValue";
            }
            constructor(fields){
                if (Array.isArray(fields)) fields = {
                    messages: fields
                };
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "prompt_values"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "messages", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.messages = fields.messages;
            }
            toString() {
                return (0, _messages_utils_js__WEBPACK_IMPORTED_MODULE_2__.zs)(this.messages);
            }
            toChatMessages() {
                return this.messages;
            }
        }
        class ImagePromptValue extends BasePromptValue {
            static lc_name() {
                return "ImagePromptValue";
            }
            constructor(fields){
                if (!("imageUrl" in fields)) fields = {
                    imageUrl: fields
                };
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "prompt_values"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "imageUrl", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "value", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.imageUrl = fields.imageUrl;
            }
            toString() {
                return this.imageUrl.url;
            }
            toChatMessages() {
                return [
                    new _messages_human_js__WEBPACK_IMPORTED_MODULE_1__.xk({
                        content: [
                            {
                                type: "image_url",
                                image_url: {
                                    detail: this.imageUrl.detail,
                                    url: this.imageUrl.url
                                }
                            }
                        ]
                    })
                ];
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/prompts/base.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            d: ()=>BasePromptTemplate
        });
        var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/runnables/base.js");
        class BasePromptTemplate extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.eq {
            get lc_attributes() {
                return {
                    partialVariables: void 0
                };
            }
            constructor(input){
                super(input);
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "prompts",
                        this._getPromptType()
                    ]
                });
                Object.defineProperty(this, "inputVariables", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "outputParser", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "partialVariables", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "metadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "tags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                const { inputVariables } = input;
                if (inputVariables.includes("stop")) throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");
                Object.assign(this, input);
            }
            async mergePartialAndUserVariables(userVariables) {
                const partialVariables = this.partialVariables ?? {};
                const partialValues = {};
                for (const [key, value] of Object.entries(partialVariables))if ("string" == typeof value) partialValues[key] = value;
                else partialValues[key] = await value();
                const allKwargs = {
                    ...partialValues,
                    ...userVariables
                };
                return allKwargs;
            }
            async invoke(input, options) {
                const metadata = {
                    ...this.metadata,
                    ...options?.metadata
                };
                const tags = [
                    ...this.tags ?? [],
                    ...options?.tags ?? []
                ];
                return this._callWithConfig((input)=>this.formatPromptValue(input), input, {
                    ...options,
                    tags,
                    metadata,
                    runType: "prompt"
                });
            }
            serialize() {
                throw new Error("Use .toJSON() instead");
            }
            static async deserialize(data) {
                switch(data._type){
                    case "prompt":
                        {
                            const { PromptTemplate } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../../../node_modules/@langchain/core/dist/prompts/prompt.js"));
                            return PromptTemplate.deserialize(data);
                        }
                    case void 0:
                        {
                            const { PromptTemplate } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../../../node_modules/@langchain/core/dist/prompts/prompt.js"));
                            return PromptTemplate.deserialize({
                                ...data,
                                _type: "prompt"
                            });
                        }
                    case "few_shot":
                        {
                            const { FewShotPromptTemplate } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../../../node_modules/@langchain/core/dist/prompts/few_shot.js"));
                            return FewShotPromptTemplate.deserialize(data);
                        }
                    default:
                        throw new Error(`Invalid prompt type in config: ${data._type}`);
                }
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/prompts/chat.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            S: ()=>BaseChatPromptTemplate,
            ks: ()=>ChatPromptTemplate
        });
        var _messages_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/index.js");
        var _prompt_values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompt_values.js");
        var _runnables_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/runnables/base.js");
        var _string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/string.js");
        var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/base.js");
        var _prompt_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/prompt.js");
        var _image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/image.js");
        var _template_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/template.js");
        var _errors_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/errors/index.js");
        class BaseMessagePromptTemplate extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_2__.eq {
            constructor(){
                super(...arguments);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "prompts",
                        "chat"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
            }
            async invoke(input, options) {
                return this._callWithConfig((input)=>this.formatMessages(input), input, {
                    ...options,
                    runType: "prompt"
                });
            }
        }
        class MessagesPlaceholder extends BaseMessagePromptTemplate {
            static lc_name() {
                return "MessagesPlaceholder";
            }
            constructor(fields){
                if ("string" == typeof fields) fields = {
                    variableName: fields
                };
                super(fields);
                Object.defineProperty(this, "variableName", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "optional", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.variableName = fields.variableName;
                this.optional = fields.optional ?? false;
            }
            get inputVariables() {
                return [
                    this.variableName
                ];
            }
            async formatMessages(values) {
                const input = values[this.variableName];
                if (this.optional && !input) return [];
                if (!input) {
                    const error = new Error(`Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`);
                    error.name = "InputFormatError";
                    throw error;
                }
                let formattedMessages;
                try {
                    formattedMessages = Array.isArray(input) ? input.map(_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.E1) : [
                        (0, _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.E1)(input)
                    ];
                } catch (e) {
                    const readableInput = "string" == typeof input ? input : JSON.stringify(input, null, 2);
                    const error = new Error([
                        `Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,
                        `Received value: ${readableInput}`,
                        `Additional message: ${e.message}`
                    ].join("\n\n"));
                    error.name = "InputFormatError";
                    error.lc_error_code = e.lc_error_code;
                    throw error;
                }
                return formattedMessages;
            }
        }
        class BaseMessageStringPromptTemplate extends BaseMessagePromptTemplate {
            constructor(fields){
                if (!("prompt" in fields)) fields = {
                    prompt: fields
                };
                super(fields);
                Object.defineProperty(this, "prompt", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.prompt = fields.prompt;
            }
            get inputVariables() {
                return this.prompt.inputVariables;
            }
            async formatMessages(values) {
                return [
                    await this.format(values)
                ];
            }
        }
        class BaseChatPromptTemplate extends _base_js__WEBPACK_IMPORTED_MODULE_4__.d {
            constructor(input){
                super(input);
            }
            async format(values) {
                return (await this.formatPromptValue(values)).toString();
            }
            async formatPromptValue(values) {
                const resultMessages = await this.formatMessages(values);
                return new _prompt_values_js__WEBPACK_IMPORTED_MODULE_1__.GU(resultMessages);
            }
        }
        class ChatMessagePromptTemplate extends BaseMessageStringPromptTemplate {
            static lc_name() {
                return "ChatMessagePromptTemplate";
            }
            constructor(fields, role){
                if (!("prompt" in fields)) fields = {
                    prompt: fields,
                    role: role
                };
                super(fields);
                Object.defineProperty(this, "role", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.role = fields.role;
            }
            async format(values) {
                return new _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.J(await this.prompt.format(values), this.role);
            }
            static fromTemplate(template, role, options) {
                return new this(_prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(template, {
                    templateFormat: options?.templateFormat
                }), role);
            }
        }
        class _StringImageMessagePromptTemplate extends BaseMessagePromptTemplate {
            static _messageClass() {
                throw new Error("Can not invoke _messageClass from inside _StringImageMessagePromptTemplate");
            }
            constructor(fields, additionalOptions){
                if (!("prompt" in fields)) fields = {
                    prompt: fields
                };
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "prompts",
                        "chat"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "inputVariables", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "additionalOptions", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: {}
                });
                Object.defineProperty(this, "prompt", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "messageClass", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "chatMessageClass", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.prompt = fields.prompt;
                if (Array.isArray(this.prompt)) {
                    let inputVariables = [];
                    this.prompt.forEach((prompt)=>{
                        if ("inputVariables" in prompt) inputVariables = inputVariables.concat(prompt.inputVariables);
                    });
                    this.inputVariables = inputVariables;
                } else this.inputVariables = this.prompt.inputVariables;
                this.additionalOptions = additionalOptions ?? this.additionalOptions;
            }
            createMessage(content) {
                const constructor = this.constructor;
                if (constructor._messageClass()) {
                    const MsgClass = constructor._messageClass();
                    return new MsgClass({
                        content
                    });
                }
                if (constructor.chatMessageClass) {
                    const MsgClass = constructor.chatMessageClass();
                    return new MsgClass({
                        content,
                        role: this.getRoleFromMessageClass(MsgClass.lc_name())
                    });
                }
                throw new Error("No message class defined");
            }
            getRoleFromMessageClass(name) {
                switch(name){
                    case "HumanMessage":
                        return "human";
                    case "AIMessage":
                        return "ai";
                    case "SystemMessage":
                        return "system";
                    case "ChatMessage":
                        return "chat";
                    default:
                        throw new Error("Invalid message class name");
                }
            }
            static fromTemplate(template, additionalOptions) {
                if ("string" == typeof template) return new this(_prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(template, additionalOptions));
                const prompt = [];
                for (const item of template)if ("string" == typeof item || "object" == typeof item && "text" in item) {
                    let text = "";
                    if ("string" == typeof item) text = item;
                    else if ("string" == typeof item.text) text = item.text ?? "";
                    const options = {
                        ...additionalOptions,
                        ..."string" != typeof item ? {
                            additionalContentFields: item
                        } : {}
                    };
                    prompt.push(_prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(text, options));
                } else if ("object" == typeof item && "image_url" in item) {
                    let imgTemplate = item.image_url ?? "";
                    let imgTemplateObject;
                    let inputVariables = [];
                    if ("string" == typeof imgTemplate) {
                        let parsedTemplate;
                        parsedTemplate = additionalOptions?.templateFormat === "mustache" ? (0, _template_js__WEBPACK_IMPORTED_MODULE_7__.PZ)(imgTemplate) : (0, _template_js__WEBPACK_IMPORTED_MODULE_7__._O)(imgTemplate);
                        const variables = parsedTemplate.flatMap((item)=>"variable" === item.type ? [
                                item.name
                            ] : []);
                        if ((variables?.length ?? 0) > 0) {
                            if (variables.length > 1) throw new Error(`Only one format variable allowed per image template.\nGot: ${variables}\nFrom: ${imgTemplate}`);
                            inputVariables = [
                                variables[0]
                            ];
                        } else inputVariables = [];
                        imgTemplate = {
                            url: imgTemplate
                        };
                        imgTemplateObject = new _image_js__WEBPACK_IMPORTED_MODULE_6__.r({
                            template: imgTemplate,
                            inputVariables,
                            templateFormat: additionalOptions?.templateFormat,
                            additionalContentFields: item
                        });
                    } else if ("object" == typeof imgTemplate) {
                        if ("url" in imgTemplate) {
                            let parsedTemplate;
                            parsedTemplate = additionalOptions?.templateFormat === "mustache" ? (0, _template_js__WEBPACK_IMPORTED_MODULE_7__.PZ)(imgTemplate.url) : (0, _template_js__WEBPACK_IMPORTED_MODULE_7__._O)(imgTemplate.url);
                            inputVariables = parsedTemplate.flatMap((item)=>"variable" === item.type ? [
                                    item.name
                                ] : []);
                        } else inputVariables = [];
                        imgTemplateObject = new _image_js__WEBPACK_IMPORTED_MODULE_6__.r({
                            template: imgTemplate,
                            inputVariables,
                            templateFormat: additionalOptions?.templateFormat,
                            additionalContentFields: item
                        });
                    } else throw new Error("Invalid image template");
                    prompt.push(imgTemplateObject);
                }
                return new this({
                    prompt,
                    additionalOptions
                });
            }
            async format(input) {
                if (this.prompt instanceof _string_js__WEBPACK_IMPORTED_MODULE_3__.A) {
                    const text = await this.prompt.format(input);
                    return this.createMessage(text);
                }
                {
                    const content = [];
                    for (const prompt of this.prompt){
                        let inputs = {};
                        if (!("inputVariables" in prompt)) throw new Error(`Prompt ${prompt} does not have inputVariables defined.`);
                        for (const item of prompt.inputVariables){
                            if (!inputs) inputs = {
                                [item]: input[item]
                            };
                            inputs = {
                                ...inputs,
                                [item]: input[item]
                            };
                        }
                        if (prompt instanceof _string_js__WEBPACK_IMPORTED_MODULE_3__.A) {
                            const formatted = await prompt.format(inputs);
                            let additionalContentFields;
                            if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
                            content.push({
                                ...additionalContentFields,
                                type: "text",
                                text: formatted
                            });
                        } else if (prompt instanceof _image_js__WEBPACK_IMPORTED_MODULE_6__.r) {
                            const formatted = await prompt.format(inputs);
                            let additionalContentFields;
                            if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
                            content.push({
                                ...additionalContentFields,
                                type: "image_url",
                                image_url: formatted
                            });
                        }
                    }
                    return this.createMessage(content);
                }
            }
            async formatMessages(values) {
                return [
                    await this.format(values)
                ];
            }
        }
        class HumanMessagePromptTemplate extends _StringImageMessagePromptTemplate {
            static _messageClass() {
                return _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.xk;
            }
            static lc_name() {
                return "HumanMessagePromptTemplate";
            }
        }
        class AIMessagePromptTemplate extends _StringImageMessagePromptTemplate {
            static _messageClass() {
                return _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.gY;
            }
            static lc_name() {
                return "AIMessagePromptTemplate";
            }
        }
        class SystemMessagePromptTemplate extends _StringImageMessagePromptTemplate {
            static _messageClass() {
                return _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.jN;
            }
            static lc_name() {
                return "SystemMessagePromptTemplate";
            }
        }
        function _isBaseMessagePromptTemplate(baseMessagePromptTemplateLike) {
            return "function" == typeof baseMessagePromptTemplateLike.formatMessages;
        }
        function _coerceMessagePromptTemplateLike(messagePromptTemplateLike, extra) {
            if (_isBaseMessagePromptTemplate(messagePromptTemplateLike) || (0, _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.QW)(messagePromptTemplateLike)) return messagePromptTemplateLike;
            if (Array.isArray(messagePromptTemplateLike) && "placeholder" === messagePromptTemplateLike[0]) {
                const messageContent = messagePromptTemplateLike[1];
                if (extra?.templateFormat === "mustache" && "string" == typeof messageContent && "{{" === messageContent.slice(0, 2) && "}}" === messageContent.slice(-2)) {
                    const variableName = messageContent.slice(2, -2);
                    return new MessagesPlaceholder({
                        variableName,
                        optional: true
                    });
                }
                if ("string" == typeof messageContent && "{" === messageContent[0] && "}" === messageContent[messageContent.length - 1]) {
                    const variableName = messageContent.slice(1, -1);
                    return new MessagesPlaceholder({
                        variableName,
                        optional: true
                    });
                }
                throw new Error(`Invalid placeholder template for format ${extra?.templateFormat ?? '"f-string"'}: "${messagePromptTemplateLike[1]}". Expected a variable name surrounded by ${extra?.templateFormat === "mustache" ? "double" : "single"} curly braces.`);
            }
            const message = (0, _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.E1)(messagePromptTemplateLike);
            let templateData;
            templateData = "string" == typeof message.content ? message.content : message.content.map((item)=>{
                if ("text" in item) return {
                    ...item,
                    text: item.text
                };
                if ("image_url" in item) return {
                    ...item,
                    image_url: item.image_url
                };
                return item;
            });
            if ("human" === message._getType()) return HumanMessagePromptTemplate.fromTemplate(templateData, extra);
            if ("ai" === message._getType()) return AIMessagePromptTemplate.fromTemplate(templateData, extra);
            if ("system" === message._getType()) return SystemMessagePromptTemplate.fromTemplate(templateData, extra);
            if (_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.J.isInstance(message)) return ChatMessagePromptTemplate.fromTemplate(message.content, message.role, extra);
            throw new Error(`Could not coerce message prompt template from input. Received message type: "${message._getType()}".`);
        }
        function isMessagesPlaceholder(x) {
            return "MessagesPlaceholder" === x.constructor.lc_name();
        }
        class ChatPromptTemplate extends BaseChatPromptTemplate {
            static lc_name() {
                return "ChatPromptTemplate";
            }
            get lc_aliases() {
                return {
                    promptMessages: "messages"
                };
            }
            constructor(input){
                super(input);
                Object.defineProperty(this, "promptMessages", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "validateTemplate", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "templateFormat", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "f-string"
                });
                if ("mustache" === input.templateFormat && void 0 === input.validateTemplate) this.validateTemplate = false;
                Object.assign(this, input);
                if (this.validateTemplate) {
                    const inputVariablesMessages = new Set();
                    for (const promptMessage of this.promptMessages)if (!(promptMessage instanceof _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ku)) for (const inputVariable of promptMessage.inputVariables)inputVariablesMessages.add(inputVariable);
                    const totalInputVariables = this.inputVariables;
                    const inputVariablesInstance = new Set(this.partialVariables ? totalInputVariables.concat(Object.keys(this.partialVariables)) : totalInputVariables);
                    const difference = new Set([
                        ...inputVariablesInstance
                    ].filter((x)=>!inputVariablesMessages.has(x)));
                    if (difference.size > 0) throw new Error(`Input variables \`${[
                        ...difference
                    ]}\` are not used in any of the prompt messages.`);
                    const otherDifference = new Set([
                        ...inputVariablesMessages
                    ].filter((x)=>!inputVariablesInstance.has(x)));
                    if (otherDifference.size > 0) throw new Error(`Input variables \`${[
                        ...otherDifference
                    ]}\` are used in prompt messages but not in the prompt template.`);
                }
            }
            _getPromptType() {
                return "chat";
            }
            async _parseImagePrompts(message, inputValues) {
                if ("string" == typeof message.content) return message;
                const formattedMessageContent = await Promise.all(message.content.map(async (item)=>{
                    if ("image_url" !== item.type) return item;
                    let imageUrl = "";
                    imageUrl = "string" == typeof item.image_url ? item.image_url : item.image_url.url;
                    const promptTemplatePlaceholder = _prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(imageUrl, {
                        templateFormat: this.templateFormat
                    });
                    const formattedUrl = await promptTemplatePlaceholder.format(inputValues);
                    if ("string" != typeof item.image_url && "url" in item.image_url) item.image_url.url = formattedUrl;
                    else item.image_url = formattedUrl;
                    return item;
                }));
                message.content = formattedMessageContent;
                return message;
            }
            async formatMessages(values) {
                const allValues = await this.mergePartialAndUserVariables(values);
                let resultMessages = [];
                for (const promptMessage of this.promptMessages)if (promptMessage instanceof _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ku) resultMessages.push(await this._parseImagePrompts(promptMessage, allValues));
                else {
                    const inputValues = promptMessage.inputVariables.reduce((acc, inputVariable)=>{
                        if (!(inputVariable in allValues) && !(isMessagesPlaceholder(promptMessage) && promptMessage.optional)) {
                            const error = (0, _errors_index_js__WEBPACK_IMPORTED_MODULE_8__.r)(new Error(`Missing value for input variable \`${inputVariable.toString()}\``), "INVALID_PROMPT_INPUT");
                            throw error;
                        }
                        acc[inputVariable] = allValues[inputVariable];
                        return acc;
                    }, {});
                    const message = await promptMessage.formatMessages(inputValues);
                    resultMessages = resultMessages.concat(message);
                }
                return resultMessages;
            }
            async partial(values) {
                const newInputVariables = this.inputVariables.filter((iv)=>!(iv in values));
                const newPartialVariables = {
                    ...this.partialVariables ?? {},
                    ...values
                };
                const promptDict = {
                    ...this,
                    inputVariables: newInputVariables,
                    partialVariables: newPartialVariables
                };
                return new ChatPromptTemplate(promptDict);
            }
            static fromTemplate(template, options) {
                const prompt = _prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(template, options);
                const humanTemplate = new HumanMessagePromptTemplate({
                    prompt
                });
                return this.fromMessages([
                    humanTemplate
                ]);
            }
            static fromMessages(promptMessages, extra) {
                const flattenedMessages = promptMessages.reduce((acc, promptMessage)=>acc.concat(promptMessage instanceof ChatPromptTemplate ? promptMessage.promptMessages : [
                        _coerceMessagePromptTemplateLike(promptMessage, extra)
                    ]), []);
                const flattenedPartialVariables = promptMessages.reduce((acc, promptMessage)=>promptMessage instanceof ChatPromptTemplate ? Object.assign(acc, promptMessage.partialVariables) : acc, Object.create(null));
                const inputVariables = new Set();
                for (const promptMessage of flattenedMessages)if (!(promptMessage instanceof _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ku)) {
                    for (const inputVariable of promptMessage.inputVariables)if (!(inputVariable in flattenedPartialVariables)) inputVariables.add(inputVariable);
                }
                return new this({
                    ...extra,
                    inputVariables: [
                        ...inputVariables
                    ],
                    promptMessages: flattenedMessages,
                    partialVariables: flattenedPartialVariables,
                    templateFormat: extra?.templateFormat
                });
            }
            static fromPromptMessages(promptMessages) {
                return this.fromMessages(promptMessages);
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/prompts/few_shot.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            FewShotPromptTemplate: ()=>FewShotPromptTemplate
        });
        var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/string.js");
        var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/template.js");
        var _prompt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/prompt.js");
        var _chat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/chat.js");
        class FewShotPromptTemplate extends _string_js__WEBPACK_IMPORTED_MODULE_0__.A {
            constructor(input){
                super(input);
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "examples", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "exampleSelector", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "examplePrompt", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "suffix", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: ""
                });
                Object.defineProperty(this, "exampleSeparator", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "\n\n"
                });
                Object.defineProperty(this, "prefix", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: ""
                });
                Object.defineProperty(this, "templateFormat", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "f-string"
                });
                Object.defineProperty(this, "validateTemplate", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.assign(this, input);
                if (void 0 !== this.examples && void 0 !== this.exampleSelector) throw new Error("Only one of 'examples' and 'example_selector' should be provided");
                if (void 0 === this.examples && void 0 === this.exampleSelector) throw new Error("One of 'examples' and 'example_selector' should be provided");
                if (this.validateTemplate) {
                    let totalInputVariables = this.inputVariables;
                    if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
                    (0, _template_js__WEBPACK_IMPORTED_MODULE_1__.af)(this.prefix + this.suffix, this.templateFormat, totalInputVariables);
                }
            }
            _getPromptType() {
                return "few_shot";
            }
            static lc_name() {
                return "FewShotPromptTemplate";
            }
            async getExamples(inputVariables) {
                if (void 0 !== this.examples) return this.examples;
                if (void 0 !== this.exampleSelector) return this.exampleSelector.selectExamples(inputVariables);
                throw new Error("One of 'examples' and 'example_selector' should be provided");
            }
            async partial(values) {
                const newInputVariables = this.inputVariables.filter((iv)=>!(iv in values));
                const newPartialVariables = {
                    ...this.partialVariables ?? {},
                    ...values
                };
                const promptDict = {
                    ...this,
                    inputVariables: newInputVariables,
                    partialVariables: newPartialVariables
                };
                return new FewShotPromptTemplate(promptDict);
            }
            async format(values) {
                const allValues = await this.mergePartialAndUserVariables(values);
                const examples = await this.getExamples(allValues);
                const exampleStrings = await Promise.all(examples.map((example)=>this.examplePrompt.format(example)));
                const template = [
                    this.prefix,
                    ...exampleStrings,
                    this.suffix
                ].join(this.exampleSeparator);
                return (0, _template_js__WEBPACK_IMPORTED_MODULE_1__.SM)(template, this.templateFormat, allValues);
            }
            serialize() {
                if (this.exampleSelector || !this.examples) throw new Error("Serializing an example selector is not currently supported");
                if (void 0 !== this.outputParser) throw new Error("Serializing an output parser is not currently supported");
                return {
                    _type: this._getPromptType(),
                    input_variables: this.inputVariables,
                    example_prompt: this.examplePrompt.serialize(),
                    example_separator: this.exampleSeparator,
                    suffix: this.suffix,
                    prefix: this.prefix,
                    template_format: this.templateFormat,
                    examples: this.examples
                };
            }
            static async deserialize(data) {
                const { example_prompt } = data;
                if (!example_prompt) throw new Error("Missing example prompt");
                const examplePrompt = await _prompt_js__WEBPACK_IMPORTED_MODULE_2__.PromptTemplate.deserialize(example_prompt);
                let examples;
                if (Array.isArray(data.examples)) examples = data.examples;
                else throw new Error("Invalid examples format. Only list or string are supported.");
                return new FewShotPromptTemplate({
                    inputVariables: data.input_variables,
                    examplePrompt,
                    examples,
                    exampleSeparator: data.example_separator,
                    prefix: data.prefix,
                    suffix: data.suffix,
                    templateFormat: data.template_format
                });
            }
        }
        class FewShotChatMessagePromptTemplate extends _chat_js__WEBPACK_IMPORTED_MODULE_3__.S {
            _getPromptType() {
                return "few_shot_chat";
            }
            static lc_name() {
                return "FewShotChatMessagePromptTemplate";
            }
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "examples", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "exampleSelector", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "examplePrompt", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "suffix", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: ""
                });
                Object.defineProperty(this, "exampleSeparator", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "\n\n"
                });
                Object.defineProperty(this, "prefix", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: ""
                });
                Object.defineProperty(this, "templateFormat", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "f-string"
                });
                Object.defineProperty(this, "validateTemplate", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                this.examples = fields.examples;
                this.examplePrompt = fields.examplePrompt;
                this.exampleSeparator = fields.exampleSeparator ?? "\n\n";
                this.exampleSelector = fields.exampleSelector;
                this.prefix = fields.prefix ?? "";
                this.suffix = fields.suffix ?? "";
                this.templateFormat = fields.templateFormat ?? "f-string";
                this.validateTemplate = fields.validateTemplate ?? true;
                if (void 0 !== this.examples && void 0 !== this.exampleSelector) throw new Error("Only one of 'examples' and 'example_selector' should be provided");
                if (void 0 === this.examples && void 0 === this.exampleSelector) throw new Error("One of 'examples' and 'example_selector' should be provided");
                if (this.validateTemplate) {
                    let totalInputVariables = this.inputVariables;
                    if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
                    (0, _template_js__WEBPACK_IMPORTED_MODULE_1__.af)(this.prefix + this.suffix, this.templateFormat, totalInputVariables);
                }
            }
            async getExamples(inputVariables) {
                if (void 0 !== this.examples) return this.examples;
                if (void 0 !== this.exampleSelector) return this.exampleSelector.selectExamples(inputVariables);
                throw new Error("One of 'examples' and 'example_selector' should be provided");
            }
            async formatMessages(values) {
                const allValues = await this.mergePartialAndUserVariables(values);
                let examples = await this.getExamples(allValues);
                examples = examples.map((example)=>{
                    const result = {};
                    this.examplePrompt.inputVariables.forEach((inputVariable)=>{
                        result[inputVariable] = example[inputVariable];
                    });
                    return result;
                });
                const messages = [];
                for (const example of examples){
                    const exampleMessages = await this.examplePrompt.formatMessages(example);
                    messages.push(...exampleMessages);
                }
                return messages;
            }
            async format(values) {
                const allValues = await this.mergePartialAndUserVariables(values);
                const examples = await this.getExamples(allValues);
                const exampleMessages = await Promise.all(examples.map((example)=>this.examplePrompt.formatMessages(example)));
                const exampleStrings = exampleMessages.flat().map((message)=>message.content);
                const template = [
                    this.prefix,
                    ...exampleStrings,
                    this.suffix
                ].join(this.exampleSeparator);
                return (0, _template_js__WEBPACK_IMPORTED_MODULE_1__.SM)(template, this.templateFormat, allValues);
            }
            async partial(values) {
                const newInputVariables = this.inputVariables.filter((variable)=>!(variable in values));
                const newPartialVariables = {
                    ...this.partialVariables ?? {},
                    ...values
                };
                const promptDict = {
                    ...this,
                    inputVariables: newInputVariables,
                    partialVariables: newPartialVariables
                };
                return new FewShotChatMessagePromptTemplate(promptDict);
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/prompts/image.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            r: ()=>ImagePromptTemplate
        });
        var _prompt_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompt_values.js");
        var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/base.js");
        var _template_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/template.js");
        class ImagePromptTemplate extends _base_js__WEBPACK_IMPORTED_MODULE_1__.d {
            static lc_name() {
                return "ImagePromptTemplate";
            }
            constructor(input){
                super(input);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "prompts",
                        "image"
                    ]
                });
                Object.defineProperty(this, "template", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "templateFormat", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "f-string"
                });
                Object.defineProperty(this, "validateTemplate", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "additionalContentFields", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.template = input.template;
                this.templateFormat = input.templateFormat ?? this.templateFormat;
                this.validateTemplate = input.validateTemplate ?? this.validateTemplate;
                this.additionalContentFields = input.additionalContentFields;
                if (this.validateTemplate) {
                    let totalInputVariables = this.inputVariables;
                    if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
                    (0, _template_js__WEBPACK_IMPORTED_MODULE_2__.af)([
                        {
                            type: "image_url",
                            image_url: this.template
                        }
                    ], this.templateFormat, totalInputVariables);
                }
            }
            _getPromptType() {
                return "prompt";
            }
            async partial(values) {
                const newInputVariables = this.inputVariables.filter((iv)=>!(iv in values));
                const newPartialVariables = {
                    ...this.partialVariables ?? {},
                    ...values
                };
                const promptDict = {
                    ...this,
                    inputVariables: newInputVariables,
                    partialVariables: newPartialVariables
                };
                return new ImagePromptTemplate(promptDict);
            }
            async format(values) {
                const formatted = {};
                for (const [key, value] of Object.entries(this.template))if ("string" == typeof value) formatted[key] = (0, _template_js__WEBPACK_IMPORTED_MODULE_2__.SM)(value, this.templateFormat, values);
                else formatted[key] = value;
                const url = values.url || formatted.url;
                const detail = values.detail || formatted.detail;
                if (!url) throw new Error("Must provide either an image URL.");
                if ("string" != typeof url) throw new Error("url must be a string.");
                const output = {
                    url
                };
                if (detail) output.detail = detail;
                return output;
            }
            async formatPromptValue(values) {
                const formattedPrompt = await this.format(values);
                return new _prompt_values_js__WEBPACK_IMPORTED_MODULE_0__.Nn(formattedPrompt);
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/prompts/prompt.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            PromptTemplate: ()=>PromptTemplate
        });
        var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/string.js");
        var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/template.js");
        class PromptTemplate extends _string_js__WEBPACK_IMPORTED_MODULE_0__.A {
            static lc_name() {
                return "PromptTemplate";
            }
            constructor(input){
                super(input);
                Object.defineProperty(this, "template", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "templateFormat", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "f-string"
                });
                Object.defineProperty(this, "validateTemplate", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "additionalContentFields", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                if ("mustache" === input.templateFormat && void 0 === input.validateTemplate) this.validateTemplate = false;
                Object.assign(this, input);
                if (this.validateTemplate) {
                    if ("mustache" === this.templateFormat) throw new Error("Mustache templates cannot be validated.");
                    let totalInputVariables = this.inputVariables;
                    if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
                    (0, _template_js__WEBPACK_IMPORTED_MODULE_1__.af)(this.template, this.templateFormat, totalInputVariables);
                }
            }
            _getPromptType() {
                return "prompt";
            }
            async format(values) {
                const allValues = await this.mergePartialAndUserVariables(values);
                return (0, _template_js__WEBPACK_IMPORTED_MODULE_1__.SM)(this.template, this.templateFormat, allValues);
            }
            static fromExamples(examples, suffix, inputVariables, exampleSeparator = "\n\n", prefix = "") {
                const template = [
                    prefix,
                    ...examples,
                    suffix
                ].join(exampleSeparator);
                return new PromptTemplate({
                    inputVariables,
                    template
                });
            }
            static fromTemplate(template, options) {
                const { templateFormat = "f-string", ...rest } = options ?? {};
                const names = new Set();
                (0, _template_js__WEBPACK_IMPORTED_MODULE_1__.$M)(template, templateFormat).forEach((node)=>{
                    if ("variable" === node.type) names.add(node.name);
                });
                return new PromptTemplate({
                    inputVariables: [
                        ...names
                    ],
                    templateFormat,
                    template,
                    ...rest
                });
            }
            async partial(values) {
                const newInputVariables = this.inputVariables.filter((iv)=>!(iv in values));
                const newPartialVariables = {
                    ...this.partialVariables ?? {},
                    ...values
                };
                const promptDict = {
                    ...this,
                    inputVariables: newInputVariables,
                    partialVariables: newPartialVariables
                };
                return new PromptTemplate(promptDict);
            }
            serialize() {
                if (void 0 !== this.outputParser) throw new Error("Cannot serialize a prompt template with an output parser");
                return {
                    _type: this._getPromptType(),
                    input_variables: this.inputVariables,
                    template: this.template,
                    template_format: this.templateFormat
                };
            }
            static async deserialize(data) {
                if (!data.template) throw new Error("Prompt template must have a template");
                const res = new PromptTemplate({
                    inputVariables: data.input_variables,
                    template: data.template,
                    templateFormat: data.template_format
                });
                return res;
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/prompts/string.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            A: ()=>BaseStringPromptTemplate
        });
        var _prompt_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompt_values.js");
        var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/base.js");
        class BaseStringPromptTemplate extends _base_js__WEBPACK_IMPORTED_MODULE_1__.d {
            async formatPromptValue(values) {
                const formattedPrompt = await this.format(values);
                return new _prompt_values_js__WEBPACK_IMPORTED_MODULE_0__.nw(formattedPrompt);
            }
        }
    },
    "../../../../node_modules/@langchain/core/dist/prompts/template.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            af: ()=>checkValidTemplate,
            _O: ()=>parseFString,
            $M: ()=>template_parseTemplate,
            SM: ()=>renderTemplate,
            PZ: ()=>parseMustache
        });
        /*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */ var objectToString = Object.prototype.toString;
        var isArray = Array.isArray || function(object) {
            return '[object Array]' === objectToString.call(object);
        };
        function isFunction(object) {
            return 'function' == typeof object;
        }
        function typeStr(obj) {
            return isArray(obj) ? 'array' : typeof obj;
        }
        function escapeRegExp(string) {
            return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
        }
        function hasProperty(obj, propName) {
            return null != obj && 'object' == typeof obj && propName in obj;
        }
        function primitiveHasOwnProperty(primitive, propName) {
            return null != primitive && 'object' != typeof primitive && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
        }
        var regExpTest = RegExp.prototype.test;
        function testRegExp(re, string) {
            return regExpTest.call(re, string);
        }
        var nonSpaceRe = /\S/;
        function isWhitespace(string) {
            return !testRegExp(nonSpaceRe, string);
        }
        var entityMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '/': '&#x2F;',
            '`': '&#x60;',
            '=': '&#x3D;'
        };
        function escapeHtml(string) {
            return String(string).replace(/[&<>"'`=\/]/g, function(s) {
                return entityMap[s];
            });
        }
        var whiteRe = /\s*/;
        var spaceRe = /\s+/;
        var equalsRe = /\s*=/;
        var curlyRe = /\s*\}/;
        var tagRe = /#|\^|\/|>|\{|&|=|!/;
        function parseTemplate(template, tags) {
            if (!template) return [];
            var lineHasNonSpace = false;
            var sections = [];
            var tokens = [];
            var spaces = [];
            var hasTag = false;
            var nonSpace = false;
            var indentation = '';
            var tagIndex = 0;
            function stripSpace() {
                if (hasTag && !nonSpace) while(spaces.length)delete tokens[spaces.pop()];
                else spaces = [];
                hasTag = false;
                nonSpace = false;
            }
            var openingTagRe, closingTagRe, closingCurlyRe;
            function compileTags(tagsToCompile) {
                if ('string' == typeof tagsToCompile) tagsToCompile = tagsToCompile.split(spaceRe, 2);
                if (!isArray(tagsToCompile) || 2 !== tagsToCompile.length) throw new Error('Invalid tags: ' + tagsToCompile);
                openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
                closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
                closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
            }
            compileTags(tags || mustache.tags);
            var scanner = new Scanner(template);
            var start, type, value, chr, token, openSection;
            while(!scanner.eos()){
                start = scanner.pos;
                value = scanner.scanUntil(openingTagRe);
                if (value) for(var i = 0, valueLength = value.length; i < valueLength; ++i){
                    chr = value.charAt(i);
                    if (isWhitespace(chr)) {
                        spaces.push(tokens.length);
                        indentation += chr;
                    } else {
                        nonSpace = true;
                        lineHasNonSpace = true;
                        indentation += ' ';
                    }
                    tokens.push([
                        'text',
                        chr,
                        start,
                        start + 1
                    ]);
                    start += 1;
                    if ('\n' === chr) {
                        stripSpace();
                        indentation = '';
                        tagIndex = 0;
                        lineHasNonSpace = false;
                    }
                }
                if (!scanner.scan(openingTagRe)) break;
                hasTag = true;
                type = scanner.scan(tagRe) || 'name';
                scanner.scan(whiteRe);
                if ('=' === type) {
                    value = scanner.scanUntil(equalsRe);
                    scanner.scan(equalsRe);
                    scanner.scanUntil(closingTagRe);
                } else if ('{' === type) {
                    value = scanner.scanUntil(closingCurlyRe);
                    scanner.scan(curlyRe);
                    scanner.scanUntil(closingTagRe);
                    type = '&';
                } else value = scanner.scanUntil(closingTagRe);
                if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);
                token = '>' == type ? [
                    type,
                    value,
                    start,
                    scanner.pos,
                    indentation,
                    tagIndex,
                    lineHasNonSpace
                ] : [
                    type,
                    value,
                    start,
                    scanner.pos
                ];
                tagIndex++;
                tokens.push(token);
                if ('#' === type || '^' === type) sections.push(token);
                else if ('/' === type) {
                    openSection = sections.pop();
                    if (!openSection) throw new Error('Unopened section "' + value + '" at ' + start);
                    if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
                } else if ('name' === type || '{' === type || '&' === type) nonSpace = true;
                else if ('=' === type) compileTags(value);
            }
            stripSpace();
            openSection = sections.pop();
            if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
            return nestTokens(squashTokens(tokens));
        }
        function squashTokens(tokens) {
            var squashedTokens = [];
            var token, lastToken;
            for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){
                token = tokens[i];
                if (token) {
                    if ('text' === token[0] && lastToken && 'text' === lastToken[0]) {
                        lastToken[1] += token[1];
                        lastToken[3] = token[3];
                    } else {
                        squashedTokens.push(token);
                        lastToken = token;
                    }
                }
            }
            return squashedTokens;
        }
        function nestTokens(tokens) {
            var nestedTokens = [];
            var collector = nestedTokens;
            var sections = [];
            var token, section;
            for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){
                token = tokens[i];
                switch(token[0]){
                    case '#':
                    case '^':
                        collector.push(token);
                        sections.push(token);
                        collector = token[4] = [];
                        break;
                    case '/':
                        section = sections.pop();
                        section[5] = token[2];
                        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
                        break;
                    default:
                        collector.push(token);
                }
            }
            return nestedTokens;
        }
        function Scanner(string) {
            this.string = string;
            this.tail = string;
            this.pos = 0;
        }
        Scanner.prototype.eos = function() {
            return '' === this.tail;
        };
        Scanner.prototype.scan = function(re) {
            var match = this.tail.match(re);
            if (!match || 0 !== match.index) return '';
            var string = match[0];
            this.tail = this.tail.substring(string.length);
            this.pos += string.length;
            return string;
        };
        Scanner.prototype.scanUntil = function(re) {
            var index = this.tail.search(re), match;
            switch(index){
                case -1:
                    match = this.tail;
                    this.tail = '';
                    break;
                case 0:
                    match = '';
                    break;
                default:
                    match = this.tail.substring(0, index);
                    this.tail = this.tail.substring(index);
            }
            this.pos += match.length;
            return match;
        };
        function Context(view, parentContext) {
            this.view = view;
            this.cache = {
                '.': this.view
            };
            this.parent = parentContext;
        }
        Context.prototype.push = function(view) {
            return new Context(view, this);
        };
        Context.prototype.lookup = function(name) {
            var cache1 = this.cache;
            var value;
            if (cache1.hasOwnProperty(name)) value = cache1[name];
            else {
                var context = this, intermediateValue, names, index, lookupHit = false;
                while(context){
                    if (name.indexOf('.') > 0) {
                        intermediateValue = context.view;
                        names = name.split('.');
                        index = 0;
                        while(null != intermediateValue && index < names.length){
                            if (index === names.length - 1) lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                            intermediateValue = intermediateValue[names[index++]];
                        }
                    } else {
                        intermediateValue = context.view[name];
                        lookupHit = hasProperty(context.view, name);
                    }
                    if (lookupHit) {
                        value = intermediateValue;
                        break;
                    }
                    context = context.parent;
                }
                cache1[name] = value;
            }
            if (isFunction(value)) value = value.call(this.view);
            return value;
        };
        function Writer() {
            this.templateCache = {
                _cache: {},
                set: function(key, value) {
                    this._cache[key] = value;
                },
                get: function(key) {
                    return this._cache[key];
                },
                clear: function() {
                    this._cache = {};
                }
            };
        }
        Writer.prototype.clearCache = function() {
            if (void 0 !== this.templateCache) this.templateCache.clear();
        };
        Writer.prototype.parse = function(template, tags) {
            var cache1 = this.templateCache;
            var cacheKey = template + ':' + (tags || mustache.tags).join(':');
            var isCacheEnabled = void 0 !== cache1;
            var tokens = isCacheEnabled ? cache1.get(cacheKey) : void 0;
            if (void 0 == tokens) {
                tokens = parseTemplate(template, tags);
                isCacheEnabled && cache1.set(cacheKey, tokens);
            }
            return tokens;
        };
        Writer.prototype.render = function(template, view, partials, config) {
            var tags = this.getConfigTags(config);
            var tokens = this.parse(template, tags);
            var context = view instanceof Context ? view : new Context(view, void 0);
            return this.renderTokens(tokens, context, partials, template, config);
        };
        Writer.prototype.renderTokens = function(tokens, context, partials, originalTemplate, config) {
            var buffer = '';
            var token, symbol, value;
            for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){
                value = void 0;
                token = tokens[i];
                symbol = token[0];
                if ('#' === symbol) value = this.renderSection(token, context, partials, originalTemplate, config);
                else if ('^' === symbol) value = this.renderInverted(token, context, partials, originalTemplate, config);
                else if ('>' === symbol) value = this.renderPartial(token, context, partials, config);
                else if ('&' === symbol) value = this.unescapedValue(token, context);
                else if ('name' === symbol) value = this.escapedValue(token, context, config);
                else if ('text' === symbol) value = this.rawValue(token);
                if (void 0 !== value) buffer += value;
            }
            return buffer;
        };
        Writer.prototype.renderSection = function(token, context, partials, originalTemplate, config) {
            var self1 = this;
            var buffer = '';
            var value = context.lookup(token[1]);
            function subRender(template) {
                return self1.render(template, context, partials, config);
            }
            if (!value) return;
            if (isArray(value)) for(var j = 0, valueLength = value.length; j < valueLength; ++j)buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
            else if ('object' == typeof value || 'string' == typeof value || 'number' == typeof value) buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
            else if (isFunction(value)) {
                if ('string' != typeof originalTemplate) throw new Error('Cannot use higher-order sections without the original template');
                value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
                if (null != value) buffer += value;
            } else buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
            return buffer;
        };
        Writer.prototype.renderInverted = function(token, context, partials, originalTemplate, config) {
            var value = context.lookup(token[1]);
            if (!value || isArray(value) && 0 === value.length) return this.renderTokens(token[4], context, partials, originalTemplate, config);
        };
        Writer.prototype.indentPartial = function(partial, indentation, lineHasNonSpace) {
            var filteredIndentation = indentation.replace(/[^ \t]/g, '');
            var partialByNl = partial.split('\n');
            for(var i = 0; i < partialByNl.length; i++)if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) partialByNl[i] = filteredIndentation + partialByNl[i];
            return partialByNl.join('\n');
        };
        Writer.prototype.renderPartial = function(token, context, partials, config) {
            if (!partials) return;
            var tags = this.getConfigTags(config);
            var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
            if (null != value) {
                var lineHasNonSpace = token[6];
                var tagIndex = token[5];
                var indentation = token[4];
                var indentedValue = value;
                if (0 == tagIndex && indentation) indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
                var tokens = this.parse(indentedValue, tags);
                return this.renderTokens(tokens, context, partials, indentedValue, config);
            }
        };
        Writer.prototype.unescapedValue = function(token, context) {
            var value = context.lookup(token[1]);
            if (null != value) return value;
        };
        Writer.prototype.escapedValue = function(token, context, config) {
            var escape = this.getConfigEscape(config) || mustache.escape;
            var value = context.lookup(token[1]);
            if (null != value) return 'number' == typeof value && escape === mustache.escape ? String(value) : escape(value);
        };
        Writer.prototype.rawValue = function(token) {
            return token[1];
        };
        Writer.prototype.getConfigTags = function(config) {
            if (isArray(config)) return config;
            if (config && 'object' == typeof config) return config.tags;
        };
        Writer.prototype.getConfigEscape = function(config) {
            if (config && 'object' == typeof config && !isArray(config)) return config.escape;
        };
        var mustache = {
            name: 'mustache.js',
            version: '4.2.0',
            tags: [
                '{{',
                '}}'
            ],
            clearCache: void 0,
            escape: void 0,
            parse: void 0,
            render: void 0,
            Scanner: void 0,
            Context: void 0,
            Writer: void 0,
            set templateCache (cache){
                defaultWriter.templateCache = cache;
            },
            get templateCache () {
                return defaultWriter.templateCache;
            }
        };
        var defaultWriter = new Writer();
        mustache.clearCache = function() {
            return defaultWriter.clearCache();
        };
        mustache.parse = function(template, tags) {
            return defaultWriter.parse(template, tags);
        };
        mustache.render = function(template, view, partials, config) {
            if ('string' != typeof template) throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
            return defaultWriter.render(template, view, partials, config);
        };
        mustache.escape = escapeHtml;
        mustache.Scanner = Scanner;
        mustache.Context = Context;
        mustache.Writer = Writer;
        const mustache_mustache = mustache;
        var errors = __webpack_require__("../../../../node_modules/@langchain/core/dist/errors/index.js");
        function configureMustache() {
            mustache_mustache.escape = (text)=>text;
        }
        const parseFString = (template)=>{
            const chars = template.split("");
            const nodes = [];
            const nextBracket = (bracket, start)=>{
                for(let i = start; i < chars.length; i += 1)if (bracket.includes(chars[i])) return i;
                return -1;
            };
            let i = 0;
            while(i < chars.length)if ("{" === chars[i] && i + 1 < chars.length && "{" === chars[i + 1]) {
                nodes.push({
                    type: "literal",
                    text: "{"
                });
                i += 2;
            } else if ("}" === chars[i] && i + 1 < chars.length && "}" === chars[i + 1]) {
                nodes.push({
                    type: "literal",
                    text: "}"
                });
                i += 2;
            } else if ("{" === chars[i]) {
                const j = nextBracket("}", i);
                if (j < 0) throw new Error("Unclosed '{' in template.");
                nodes.push({
                    type: "variable",
                    name: chars.slice(i + 1, j).join("")
                });
                i = j + 1;
            } else if ("}" === chars[i]) throw new Error("Single '}' in template.");
            else {
                const next = nextBracket("{}", i);
                const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join("");
                nodes.push({
                    type: "literal",
                    text
                });
                i = next < 0 ? chars.length : next;
            }
            return nodes;
        };
        const mustacheTemplateToNodes = (template)=>template.map((temp)=>{
                if ("name" === temp[0]) {
                    const name = temp[1].includes(".") ? temp[1].split(".")[0] : temp[1];
                    return {
                        type: "variable",
                        name
                    };
                }
                if ([
                    "#",
                    "&",
                    "^",
                    ">"
                ].includes(temp[0])) return {
                    type: "variable",
                    name: temp[1]
                };
                return {
                    type: "literal",
                    text: temp[1]
                };
            });
        const parseMustache = (template)=>{
            configureMustache();
            const parsed = mustache_mustache.parse(template);
            return mustacheTemplateToNodes(parsed);
        };
        const interpolateFString = (template, values)=>parseFString(template).reduce((res, node)=>{
                if ("variable" === node.type) {
                    if (node.name in values) {
                        const stringValue = "string" == typeof values[node.name] ? values[node.name] : JSON.stringify(values[node.name]);
                        return res + stringValue;
                    }
                    throw new Error(`(f-string) Missing value for input ${node.name}`);
                }
                return res + node.text;
            }, "");
        const interpolateMustache = (template, values)=>{
            configureMustache();
            return mustache_mustache.render(template, values);
        };
        const DEFAULT_FORMATTER_MAPPING = {
            "f-string": interpolateFString,
            mustache: interpolateMustache
        };
        const DEFAULT_PARSER_MAPPING = {
            "f-string": parseFString,
            mustache: parseMustache
        };
        const renderTemplate = (template, templateFormat, inputValues)=>{
            try {
                return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);
            } catch (e) {
                const error = (0, errors.r)(e, "INVALID_PROMPT_INPUT");
                throw error;
            }
        };
        const template_parseTemplate = (template, templateFormat)=>DEFAULT_PARSER_MAPPING[templateFormat](template);
        const checkValidTemplate = (template, templateFormat, inputVariables)=>{
            if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {
                const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);
                throw new Error(`Invalid template format. Got \`${templateFormat}\`;
                         should be one of ${validFormats}`);
            }
            try {
                const dummyInputs = inputVariables.reduce((acc, v)=>{
                    acc[v] = "foo";
                    return acc;
                }, {});
                if (Array.isArray(template)) template.forEach((message)=>{
                    if ("text" === message.type) renderTemplate(message.text, templateFormat, dummyInputs);
                    else if ("image_url" === message.type) {
                        if ("string" == typeof message.image_url) renderTemplate(message.image_url, templateFormat, dummyInputs);
                        else {
                            const imageUrl = message.image_url.url;
                            renderTemplate(imageUrl, templateFormat, dummyInputs);
                        }
                    } else throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);
                });
                else renderTemplate(template, templateFormat, dummyInputs);
            } catch (e) {
                throw new Error(`Invalid prompt schema: ${e.message}`);
            }
        };
    },
    "../../../../node_modules/@langchain/core/dist/runnables/base.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            eq: ()=>Runnable
        });
        var core_namespaceObject = {};
        __webpack_require__.r(core_namespaceObject);
        __webpack_require__.d(core_namespaceObject, {
            JsonPatchError: ()=>JsonPatchError,
            _areEquals: ()=>_areEquals,
            applyOperation: ()=>applyOperation,
            applyPatch: ()=>core_applyPatch,
            applyReducer: ()=>applyReducer,
            deepClone: ()=>deepClone,
            getValueByPointer: ()=>getValueByPointer,
            validate: ()=>core_validate,
            validator: ()=>validator
        });
        var lib = __webpack_require__("../../../../node_modules/zod/lib/index.mjs");
        var p_retry = __webpack_require__("../../../../node_modules/p-retry/index.js");
        const esm_node_native = {
            randomUUID: __WEBPACK_EXTERNAL_MODULE_node_crypto_9ba42079__["default"].randomUUID
        };
        const rnds8Pool = new Uint8Array(256);
        let poolPtr = rnds8Pool.length;
        function rng() {
            if (poolPtr > rnds8Pool.length - 16) {
                __WEBPACK_EXTERNAL_MODULE_node_crypto_9ba42079__["default"].randomFillSync(rnds8Pool);
                poolPtr = 0;
            }
            return rnds8Pool.slice(poolPtr, poolPtr += 16);
        }
        const byteToHex = [];
        for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
        function unsafeStringify(arr, offset = 0) {
            return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
        }
        function v4(options, buf, offset) {
            if (esm_node_native.randomUUID && !buf && !options) return esm_node_native.randomUUID();
            options = options || {};
            const rnds = options.random || (options.rng || rng)();
            rnds[6] = 0x0f & rnds[6] | 0x40;
            rnds[8] = 0x3f & rnds[8] | 0x80;
            if (buf) {
                offset = offset || 0;
                for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
                return buf;
            }
            return unsafeStringify(rnds);
        }
        const esm_node_v4 = v4;
        const dist_esm_node_native = {
            randomUUID: __WEBPACK_EXTERNAL_MODULE_node_crypto_9ba42079__["default"].randomUUID
        };
        const rng_rnds8Pool = new Uint8Array(256);
        let rng_poolPtr = rng_rnds8Pool.length;
        function rng_rng() {
            if (rng_poolPtr > rng_rnds8Pool.length - 16) {
                __WEBPACK_EXTERNAL_MODULE_node_crypto_9ba42079__["default"].randomFillSync(rng_rnds8Pool);
                rng_poolPtr = 0;
            }
            return rng_rnds8Pool.slice(rng_poolPtr, rng_poolPtr += 16);
        }
        const stringify_byteToHex = [];
        for(let i = 0; i < 256; ++i)stringify_byteToHex.push((i + 0x100).toString(16).slice(1));
        function stringify_unsafeStringify(arr, offset = 0) {
            return (stringify_byteToHex[arr[offset + 0]] + stringify_byteToHex[arr[offset + 1]] + stringify_byteToHex[arr[offset + 2]] + stringify_byteToHex[arr[offset + 3]] + '-' + stringify_byteToHex[arr[offset + 4]] + stringify_byteToHex[arr[offset + 5]] + '-' + stringify_byteToHex[arr[offset + 6]] + stringify_byteToHex[arr[offset + 7]] + '-' + stringify_byteToHex[arr[offset + 8]] + stringify_byteToHex[arr[offset + 9]] + '-' + stringify_byteToHex[arr[offset + 10]] + stringify_byteToHex[arr[offset + 11]] + stringify_byteToHex[arr[offset + 12]] + stringify_byteToHex[arr[offset + 13]] + stringify_byteToHex[arr[offset + 14]] + stringify_byteToHex[arr[offset + 15]]).toLowerCase();
        }
        function v4_v4(options, buf, offset) {
            if (dist_esm_node_native.randomUUID && !buf && !options) return dist_esm_node_native.randomUUID();
            options = options || {};
            const rnds = options.random || (options.rng || rng_rng)();
            rnds[6] = 0x0f & rnds[6] | 0x40;
            rnds[8] = 0x3f & rnds[8] | 0x80;
            if (buf) {
                offset = offset || 0;
                for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
                return buf;
            }
            return stringify_unsafeStringify(rnds);
        }
        const dist_esm_node_v4 = v4_v4;
        var dist = __webpack_require__("../../../../node_modules/p-queue/dist/index.js");
        const DEFAULT_FETCH_IMPLEMENTATION = (...args)=>fetch(...args);
        const LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
        const _getFetchImplementation = ()=>globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION;
        const STATUS_NO_RETRY = [
            400,
            401,
            403,
            404,
            405,
            406,
            407,
            408
        ];
        const STATUS_IGNORE = [
            409
        ];
        class AsyncCaller {
            constructor(params){
                Object.defineProperty(this, "maxConcurrency", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "maxRetries", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "queue", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "onFailedResponseHook", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.maxConcurrency = params.maxConcurrency ?? 1 / 0;
                this.maxRetries = params.maxRetries ?? 6;
                if ("default" in dist) this.queue = new dist["default"]({
                    concurrency: this.maxConcurrency
                });
                else this.queue = new dist({
                    concurrency: this.maxConcurrency
                });
                this.onFailedResponseHook = params?.onFailedResponseHook;
            }
            call(callable, ...args) {
                const onFailedResponseHook = this.onFailedResponseHook;
                return this.queue.add(()=>p_retry(()=>callable(...args).catch((error)=>{
                            if (error instanceof Error) throw error;
                            throw new Error(error);
                        }), {
                        async onFailedAttempt (error) {
                            if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.message.startsWith("AbortError")) throw error;
                            if (error?.code === "ECONNABORTED") throw error;
                            const response = error?.response;
                            const status = response?.status;
                            if (status) {
                                if (STATUS_NO_RETRY.includes(+status)) throw error;
                                if (STATUS_IGNORE.includes(+status)) return;
                                if (onFailedResponseHook) await onFailedResponseHook(response);
                            }
                        },
                        retries: this.maxRetries,
                        randomize: true
                    }), {
                    throwOnTimeout: true
                });
            }
            callWithOptions(options, callable, ...args) {
                if (options.signal) return Promise.race([
                    this.call(callable, ...args),
                    new Promise((_, reject)=>{
                        options.signal?.addEventListener("abort", ()=>{
                            reject(new Error("AbortError"));
                        });
                    })
                ]);
                return this.call(callable, ...args);
            }
            fetch(...args) {
                return this.call(()=>_getFetchImplementation()(...args).then((res)=>res.ok ? res : Promise.reject(res)));
            }
        }
        function isLangChainMessage(message) {
            return "function" == typeof message?._getType;
        }
        function convertLangChainMessageToExample(message) {
            const converted = {
                type: message._getType(),
                data: {
                    content: message.content
                }
            };
            if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) converted.data.additional_kwargs = {
                ...message.additional_kwargs
            };
            return converted;
        }
        const esm_node_regex = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
        function validate_validate(uuid) {
            return 'string' == typeof uuid && esm_node_regex.test(uuid);
        }
        const esm_node_validate = validate_validate;
        function assertUuid(str, which) {
            if (!esm_node_validate(str)) {
                const msg = void 0 !== which ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;
                throw new Error(msg);
            }
            return str;
        }
        const warnedMessages = {};
        function warnOnce(message) {
            if (!warnedMessages[message]) {
                console.warn(message);
                warnedMessages[message] = true;
            }
        }
        __webpack_require__("../../../../node_modules/semver/index.js");
        function parsePromptIdentifier(identifier) {
            if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) throw new Error(`Invalid identifier format: ${identifier}`);
            const [ownerNamePart, commitPart] = identifier.split(":");
            const commit = commitPart || "latest";
            if (ownerNamePart.includes("/")) {
                const [owner, name] = ownerNamePart.split("/", 2);
                if (!owner || !name) throw new Error(`Invalid identifier format: ${identifier}`);
                return [
                    owner,
                    name,
                    commit
                ];
            }
            if (!ownerNamePart) throw new Error(`Invalid identifier format: ${identifier}`);
            return [
                "-",
                ownerNamePart,
                commit
            ];
        }
        class LangSmithConflictError extends Error {
            constructor(message){
                super(message);
                this.name = "LangSmithConflictError";
            }
        }
        async function raiseForStatus(response, context, consume) {
            let errorBody;
            if (response.ok) {
                if (consume) errorBody = await response.text();
                return;
            }
            errorBody = await response.text();
            const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;
            if (409 === response.status) throw new LangSmithConflictError(fullMessage);
            throw new Error(fullMessage);
        }
        var LIMIT_REPLACE_NODE = "[...]";
        var CIRCULAR_REPLACE_NODE = {
            result: "[Circular]"
        };
        var fast_safe_stringify_arr = [];
        var replacerStack = [];
        const fast_safe_stringify_encoder = new TextEncoder();
        function defaultOptions() {
            return {
                depthLimit: Number.MAX_SAFE_INTEGER,
                edgesLimit: Number.MAX_SAFE_INTEGER
            };
        }
        function encodeString(str) {
            return fast_safe_stringify_encoder.encode(str);
        }
        function serialize(obj, replacer, spacer, options) {
            try {
                const str = JSON.stringify(obj, replacer, spacer);
                return encodeString(str);
            } catch (e) {
                if (!e.message?.includes("Converting circular structure to JSON")) {
                    console.warn("[WARNING]: LangSmith received unserializable value.");
                    return encodeString("[Unserializable]");
                }
                console.warn("[WARNING]: LangSmith received circular JSON. This will decrease tracer performance.");
                if (void 0 === options) options = defaultOptions();
                decirc(obj, "", 0, [], void 0, 0, options);
                let res;
                try {
                    res = 0 === replacerStack.length ? JSON.stringify(obj, replacer, spacer) : JSON.stringify(obj, replaceGetterValues(replacer), spacer);
                } catch (_) {
                    return encodeString("[unable to serialize, circular reference is too complex to analyze]");
                } finally{
                    while(0 !== fast_safe_stringify_arr.length){
                        const part = fast_safe_stringify_arr.pop();
                        if (4 === part.length) Object.defineProperty(part[0], part[1], part[3]);
                        else part[0][part[1]] = part[2];
                    }
                }
                return encodeString(res);
            }
        }
        function setReplace(replace, val, k, parent) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
            if (void 0 !== propertyDescriptor.get) {
                if (propertyDescriptor.configurable) {
                    Object.defineProperty(parent, k, {
                        value: replace
                    });
                    fast_safe_stringify_arr.push([
                        parent,
                        k,
                        val,
                        propertyDescriptor
                    ]);
                } else replacerStack.push([
                    val,
                    k,
                    replace
                ]);
            } else {
                parent[k] = replace;
                fast_safe_stringify_arr.push([
                    parent,
                    k,
                    val
                ]);
            }
        }
        function decirc(val, k, edgeIndex, stack, parent, depth, options) {
            depth += 1;
            var i;
            if ("object" == typeof val && null !== val) {
                for(i = 0; i < stack.length; i++)if (stack[i] === val) {
                    setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
                    return;
                }
                if (void 0 !== options.depthLimit && depth > options.depthLimit) {
                    setReplace(LIMIT_REPLACE_NODE, val, k, parent);
                    return;
                }
                if (void 0 !== options.edgesLimit && edgeIndex + 1 > options.edgesLimit) {
                    setReplace(LIMIT_REPLACE_NODE, val, k, parent);
                    return;
                }
                stack.push(val);
                if (Array.isArray(val)) for(i = 0; i < val.length; i++)decirc(val[i], i, i, stack, val, depth, options);
                else {
                    var keys = Object.keys(val);
                    for(i = 0; i < keys.length; i++){
                        var key = keys[i];
                        decirc(val[key], key, i, stack, val, depth, options);
                    }
                }
                stack.pop();
            }
        }
        function replaceGetterValues(replacer) {
            replacer = void 0 !== replacer ? replacer : function(k, v) {
                return v;
            };
            return function(key, val) {
                if (replacerStack.length > 0) for(var i = 0; i < replacerStack.length; i++){
                    var part = replacerStack[i];
                    if (part[1] === key && part[0] === val) {
                        val = part[2];
                        replacerStack.splice(i, 1);
                        break;
                    }
                }
                return replacer.call(this, key, val);
            };
        }
        function mergeRuntimeEnvIntoRunCreate(run) {
            const runtimeEnv = getRuntimeEnvironment();
            const envVars = getLangChainEnvVarsMetadata();
            const extra = run.extra ?? {};
            const metadata = extra.metadata;
            run.extra = {
                ...extra,
                runtime: {
                    ...runtimeEnv,
                    ...extra?.runtime
                },
                metadata: {
                    ...envVars,
                    ...envVars.revision_id || run.revision_id ? {
                        revision_id: run.revision_id ?? envVars.revision_id
                    } : {},
                    ...metadata
                }
            };
            return run;
        }
        const getTracingSamplingRate = (configRate)=>{
            const samplingRateStr = configRate?.toString() ?? getLangSmithEnvironmentVariable("TRACING_SAMPLING_RATE");
            if (void 0 === samplingRateStr) return;
            const samplingRate = parseFloat(samplingRateStr);
            if (samplingRate < 0 || samplingRate > 1) throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
            return samplingRate;
        };
        const isLocalhost = (url)=>{
            const strippedUrl = url.replace("http://", "").replace("https://", "");
            const hostname = strippedUrl.split("/")[0].split(":")[0];
            return "localhost" === hostname || "127.0.0.1" === hostname || "::1" === hostname;
        };
        async function toArray(iterable) {
            const result = [];
            for await (const item of iterable)result.push(item);
            return result;
        }
        function trimQuotes(str) {
            if (void 0 === str) return;
            return str.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
        }
        const handle429 = async (response)=>{
            if (response?.status === 429) {
                const retryAfter = 1000 * parseInt(response.headers.get("retry-after") ?? "30", 10);
                if (retryAfter > 0) {
                    await new Promise((resolve)=>setTimeout(resolve, retryAfter));
                    return true;
                }
            }
            return false;
        };
        function _formatFeedbackScore(score) {
            if ("number" == typeof score) return Number(score.toFixed(4));
            return score;
        }
        class AutoBatchQueue {
            constructor(){
                Object.defineProperty(this, "items", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "sizeBytes", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: 0
                });
            }
            peek() {
                return this.items[0];
            }
            push(item) {
                let itemPromiseResolve;
                const itemPromise = new Promise((resolve)=>{
                    itemPromiseResolve = resolve;
                });
                const size = serialize(item.item).length;
                this.items.push({
                    action: item.action,
                    payload: item.item,
                    itemPromiseResolve: itemPromiseResolve,
                    itemPromise,
                    size
                });
                this.sizeBytes += size;
                return itemPromise;
            }
            pop(upToSizeBytes) {
                if (upToSizeBytes < 1) throw new Error("Number of bytes to pop off may not be less than 1.");
                const popped = [];
                let poppedSizeBytes = 0;
                while(poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0){
                    const item = this.items.shift();
                    if (item) {
                        popped.push(item);
                        poppedSizeBytes += item.size;
                        this.sizeBytes -= item.size;
                    }
                }
                if (0 === popped.length && this.items.length > 0) {
                    const item = this.items.shift();
                    popped.push(item);
                    poppedSizeBytes += item.size;
                    this.sizeBytes -= item.size;
                }
                return [
                    popped.map((it)=>({
                            action: it.action,
                            item: it.payload
                        })),
                    ()=>popped.forEach((it)=>it.itemPromiseResolve())
                ];
            }
        }
        const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;
        const SERVER_INFO_REQUEST_TIMEOUT = 2500;
        class Client {
            constructor(config = {}){
                Object.defineProperty(this, "apiKey", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "apiUrl", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "webUrl", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "caller", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "batchIngestCaller", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "timeout_ms", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "_tenantId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: null
                });
                Object.defineProperty(this, "hideInputs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "hideOutputs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "tracingSampleRate", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "filteredPostUuids", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: new Set()
                });
                Object.defineProperty(this, "autoBatchTracing", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "autoBatchQueue", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: new AutoBatchQueue()
                });
                Object.defineProperty(this, "autoBatchTimeout", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "autoBatchAggregationDelayMs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: 250
                });
                Object.defineProperty(this, "batchSizeBytesLimit", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "fetchOptions", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "settings", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "blockOnRootRunFinalization", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "false" === getEnvironmentVariable("LANGSMITH_TRACING_BACKGROUND")
                });
                Object.defineProperty(this, "traceBatchConcurrency", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: 5
                });
                Object.defineProperty(this, "_serverInfo", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "_getServerInfoPromise", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "manualFlushMode", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                const defaultConfig = Client.getDefaultClientConfig();
                this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);
                this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? "";
                if (this.apiUrl.endsWith("/")) this.apiUrl = this.apiUrl.slice(0, -1);
                this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);
                this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);
                if (this.webUrl?.endsWith("/")) this.webUrl = this.webUrl.slice(0, -1);
                this.timeout_ms = config.timeout_ms ?? 90000;
                this.caller = new AsyncCaller(config.callerOptions ?? {});
                this.traceBatchConcurrency = config.traceBatchConcurrency ?? this.traceBatchConcurrency;
                if (this.traceBatchConcurrency < 1) throw new Error("Trace batch concurrency must be positive.");
                this.batchIngestCaller = new AsyncCaller({
                    maxRetries: 2,
                    maxConcurrency: this.traceBatchConcurrency,
                    ...config.callerOptions ?? {},
                    onFailedResponseHook: handle429
                });
                this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;
                this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;
                this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;
                this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;
                this.batchSizeBytesLimit = config.batchSizeBytesLimit;
                this.fetchOptions = config.fetchOptions || {};
                this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;
            }
            static getDefaultClientConfig() {
                const apiKey = getLangSmithEnvironmentVariable("API_KEY");
                const apiUrl = getLangSmithEnvironmentVariable("ENDPOINT") ?? "https://api.smith.langchain.com";
                const hideInputs = "true" === getLangSmithEnvironmentVariable("HIDE_INPUTS");
                const hideOutputs = "true" === getLangSmithEnvironmentVariable("HIDE_OUTPUTS");
                return {
                    apiUrl: apiUrl,
                    apiKey: apiKey,
                    webUrl: void 0,
                    hideInputs: hideInputs,
                    hideOutputs: hideOutputs
                };
            }
            getHostUrl() {
                if (this.webUrl) return this.webUrl;
                if (isLocalhost(this.apiUrl)) {
                    this.webUrl = "http://localhost:3000";
                    return this.webUrl;
                }
                if (this.apiUrl.endsWith("/api/v1")) {
                    this.webUrl = this.apiUrl.replace("/api/v1", "");
                    return this.webUrl;
                }
                if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
                    this.webUrl = this.apiUrl.replace("/api", "");
                    return this.webUrl;
                }
                if (this.apiUrl.split(".", 1)[0].includes("dev")) {
                    this.webUrl = "https://dev.smith.langchain.com";
                    return this.webUrl;
                } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
                    this.webUrl = "https://eu.smith.langchain.com";
                    return this.webUrl;
                } else if (this.apiUrl.split(".", 1)[0].includes("beta")) {
                    this.webUrl = "https://beta.smith.langchain.com";
                    return this.webUrl;
                } else {
                    this.webUrl = "https://smith.langchain.com";
                    return this.webUrl;
                }
            }
            get headers() {
                const headers = {
                    "User-Agent": `langsmith-js/${__version__}`
                };
                if (this.apiKey) headers["x-api-key"] = `${this.apiKey}`;
                return headers;
            }
            processInputs(inputs) {
                if (false === this.hideInputs) return inputs;
                if (true === this.hideInputs) return {};
                if ("function" == typeof this.hideInputs) return this.hideInputs(inputs);
                return inputs;
            }
            processOutputs(outputs) {
                if (false === this.hideOutputs) return outputs;
                if (true === this.hideOutputs) return {};
                if ("function" == typeof this.hideOutputs) return this.hideOutputs(outputs);
                return outputs;
            }
            prepareRunCreateOrUpdateInputs(run) {
                const runParams = {
                    ...run
                };
                if (void 0 !== runParams.inputs) runParams.inputs = this.processInputs(runParams.inputs);
                if (void 0 !== runParams.outputs) runParams.outputs = this.processOutputs(runParams.outputs);
                return runParams;
            }
            async _getResponse(path, queryParams) {
                const paramsString = queryParams?.toString() ?? "";
                const url = `${this.apiUrl}${path}?${paramsString}`;
                const response = await this.caller.call(_getFetchImplementation(), url, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, `Failed to fetch ${path}`);
                return response;
            }
            async _get(path, queryParams) {
                const response = await this._getResponse(path, queryParams);
                return response.json();
            }
            async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {
                let offset = Number(queryParams.get("offset")) || 0;
                const limit = Number(queryParams.get("limit")) || 100;
                while(true){
                    queryParams.set("offset", String(offset));
                    queryParams.set("limit", String(limit));
                    const url = `${this.apiUrl}${path}?${queryParams}`;
                    const response = await this.caller.call(_getFetchImplementation(), url, {
                        method: "GET",
                        headers: this.headers,
                        signal: AbortSignal.timeout(this.timeout_ms),
                        ...this.fetchOptions
                    });
                    await raiseForStatus(response, `Failed to fetch ${path}`);
                    const items = transform ? transform(await response.json()) : await response.json();
                    if (0 === items.length) break;
                    yield items;
                    if (items.length < limit) break;
                    offset += items.length;
                }
            }
            async *_getCursorPaginatedList(path, body = null, requestMethod = "POST", dataKey = "runs") {
                const bodyParams = body ? {
                    ...body
                } : {};
                while(true){
                    const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${path}`, {
                        method: requestMethod,
                        headers: {
                            ...this.headers,
                            "Content-Type": "application/json"
                        },
                        signal: AbortSignal.timeout(this.timeout_ms),
                        ...this.fetchOptions,
                        body: JSON.stringify(bodyParams)
                    });
                    const responseBody = await response.json();
                    if (!responseBody) break;
                    if (!responseBody[dataKey]) break;
                    yield responseBody[dataKey];
                    const cursors = responseBody.cursors;
                    if (!cursors) break;
                    if (!cursors.next) break;
                    bodyParams.cursor = cursors.next;
                }
            }
            _shouldSample() {
                if (void 0 === this.tracingSampleRate) return true;
                return Math.random() < this.tracingSampleRate;
            }
            _filterForSampling(runs, patch = false) {
                if (void 0 === this.tracingSampleRate) return runs;
                if (patch) {
                    const sampled = [];
                    for (const run of runs)if (this.filteredPostUuids.has(run.id)) this.filteredPostUuids.delete(run.id);
                    else sampled.push(run);
                    return sampled;
                }
                {
                    const sampled = [];
                    for (const run of runs){
                        const traceId = run.trace_id ?? run.id;
                        if (!this.filteredPostUuids.has(traceId)) {
                            if (run.id === traceId) {
                                if (this._shouldSample()) sampled.push(run);
                                else this.filteredPostUuids.add(traceId);
                            } else sampled.push(run);
                        }
                    }
                    return sampled;
                }
            }
            async _getBatchSizeLimitBytes() {
                const serverInfo = await this._ensureServerInfo();
                return this.batchSizeBytesLimit ?? serverInfo.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;
            }
            async _getMultiPartSupport() {
                const serverInfo = await this._ensureServerInfo();
                return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;
            }
            drainAutoBatchQueue(batchSizeLimit) {
                const promises = [];
                while(this.autoBatchQueue.items.length > 0){
                    const [batch, done] = this.autoBatchQueue.pop(batchSizeLimit);
                    if (!batch.length) {
                        done();
                        break;
                    }
                    const batchPromise = this._processBatch(batch, done).catch(console.error);
                    promises.push(batchPromise);
                }
                return Promise.all(promises);
            }
            async _processBatch(batch, done) {
                if (!batch.length) {
                    done();
                    return;
                }
                try {
                    const ingestParams = {
                        runCreates: batch.filter((item)=>"create" === item.action).map((item)=>item.item),
                        runUpdates: batch.filter((item)=>"update" === item.action).map((item)=>item.item)
                    };
                    const serverInfo = await this._ensureServerInfo();
                    if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) await this.multipartIngestRuns(ingestParams);
                    else await this.batchIngestRuns(ingestParams);
                } finally{
                    done();
                }
            }
            async processRunOperation(item) {
                clearTimeout(this.autoBatchTimeout);
                this.autoBatchTimeout = void 0;
                if ("create" === item.action) item.item = mergeRuntimeEnvIntoRunCreate(item.item);
                const itemPromise = this.autoBatchQueue.push(item);
                if (this.manualFlushMode) return itemPromise;
                const sizeLimitBytes = await this._getBatchSizeLimitBytes();
                if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) this.drainAutoBatchQueue(sizeLimitBytes);
                if (this.autoBatchQueue.items.length > 0) this.autoBatchTimeout = setTimeout(()=>{
                    this.autoBatchTimeout = void 0;
                    this.drainAutoBatchQueue(sizeLimitBytes);
                }, this.autoBatchAggregationDelayMs);
                return itemPromise;
            }
            async _getServerInfo() {
                const response = await _getFetchImplementation()(`${this.apiUrl}/info`, {
                    method: "GET",
                    headers: {
                        Accept: "application/json"
                    },
                    signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "get server info");
                return response.json();
            }
            async _ensureServerInfo() {
                if (void 0 === this._getServerInfoPromise) this._getServerInfoPromise = (async ()=>{
                    if (void 0 === this._serverInfo) try {
                        this._serverInfo = await this._getServerInfo();
                    } catch (e) {
                        console.warn("[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.");
                    }
                    return this._serverInfo ?? {};
                })();
                return this._getServerInfoPromise.then((serverInfo)=>{
                    if (void 0 === this._serverInfo) this._getServerInfoPromise = void 0;
                    return serverInfo;
                });
            }
            async _getSettings() {
                if (!this.settings) this.settings = this._get("/settings");
                return await this.settings;
            }
            async flush() {
                const sizeLimitBytes = await this._getBatchSizeLimitBytes();
                await this.drainAutoBatchQueue(sizeLimitBytes);
            }
            async createRun(run) {
                if (!this._filterForSampling([
                    run
                ]).length) return;
                const headers = {
                    ...this.headers,
                    "Content-Type": "application/json"
                };
                const session_name = run.project_name;
                delete run.project_name;
                const runCreate = this.prepareRunCreateOrUpdateInputs({
                    session_name,
                    ...run,
                    start_time: run.start_time ?? Date.now()
                });
                if (this.autoBatchTracing && void 0 !== runCreate.trace_id && void 0 !== runCreate.dotted_order) {
                    this.processRunOperation({
                        action: "create",
                        item: runCreate
                    }).catch(console.error);
                    return;
                }
                const mergedRunCreateParam = mergeRuntimeEnvIntoRunCreate(runCreate);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs`, {
                    method: "POST",
                    headers,
                    body: serialize(mergedRunCreateParam),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "create run", true);
            }
            async batchIngestRuns({ runCreates, runUpdates }) {
                if (void 0 === runCreates && void 0 === runUpdates) return;
                let preparedCreateParams = runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? [];
                let preparedUpdateParams = runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? [];
                if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
                    const createById = preparedCreateParams.reduce((params, run)=>{
                        if (!run.id) return params;
                        params[run.id] = run;
                        return params;
                    }, {});
                    const standaloneUpdates = [];
                    for (const updateParam of preparedUpdateParams)if (void 0 !== updateParam.id && createById[updateParam.id]) createById[updateParam.id] = {
                        ...createById[updateParam.id],
                        ...updateParam
                    };
                    else standaloneUpdates.push(updateParam);
                    preparedCreateParams = Object.values(createById);
                    preparedUpdateParams = standaloneUpdates;
                }
                const rawBatch = {
                    post: preparedCreateParams,
                    patch: preparedUpdateParams
                };
                if (!rawBatch.post.length && !rawBatch.patch.length) return;
                const batchChunks = {
                    post: [],
                    patch: []
                };
                for (const k of [
                    "post",
                    "patch"
                ]){
                    const key = k;
                    const batchItems = rawBatch[key].reverse();
                    let batchItem = batchItems.pop();
                    while(void 0 !== batchItem){
                        batchChunks[key].push(batchItem);
                        batchItem = batchItems.pop();
                    }
                }
                if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) await this._postBatchIngestRuns(serialize(batchChunks));
            }
            async _postBatchIngestRuns(body) {
                const headers = {
                    ...this.headers,
                    "Content-Type": "application/json",
                    Accept: "application/json"
                };
                const response = await this.batchIngestCaller.call(_getFetchImplementation(), `${this.apiUrl}/runs/batch`, {
                    method: "POST",
                    headers,
                    body: body,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "batch create run", true);
            }
            async multipartIngestRuns({ runCreates, runUpdates }) {
                if (void 0 === runCreates && void 0 === runUpdates) return;
                const allAttachments = {};
                let preparedCreateParams = [];
                for (const create of runCreates ?? []){
                    const preparedCreate = this.prepareRunCreateOrUpdateInputs(create);
                    if (void 0 !== preparedCreate.id && void 0 !== preparedCreate.attachments) allAttachments[preparedCreate.id] = preparedCreate.attachments;
                    delete preparedCreate.attachments;
                    preparedCreateParams.push(preparedCreate);
                }
                let preparedUpdateParams = [];
                for (const update of runUpdates ?? [])preparedUpdateParams.push(this.prepareRunCreateOrUpdateInputs(update));
                const invalidRunCreate = preparedCreateParams.find((runCreate)=>void 0 === runCreate.trace_id || void 0 === runCreate.dotted_order);
                if (void 0 !== invalidRunCreate) throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
                const invalidRunUpdate = preparedUpdateParams.find((runUpdate)=>void 0 === runUpdate.trace_id || void 0 === runUpdate.dotted_order);
                if (void 0 !== invalidRunUpdate) throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
                if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
                    const createById = preparedCreateParams.reduce((params, run)=>{
                        if (!run.id) return params;
                        params[run.id] = run;
                        return params;
                    }, {});
                    const standaloneUpdates = [];
                    for (const updateParam of preparedUpdateParams)if (void 0 !== updateParam.id && createById[updateParam.id]) createById[updateParam.id] = {
                        ...createById[updateParam.id],
                        ...updateParam
                    };
                    else standaloneUpdates.push(updateParam);
                    preparedCreateParams = Object.values(createById);
                    preparedUpdateParams = standaloneUpdates;
                }
                if (0 === preparedCreateParams.length && 0 === preparedUpdateParams.length) return;
                const accumulatedContext = [];
                const accumulatedParts = [];
                for (const [method, payloads] of [
                    [
                        "post",
                        preparedCreateParams
                    ],
                    [
                        "patch",
                        preparedUpdateParams
                    ]
                ])for (const originalPayload of payloads){
                    const { inputs, outputs, events, attachments, ...payload } = originalPayload;
                    const fields = {
                        inputs,
                        outputs,
                        events
                    };
                    const stringifiedPayload = serialize(payload);
                    accumulatedParts.push({
                        name: `${method}.${payload.id}`,
                        payload: new Blob([
                            stringifiedPayload
                        ], {
                            type: `application/json; length=${stringifiedPayload.length}`
                        })
                    });
                    for (const [key, value] of Object.entries(fields)){
                        if (void 0 === value) continue;
                        const stringifiedValue = serialize(value);
                        accumulatedParts.push({
                            name: `${method}.${payload.id}.${key}`,
                            payload: new Blob([
                                stringifiedValue
                            ], {
                                type: `application/json; length=${stringifiedValue.length}`
                            })
                        });
                    }
                    if (void 0 !== payload.id) {
                        const attachments = allAttachments[payload.id];
                        if (attachments) {
                            delete allAttachments[payload.id];
                            for (const [name, attachment] of Object.entries(attachments)){
                                let contentType;
                                let content;
                                if (Array.isArray(attachment)) [contentType, content] = attachment;
                                else {
                                    contentType = attachment.mimeType;
                                    content = attachment.data;
                                }
                                if (name.includes(".")) {
                                    console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                                    continue;
                                }
                                accumulatedParts.push({
                                    name: `attachment.${payload.id}.${name}`,
                                    payload: new Blob([
                                        content
                                    ], {
                                        type: `${contentType}; length=${content.byteLength}`
                                    })
                                });
                            }
                        }
                    }
                    accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);
                }
                await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "));
            }
            async _sendMultipartRequest(parts, context) {
                try {
                    const boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
                    const chunks = [];
                    for (const part of parts){
                        chunks.push(new Blob([
                            `--${boundary}\r\n`
                        ]));
                        chunks.push(new Blob([
                            `Content-Disposition: form-data; name="${part.name}"\r\n`,
                            `Content-Type: ${part.payload.type}\r\n\r\n`
                        ]));
                        chunks.push(part.payload);
                        chunks.push(new Blob([
                            "\r\n"
                        ]));
                    }
                    chunks.push(new Blob([
                        `--${boundary}--\r\n`
                    ]));
                    const body = new Blob(chunks);
                    const arrayBuffer = await body.arrayBuffer();
                    const res = await this.batchIngestCaller.call(_getFetchImplementation(), `${this.apiUrl}/runs/multipart`, {
                        method: "POST",
                        headers: {
                            ...this.headers,
                            "Content-Type": `multipart/form-data; boundary=${boundary}`
                        },
                        body: arrayBuffer,
                        signal: AbortSignal.timeout(this.timeout_ms),
                        ...this.fetchOptions
                    });
                    await raiseForStatus(res, "ingest multipart runs", true);
                } catch (e) {
                    console.warn(`${e.message.trim()}\n\nContext: ${context}`);
                }
            }
            async updateRun(runId, run) {
                assertUuid(runId);
                if (run.inputs) run.inputs = this.processInputs(run.inputs);
                if (run.outputs) run.outputs = this.processOutputs(run.outputs);
                const data = {
                    ...run,
                    id: runId
                };
                if (!this._filterForSampling([
                    data
                ], true).length) return;
                if (this.autoBatchTracing && void 0 !== data.trace_id && void 0 !== data.dotted_order) {
                    if (void 0 !== run.end_time && void 0 === data.parent_run_id && this.blockOnRootRunFinalization && !this.manualFlushMode) await this.processRunOperation({
                        action: "update",
                        item: data
                    }).catch(console.error);
                    else this.processRunOperation({
                        action: "update",
                        item: data
                    }).catch(console.error);
                    return;
                }
                const headers = {
                    ...this.headers,
                    "Content-Type": "application/json"
                };
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}`, {
                    method: "PATCH",
                    headers,
                    body: serialize(run),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "update run", true);
            }
            async readRun(runId, { loadChildRuns } = {
                loadChildRuns: false
            }) {
                assertUuid(runId);
                let run = await this._get(`/runs/${runId}`);
                if (loadChildRuns && run.child_run_ids) run = await this._loadChildRuns(run);
                return run;
            }
            async getRunUrl({ runId, run, projectOpts }) {
                if (void 0 !== run) {
                    let sessionId;
                    if (run.session_id) sessionId = run.session_id;
                    else if (projectOpts?.projectName) sessionId = (await this.readProject({
                        projectName: projectOpts?.projectName
                    })).id;
                    else if (projectOpts?.projectId) sessionId = projectOpts?.projectId;
                    else {
                        const project = await this.readProject({
                            projectName: getLangSmithEnvironmentVariable("PROJECT") || "default"
                        });
                        sessionId = project.id;
                    }
                    const tenantId = await this._getTenantId();
                    return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
                }
                if (void 0 !== runId) {
                    const run_ = await this.readRun(runId);
                    if (!run_.app_path) throw new Error(`Run ${runId} has no app_path`);
                    const baseUrl = this.getHostUrl();
                    return `${baseUrl}${run_.app_path}`;
                }
                throw new Error("Must provide either runId or run");
            }
            async _loadChildRuns(run) {
                const childRuns = await toArray(this.listRuns({
                    id: run.child_run_ids
                }));
                const treemap = {};
                const runs = {};
                childRuns.sort((a, b)=>(a?.dotted_order ?? "").localeCompare(b?.dotted_order ?? ""));
                for (const childRun of childRuns){
                    if (null === childRun.parent_run_id || void 0 === childRun.parent_run_id) throw new Error(`Child run ${childRun.id} has no parent`);
                    if (!(childRun.parent_run_id in treemap)) treemap[childRun.parent_run_id] = [];
                    treemap[childRun.parent_run_id].push(childRun);
                    runs[childRun.id] = childRun;
                }
                run.child_runs = treemap[run.id] || [];
                for(const runId in treemap)if (runId !== run.id) runs[runId].child_runs = treemap[runId];
                return run;
            }
            async *listRuns(props) {
                const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select } = props;
                let projectIds = [];
                if (projectId) projectIds = Array.isArray(projectId) ? projectId : [
                    projectId
                ];
                if (projectName) {
                    const projectNames = Array.isArray(projectName) ? projectName : [
                        projectName
                    ];
                    const projectIds_ = await Promise.all(projectNames.map((name)=>this.readProject({
                            projectName: name
                        }).then((project)=>project.id)));
                    projectIds.push(...projectIds_);
                }
                const default_select = [
                    "app_path",
                    "child_run_ids",
                    "completion_cost",
                    "completion_tokens",
                    "dotted_order",
                    "end_time",
                    "error",
                    "events",
                    "extra",
                    "feedback_stats",
                    "first_token_time",
                    "id",
                    "inputs",
                    "name",
                    "outputs",
                    "parent_run_id",
                    "parent_run_ids",
                    "prompt_cost",
                    "prompt_tokens",
                    "reference_example_id",
                    "run_type",
                    "session_id",
                    "start_time",
                    "status",
                    "tags",
                    "total_cost",
                    "total_tokens",
                    "trace_id"
                ];
                const body = {
                    session: projectIds.length ? projectIds : null,
                    run_type: runType,
                    reference_example: referenceExampleId,
                    query,
                    filter,
                    trace_filter: traceFilter,
                    tree_filter: treeFilter,
                    execution_order: executionOrder,
                    parent_run: parentRunId,
                    start_time: startTime ? startTime.toISOString() : null,
                    error,
                    id,
                    limit,
                    trace: traceId,
                    select: select ? select : default_select,
                    is_root: isRoot
                };
                let runsYielded = 0;
                for await (const runs of this._getCursorPaginatedList("/runs/query", body))if (limit) {
                    if (runsYielded >= limit) break;
                    if (runs.length + runsYielded > limit) {
                        const newRuns = runs.slice(0, limit - runsYielded);
                        yield* newRuns;
                        break;
                    }
                    runsYielded += runs.length;
                    yield* runs;
                } else yield* runs;
            }
            async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {
                let projectIds_ = projectIds || [];
                if (projectNames) projectIds_ = [
                    ...projectIds || [],
                    ...await Promise.all(projectNames.map((name)=>this.readProject({
                            projectName: name
                        }).then((project)=>project.id)))
                ];
                const payload = {
                    id,
                    trace,
                    parent_run: parentRun,
                    run_type: runType,
                    session: projectIds_,
                    reference_example: referenceExampleIds,
                    start_time: startTime,
                    end_time: endTime,
                    error,
                    query,
                    filter,
                    trace_filter: traceFilter,
                    tree_filter: treeFilter,
                    is_root: isRoot,
                    data_source_type: dataSourceType
                };
                const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value])=>void 0 !== value));
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/stats`, {
                    method: "POST",
                    headers: this.headers,
                    body: JSON.stringify(filteredPayload),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const result = await response.json();
                return result;
            }
            async shareRun(runId, { shareId } = {}) {
                const data = {
                    run_id: runId,
                    share_token: shareId || dist_esm_node_v4()
                };
                assertUuid(runId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
                    method: "PUT",
                    headers: this.headers,
                    body: JSON.stringify(data),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const result = await response.json();
                if (null === result || !("share_token" in result)) throw new Error("Invalid response from server");
                return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
            }
            async unshareRun(runId) {
                assertUuid(runId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
                    method: "DELETE",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "unshare run", true);
            }
            async readRunSharedLink(runId) {
                assertUuid(runId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const result = await response.json();
                if (null === result || !("share_token" in result)) return;
                return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
            }
            async listSharedRuns(shareToken, { runIds } = {}) {
                const queryParams = new URLSearchParams({
                    share_token: shareToken
                });
                if (void 0 !== runIds) for (const runId of runIds)queryParams.append("id", runId);
                assertUuid(shareToken);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const runs = await response.json();
                return runs;
            }
            async readDatasetSharedSchema(datasetId, datasetName) {
                if (!datasetId && !datasetName) throw new Error("Either datasetId or datasetName must be given");
                if (!datasetId) {
                    const dataset = await this.readDataset({
                        datasetName
                    });
                    datasetId = dataset.id;
                }
                assertUuid(datasetId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const shareSchema = await response.json();
                shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
                return shareSchema;
            }
            async shareDataset(datasetId, datasetName) {
                if (!datasetId && !datasetName) throw new Error("Either datasetId or datasetName must be given");
                if (!datasetId) {
                    const dataset = await this.readDataset({
                        datasetName
                    });
                    datasetId = dataset.id;
                }
                const data = {
                    dataset_id: datasetId
                };
                assertUuid(datasetId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
                    method: "PUT",
                    headers: this.headers,
                    body: JSON.stringify(data),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const shareSchema = await response.json();
                shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
                return shareSchema;
            }
            async unshareDataset(datasetId) {
                assertUuid(datasetId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
                    method: "DELETE",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "unshare dataset", true);
            }
            async readSharedDataset(shareToken) {
                assertUuid(shareToken);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/datasets`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const dataset = await response.json();
                return dataset;
            }
            async listSharedExamples(shareToken, options) {
                const params = {};
                if (options?.exampleIds) params.id = options.exampleIds;
                const urlParams = new URLSearchParams();
                Object.entries(params).forEach(([key, value])=>{
                    if (Array.isArray(value)) value.forEach((v)=>urlParams.append(key, v));
                    else urlParams.append(key, value);
                });
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const result = await response.json();
                if (!response.ok) {
                    if ("detail" in result) throw new Error(`Failed to list shared examples.\nStatus: ${response.status}\nMessage: ${result.detail.join("\n")}`);
                    throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
                }
                return result.map((example)=>({
                        ...example,
                        _hostUrl: this.getHostUrl()
                    }));
            }
            async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
                const upsert_ = upsert ? "?upsert=true" : "";
                const endpoint = `${this.apiUrl}/sessions${upsert_}`;
                const extra = projectExtra || {};
                if (metadata) extra["metadata"] = metadata;
                const body = {
                    name: projectName,
                    extra,
                    description
                };
                if (null !== referenceDatasetId) body["reference_dataset_id"] = referenceDatasetId;
                const response = await this.caller.call(_getFetchImplementation(), endpoint, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(body),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "create project");
                const result = await response.json();
                return result;
            }
            async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
                const endpoint = `${this.apiUrl}/sessions/${projectId}`;
                let extra = projectExtra;
                if (metadata) extra = {
                    ...extra || {},
                    metadata
                };
                const body = {
                    name,
                    extra,
                    description,
                    end_time: endTime ? new Date(endTime).toISOString() : null
                };
                const response = await this.caller.call(_getFetchImplementation(), endpoint, {
                    method: "PATCH",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(body),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "update project");
                const result = await response.json();
                return result;
            }
            async hasProject({ projectId, projectName }) {
                let path = "/sessions";
                const params = new URLSearchParams();
                if (void 0 !== projectId && void 0 !== projectName) throw new Error("Must provide either projectName or projectId, not both");
                if (void 0 !== projectId) {
                    assertUuid(projectId);
                    path += `/${projectId}`;
                } else if (void 0 !== projectName) params.append("name", projectName);
                else throw new Error("Must provide projectName or projectId");
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${path}?${params}`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                try {
                    const result = await response.json();
                    if (!response.ok) return false;
                    if (Array.isArray(result)) return result.length > 0;
                    return true;
                } catch (e) {
                    return false;
                }
            }
            async readProject({ projectId, projectName, includeStats }) {
                let path = "/sessions";
                const params = new URLSearchParams();
                if (void 0 !== projectId && void 0 !== projectName) throw new Error("Must provide either projectName or projectId, not both");
                if (void 0 !== projectId) {
                    assertUuid(projectId);
                    path += `/${projectId}`;
                } else if (void 0 !== projectName) params.append("name", projectName);
                else throw new Error("Must provide projectName or projectId");
                if (void 0 !== includeStats) params.append("include_stats", includeStats.toString());
                const response = await this._get(path, params);
                let result;
                if (Array.isArray(response)) {
                    if (0 === response.length) throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
                    result = response[0];
                } else result = response;
                return result;
            }
            async getProjectUrl({ projectId, projectName }) {
                if (void 0 === projectId && void 0 === projectName) throw new Error("Must provide either projectName or projectId");
                const project = await this.readProject({
                    projectId,
                    projectName
                });
                const tenantId = await this._getTenantId();
                return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
            }
            async getDatasetUrl({ datasetId, datasetName }) {
                if (void 0 === datasetId && void 0 === datasetName) throw new Error("Must provide either datasetName or datasetId");
                const dataset = await this.readDataset({
                    datasetId,
                    datasetName
                });
                const tenantId = await this._getTenantId();
                return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
            }
            async _getTenantId() {
                if (null !== this._tenantId) return this._tenantId;
                const queryParams = new URLSearchParams({
                    limit: "1"
                });
                for await (const projects of this._getPaginated("/sessions", queryParams)){
                    this._tenantId = projects[0].tenant_id;
                    return projects[0].tenant_id;
                }
                throw new Error("No projects found to resolve tenant.");
            }
            async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata } = {}) {
                const params = new URLSearchParams();
                if (void 0 !== projectIds) for (const projectId of projectIds)params.append("id", projectId);
                if (void 0 !== name) params.append("name", name);
                if (void 0 !== nameContains) params.append("name_contains", nameContains);
                if (void 0 !== referenceDatasetId) params.append("reference_dataset", referenceDatasetId);
                else if (void 0 !== referenceDatasetName) {
                    const dataset = await this.readDataset({
                        datasetName: referenceDatasetName
                    });
                    params.append("reference_dataset", dataset.id);
                }
                if (void 0 !== referenceFree) params.append("reference_free", referenceFree.toString());
                if (void 0 !== metadata) params.append("metadata", JSON.stringify(metadata));
                for await (const projects of this._getPaginated("/sessions", params))yield* projects;
            }
            async deleteProject({ projectId, projectName }) {
                let projectId_;
                if (void 0 === projectId && void 0 === projectName) throw new Error("Must provide projectName or projectId");
                if (void 0 !== projectId && void 0 !== projectName) throw new Error("Must provide either projectName or projectId, not both");
                projectId_ = void 0 === projectId ? (await this.readProject({
                    projectName
                })).id : projectId;
                assertUuid(projectId_);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/sessions/${projectId_}`, {
                    method: "DELETE",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, `delete session ${projectId_} (${projectName})`, true);
            }
            async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
                const url = `${this.apiUrl}/datasets/upload`;
                const formData = new FormData();
                formData.append("file", csvFile, fileName);
                inputKeys.forEach((key)=>{
                    formData.append("input_keys", key);
                });
                outputKeys.forEach((key)=>{
                    formData.append("output_keys", key);
                });
                if (description) formData.append("description", description);
                if (dataType) formData.append("data_type", dataType);
                if (name) formData.append("name", name);
                const response = await this.caller.call(_getFetchImplementation(), url, {
                    method: "POST",
                    headers: this.headers,
                    body: formData,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "upload CSV");
                const result = await response.json();
                return result;
            }
            async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
                const body = {
                    name,
                    description,
                    extra: metadata ? {
                        metadata
                    } : void 0
                };
                if (dataType) body.data_type = dataType;
                if (inputsSchema) body.inputs_schema_definition = inputsSchema;
                if (outputsSchema) body.outputs_schema_definition = outputsSchema;
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(body),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "create dataset");
                const result = await response.json();
                return result;
            }
            async readDataset({ datasetId, datasetName }) {
                let path = "/datasets";
                const params = new URLSearchParams({
                    limit: "1"
                });
                if (void 0 !== datasetId && void 0 !== datasetName) throw new Error("Must provide either datasetName or datasetId, not both");
                if (void 0 !== datasetId) {
                    assertUuid(datasetId);
                    path += `/${datasetId}`;
                } else if (void 0 !== datasetName) params.append("name", datasetName);
                else throw new Error("Must provide datasetName or datasetId");
                const response = await this._get(path, params);
                let result;
                if (Array.isArray(response)) {
                    if (0 === response.length) throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
                    result = response[0];
                } else result = response;
                return result;
            }
            async hasDataset({ datasetId, datasetName }) {
                try {
                    await this.readDataset({
                        datasetId,
                        datasetName
                    });
                    return true;
                } catch (e) {
                    if (e instanceof Error && e.message.toLocaleLowerCase().includes("not found")) return false;
                    throw e;
                }
            }
            async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
                let datasetId_ = datasetId;
                if (void 0 === datasetId_ && void 0 === datasetName) throw new Error("Must provide either datasetName or datasetId");
                if (void 0 !== datasetId_ && void 0 !== datasetName) throw new Error("Must provide either datasetName or datasetId, not both");
                if (void 0 === datasetId_) {
                    const dataset = await this.readDataset({
                        datasetName
                    });
                    datasetId_ = dataset.id;
                }
                const urlParams = new URLSearchParams({
                    from_version: "string" == typeof fromVersion ? fromVersion : fromVersion.toISOString(),
                    to_version: "string" == typeof toVersion ? toVersion : toVersion.toISOString()
                });
                const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
                return response;
            }
            async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
                const path = "/datasets";
                if (void 0 !== datasetId) ;
                else if (void 0 !== datasetName) datasetId = (await this.readDataset({
                    datasetName
                })).id;
                else throw new Error("Must provide either datasetName or datasetId");
                const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
                const datasetText = await response.text();
                const dataset = datasetText.trim().split("\n").map((line)=>JSON.parse(line));
                return dataset;
            }
            async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
                const path = "/datasets";
                const params = new URLSearchParams({
                    limit: limit.toString(),
                    offset: offset.toString()
                });
                if (void 0 !== datasetIds) for (const id_ of datasetIds)params.append("id", id_);
                if (void 0 !== datasetName) params.append("name", datasetName);
                if (void 0 !== datasetNameContains) params.append("name_contains", datasetNameContains);
                if (void 0 !== metadata) params.append("metadata", JSON.stringify(metadata));
                for await (const datasets of this._getPaginated(path, params))yield* datasets;
            }
            async updateDataset(props) {
                const { datasetId, datasetName, ...update } = props;
                if (!datasetId && !datasetName) throw new Error("Must provide either datasetName or datasetId");
                const _datasetId = datasetId ?? (await this.readDataset({
                    datasetName
                })).id;
                assertUuid(_datasetId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${_datasetId}`, {
                    method: "PATCH",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(update),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "update dataset");
                return await response.json();
            }
            async updateDatasetTag(props) {
                const { datasetId, datasetName, asOf, tag } = props;
                if (!datasetId && !datasetName) throw new Error("Must provide either datasetName or datasetId");
                const _datasetId = datasetId ?? (await this.readDataset({
                    datasetName
                })).id;
                assertUuid(_datasetId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${_datasetId}/tags`, {
                    method: "PUT",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        as_of: "string" == typeof asOf ? asOf : asOf.toISOString(),
                        tag
                    }),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "update dataset tags");
            }
            async deleteDataset({ datasetId, datasetName }) {
                let path = "/datasets";
                let datasetId_ = datasetId;
                if (void 0 !== datasetId && void 0 !== datasetName) throw new Error("Must provide either datasetName or datasetId, not both");
                if (void 0 !== datasetName) {
                    const dataset = await this.readDataset({
                        datasetName
                    });
                    datasetId_ = dataset.id;
                }
                if (void 0 !== datasetId_) {
                    assertUuid(datasetId_);
                    path += `/${datasetId_}`;
                } else throw new Error("Must provide datasetName or datasetId");
                const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
                    method: "DELETE",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, `delete ${path}`);
                await response.json();
            }
            async indexDataset({ datasetId, datasetName, tag }) {
                let datasetId_ = datasetId;
                if (datasetId_ || datasetName) {
                    if (datasetId_ && datasetName) throw new Error("Must provide either datasetName or datasetId, not both");
                    if (!datasetId_) {
                        const dataset = await this.readDataset({
                            datasetName
                        });
                        datasetId_ = dataset.id;
                    }
                } else throw new Error("Must provide either datasetName or datasetId");
                assertUuid(datasetId_);
                const data = {
                    tag: tag
                };
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId_}/index`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(data),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "index dataset");
                await response.json();
            }
            async similarExamples(inputs, datasetId, limit, { filter } = {}) {
                const data = {
                    limit: limit,
                    inputs: inputs
                };
                if (void 0 !== filter) data["filter"] = filter;
                assertUuid(datasetId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/search`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(data),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "fetch similar examples");
                const result = await response.json();
                return result["examples"];
            }
            async createExample(inputsOrUpdate, outputs, options) {
                if (isExampleCreate(inputsOrUpdate)) {
                    if (void 0 !== outputs || void 0 !== options) throw new Error("Cannot provide outputs or options when using ExampleCreate object");
                }
                let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;
                const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;
                if (void 0 === datasetId_ && void 0 === datasetName_) throw new Error("Must provide either datasetName or datasetId");
                if (void 0 !== datasetId_ && void 0 !== datasetName_) throw new Error("Must provide either datasetName or datasetId, not both");
                if (void 0 === datasetId_) {
                    const dataset = await this.readDataset({
                        datasetName: datasetName_
                    });
                    datasetId_ = dataset.id;
                }
                const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();
                let data;
                data = isExampleCreate(inputsOrUpdate) ? inputsOrUpdate : {
                    inputs: inputsOrUpdate,
                    outputs,
                    created_at: createdAt_?.toISOString(),
                    id: options?.exampleId,
                    metadata: options?.metadata,
                    split: options?.split,
                    source_run_id: options?.sourceRunId,
                    use_source_run_io: options?.useSourceRunIO,
                    use_source_run_attachments: options?.useSourceRunAttachments,
                    attachments: options?.attachments
                };
                const response = await this._uploadExamplesMultipart(datasetId_, [
                    data
                ]);
                const example = await this.readExample(response.example_ids?.[0] ?? dist_esm_node_v4());
                return example;
            }
            async createExamples(propsOrUploads) {
                if (Array.isArray(propsOrUploads)) {
                    if (0 === propsOrUploads.length) return [];
                    const uploads = propsOrUploads;
                    let datasetId_ = uploads[0].dataset_id;
                    const datasetName_ = uploads[0].dataset_name;
                    if (void 0 === datasetId_ && void 0 === datasetName_) throw new Error("Must provide either datasetName or datasetId");
                    if (void 0 !== datasetId_ && void 0 !== datasetName_) throw new Error("Must provide either datasetName or datasetId, not both");
                    if (void 0 === datasetId_) {
                        const dataset = await this.readDataset({
                            datasetName: datasetName_
                        });
                        datasetId_ = dataset.id;
                    }
                    const response = await this._uploadExamplesMultipart(datasetId_, uploads);
                    const examples = await Promise.all(response.example_ids.map((id)=>this.readExample(id)));
                    return examples;
                }
                const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;
                if (void 0 === inputs) throw new Error("Must provide inputs when using legacy parameters");
                let datasetId_ = datasetId;
                const datasetName_ = datasetName;
                if (void 0 === datasetId_ && void 0 === datasetName_) throw new Error("Must provide either datasetName or datasetId");
                if (void 0 !== datasetId_ && void 0 !== datasetName_) throw new Error("Must provide either datasetName or datasetId, not both");
                if (void 0 === datasetId_) {
                    const dataset = await this.readDataset({
                        datasetName: datasetName_
                    });
                    datasetId_ = dataset.id;
                }
                const formattedExamples = inputs.map((input, idx)=>({
                        dataset_id: datasetId_,
                        inputs: input,
                        outputs: outputs?.[idx],
                        metadata: metadata?.[idx],
                        split: splits?.[idx],
                        id: exampleIds?.[idx],
                        attachments: attachments?.[idx],
                        source_run_id: sourceRunIds?.[idx],
                        use_source_run_io: useSourceRunIOs?.[idx],
                        use_source_run_attachments: useSourceRunAttachments?.[idx]
                    }));
                const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);
                const examples = await Promise.all(response.example_ids.map((id)=>this.readExample(id)));
                return examples;
            }
            async createLLMExample(input, generation, options) {
                return this.createExample({
                    input
                }, {
                    output: generation
                }, options);
            }
            async createChatExample(input, generations, options) {
                const finalInput = input.map((message)=>{
                    if (isLangChainMessage(message)) return convertLangChainMessageToExample(message);
                    return message;
                });
                const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
                return this.createExample({
                    input: finalInput
                }, {
                    output: finalOutput
                }, options);
            }
            async readExample(exampleId) {
                assertUuid(exampleId);
                const path = `/examples/${exampleId}`;
                const rawExample = await this._get(path);
                const { attachment_urls, ...rest } = rawExample;
                const example = rest;
                if (attachment_urls) example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value])=>{
                    acc[key.slice("attachment.".length)] = {
                        presigned_url: value.presigned_url,
                        mime_type: value.mime_type
                    };
                    return acc;
                }, {});
                return example;
            }
            async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments } = {}) {
                let datasetId_;
                if (void 0 !== datasetId && void 0 !== datasetName) throw new Error("Must provide either datasetName or datasetId, not both");
                if (void 0 !== datasetId) datasetId_ = datasetId;
                else if (void 0 !== datasetName) {
                    const dataset = await this.readDataset({
                        datasetName
                    });
                    datasetId_ = dataset.id;
                } else throw new Error("Must provide a datasetName or datasetId");
                const params = new URLSearchParams({
                    dataset: datasetId_
                });
                const dataset_version = asOf ? "string" == typeof asOf ? asOf : asOf?.toISOString() : void 0;
                if (dataset_version) params.append("as_of", dataset_version);
                const inlineS3Urls_ = inlineS3Urls ?? true;
                params.append("inline_s3_urls", inlineS3Urls_.toString());
                if (void 0 !== exampleIds) for (const id_ of exampleIds)params.append("id", id_);
                if (void 0 !== splits) for (const split of splits)params.append("splits", split);
                if (void 0 !== metadata) {
                    const serializedMetadata = JSON.stringify(metadata);
                    params.append("metadata", serializedMetadata);
                }
                if (void 0 !== limit) params.append("limit", limit.toString());
                if (void 0 !== offset) params.append("offset", offset.toString());
                if (void 0 !== filter) params.append("filter", filter);
                if (true === includeAttachments) [
                    "attachment_urls",
                    "outputs",
                    "metadata"
                ].forEach((field)=>params.append("select", field));
                let i = 0;
                for await (const rawExamples of this._getPaginated("/examples", params)){
                    for (const rawExample of rawExamples){
                        const { attachment_urls, ...rest } = rawExample;
                        const example = rest;
                        if (attachment_urls) example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value])=>{
                            acc[key.slice("attachment.".length)] = {
                                presigned_url: value.presigned_url,
                                mime_type: value.mime_type || void 0
                            };
                            return acc;
                        }, {});
                        yield example;
                        i++;
                    }
                    if (void 0 !== limit && i >= limit) break;
                }
            }
            async deleteExample(exampleId) {
                assertUuid(exampleId);
                const path = `/examples/${exampleId}`;
                const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
                    method: "DELETE",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, `delete ${path}`);
                await response.json();
            }
            async updateExample(exampleIdOrUpdate, update) {
                let exampleId;
                exampleId = update ? exampleIdOrUpdate : exampleIdOrUpdate.id;
                assertUuid(exampleId);
                let updateToUse;
                updateToUse = update ? {
                    id: exampleId,
                    ...update
                } : exampleIdOrUpdate;
                let datasetId;
                if (void 0 !== updateToUse.dataset_id) datasetId = updateToUse.dataset_id;
                else {
                    const example = await this.readExample(exampleId);
                    datasetId = example.dataset_id;
                }
                return this._updateExamplesMultipart(datasetId, [
                    updateToUse
                ]);
            }
            async updateExamples(update) {
                let datasetId;
                if (void 0 === update[0].dataset_id) {
                    const example = await this.readExample(update[0].id);
                    datasetId = example.dataset_id;
                } else datasetId = update[0].dataset_id;
                return this._updateExamplesMultipart(datasetId, update);
            }
            async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {
                let resolvedDatasetId;
                if (datasetId) resolvedDatasetId = datasetId;
                else {
                    const dataset = await this.readDataset({
                        datasetName
                    });
                    resolvedDatasetId = dataset.id;
                }
                assertUuid(resolvedDatasetId);
                if (asOf && tag || !asOf && !tag) throw new Error("Exactly one of asOf and tag must be specified.");
                const params = new URLSearchParams();
                if (void 0 !== asOf) params.append("as_of", "string" == typeof asOf ? asOf : asOf.toISOString());
                if (void 0 !== tag) params.append("tag", tag);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {
                    method: "GET",
                    headers: {
                        ...this.headers
                    },
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "read dataset version");
                return await response.json();
            }
            async listDatasetSplits({ datasetId, datasetName, asOf }) {
                let datasetId_;
                if (void 0 === datasetId && void 0 === datasetName) throw new Error("Must provide dataset name or ID");
                if (void 0 !== datasetId && void 0 !== datasetName) throw new Error("Must provide either datasetName or datasetId, not both");
                if (void 0 === datasetId) {
                    const dataset = await this.readDataset({
                        datasetName
                    });
                    datasetId_ = dataset.id;
                } else datasetId_ = datasetId;
                assertUuid(datasetId_);
                const params = new URLSearchParams();
                const dataset_version = asOf ? "string" == typeof asOf ? asOf : asOf?.toISOString() : void 0;
                if (dataset_version) params.append("as_of", dataset_version);
                const response = await this._get(`/datasets/${datasetId_}/splits`, params);
                return response;
            }
            async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {
                let datasetId_;
                if (void 0 === datasetId && void 0 === datasetName) throw new Error("Must provide dataset name or ID");
                if (void 0 !== datasetId && void 0 !== datasetName) throw new Error("Must provide either datasetName or datasetId, not both");
                if (void 0 === datasetId) {
                    const dataset = await this.readDataset({
                        datasetName
                    });
                    datasetId_ = dataset.id;
                } else datasetId_ = datasetId;
                assertUuid(datasetId_);
                const data = {
                    split_name: splitName,
                    examples: exampleIds.map((id)=>{
                        assertUuid(id);
                        return id;
                    }),
                    remove
                };
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId_}/splits`, {
                    method: "PUT",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(data),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "update dataset splits", true);
            }
            async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {
                loadChildRuns: false
            }) {
                warnOnce("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
                let run_;
                if ("string" == typeof run) run_ = await this.readRun(run, {
                    loadChildRuns
                });
                else if ("object" == typeof run && "id" in run) run_ = run;
                else throw new Error(`Invalid run type: ${typeof run}`);
                if (null !== run_.reference_example_id && void 0 !== run_.reference_example_id) referenceExample = await this.readExample(run_.reference_example_id);
                const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
                const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
                return feedbacks[0];
            }
            async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
                if (!runId && !projectId) throw new Error("One of runId or projectId must be provided");
                if (runId && projectId) throw new Error("Only one of runId or projectId can be provided");
                const feedback_source = {
                    type: feedbackSourceType ?? "api",
                    metadata: sourceInfo ?? {}
                };
                if (void 0 !== sourceRunId && feedback_source?.metadata !== void 0 && !feedback_source.metadata["__run"]) feedback_source.metadata["__run"] = {
                    run_id: sourceRunId
                };
                if (feedback_source?.metadata !== void 0 && feedback_source.metadata["__run"]?.run_id !== void 0) assertUuid(feedback_source.metadata["__run"].run_id);
                const feedback = {
                    id: feedbackId ?? dist_esm_node_v4(),
                    run_id: runId,
                    key,
                    score: _formatFeedbackScore(score),
                    value,
                    correction,
                    comment,
                    feedback_source: feedback_source,
                    comparative_experiment_id: comparativeExperimentId,
                    feedbackConfig,
                    session_id: projectId
                };
                const url = `${this.apiUrl}/feedback`;
                const response = await this.caller.call(_getFetchImplementation(), url, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(feedback),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "create feedback", true);
                return feedback;
            }
            async updateFeedback(feedbackId, { score, value, correction, comment }) {
                const feedbackUpdate = {};
                if (null != score) feedbackUpdate["score"] = _formatFeedbackScore(score);
                if (null != value) feedbackUpdate["value"] = value;
                if (null != correction) feedbackUpdate["correction"] = correction;
                if (null != comment) feedbackUpdate["comment"] = comment;
                assertUuid(feedbackId);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/feedback/${feedbackId}`, {
                    method: "PATCH",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(feedbackUpdate),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "update feedback", true);
            }
            async readFeedback(feedbackId) {
                assertUuid(feedbackId);
                const path = `/feedback/${feedbackId}`;
                const response = await this._get(path);
                return response;
            }
            async deleteFeedback(feedbackId) {
                assertUuid(feedbackId);
                const path = `/feedback/${feedbackId}`;
                const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
                    method: "DELETE",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, `delete ${path}`);
                await response.json();
            }
            async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
                const queryParams = new URLSearchParams();
                if (runIds) queryParams.append("run", runIds.join(","));
                if (feedbackKeys) for (const key of feedbackKeys)queryParams.append("key", key);
                if (feedbackSourceTypes) for (const type of feedbackSourceTypes)queryParams.append("source", type);
                for await (const feedbacks of this._getPaginated("/feedback", queryParams))yield* feedbacks;
            }
            async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
                const body = {
                    run_id: runId,
                    feedback_key: feedbackKey,
                    feedback_config: feedbackConfig
                };
                if (expiration) {
                    if ("string" == typeof expiration) body["expires_at"] = expiration;
                    else if (expiration?.hours || expiration?.minutes || expiration?.days) body["expires_in"] = expiration;
                } else body["expires_in"] = {
                    hours: 3
                };
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/feedback/tokens`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(body),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const result = await response.json();
                return result;
            }
            async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {
                if (0 === experimentIds.length) throw new Error("At least one experiment is required");
                if (!referenceDatasetId) referenceDatasetId = (await this.readProject({
                    projectId: experimentIds[0]
                })).reference_dataset_id;
                if (null == !referenceDatasetId) throw new Error("A reference dataset is required");
                const body = {
                    id,
                    name,
                    experiment_ids: experimentIds,
                    reference_dataset_id: referenceDatasetId,
                    description,
                    created_at: (createdAt ?? new Date())?.toISOString(),
                    extra: {}
                };
                if (metadata) body.extra["metadata"] = metadata;
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/comparative`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(body),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                return await response.json();
            }
            async *listPresignedFeedbackTokens(runId) {
                assertUuid(runId);
                const params = new URLSearchParams({
                    run_id: runId
                });
                for await (const tokens of this._getPaginated("/feedback/tokens", params))yield* tokens;
            }
            _selectEvalResults(results) {
                let results_;
                results_ = "results" in results ? results.results : Array.isArray(results) ? results : [
                    results
                ];
                return results_;
            }
            async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
                const evalResults = this._selectEvalResults(evaluatorResponse);
                const feedbacks = [];
                for (const res of evalResults){
                    let sourceInfo_ = sourceInfo || {};
                    if (res.evaluatorInfo) sourceInfo_ = {
                        ...res.evaluatorInfo,
                        ...sourceInfo_
                    };
                    let runId_ = null;
                    if (res.targetRunId) runId_ = res.targetRunId;
                    else if (run) runId_ = run.id;
                    feedbacks.push(await this.createFeedback(runId_, res.key, {
                        score: res.score,
                        value: res.value,
                        comment: res.comment,
                        correction: res.correction,
                        sourceInfo: sourceInfo_,
                        sourceRunId: res.sourceRunId,
                        feedbackConfig: res.feedbackConfig,
                        feedbackSourceType: "model"
                    }));
                }
                return [
                    evalResults,
                    feedbacks
                ];
            }
            async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
                const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
                return results;
            }
            async *listAnnotationQueues(options = {}) {
                const { queueIds, name, nameContains, limit } = options;
                const params = new URLSearchParams();
                if (queueIds) queueIds.forEach((id, i)=>{
                    assertUuid(id, `queueIds[${i}]`);
                    params.append("ids", id);
                });
                if (name) params.append("name", name);
                if (nameContains) params.append("name_contains", nameContains);
                params.append("limit", (void 0 !== limit ? Math.min(limit, 100) : 100).toString());
                let count = 0;
                for await (const queues of this._getPaginated("/annotation-queues", params)){
                    yield* queues;
                    count++;
                    if (void 0 !== limit && count >= limit) break;
                }
            }
            async createAnnotationQueue(options) {
                const { name, description, queueId } = options;
                const body = {
                    name,
                    description,
                    id: queueId || dist_esm_node_v4()
                };
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v])=>void 0 !== v))),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "create annotation queue");
                const data = await response.json();
                return data;
            }
            async readAnnotationQueue(queueId) {
                const queueIteratorResult = await this.listAnnotationQueues({
                    queueIds: [
                        queueId
                    ]
                }).next();
                if (queueIteratorResult.done) throw new Error(`Annotation queue with ID ${queueId} not found`);
                return queueIteratorResult.value;
            }
            async updateAnnotationQueue(queueId, options) {
                const { name, description } = options;
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
                    method: "PATCH",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        name,
                        description
                    }),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "update annotation queue");
            }
            async deleteAnnotationQueue(queueId) {
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
                    method: "DELETE",
                    headers: {
                        ...this.headers,
                        Accept: "application/json"
                    },
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "delete annotation queue");
            }
            async addRunsToAnnotationQueue(queueId, runIds) {
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(runIds.map((id, i)=>assertUuid(id, `runIds[${i}]`).toString())),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "add runs to annotation queue");
            }
            async getRunFromAnnotationQueue(queueId, index) {
                const baseUrl = `/annotation-queues/${assertUuid(queueId, "queueId")}/run`;
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${baseUrl}/${index}`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "get run from annotation queue");
                return await response.json();
            }
            async deleteRunFromAnnotationQueue(queueId, queueRunId) {
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs/${assertUuid(queueRunId, "queueRunId")}`, {
                    method: "DELETE",
                    headers: {
                        ...this.headers,
                        Accept: "application/json"
                    },
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "delete run from annotation queue");
            }
            async getSizeFromAnnotationQueue(queueId) {
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/size`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "get size from annotation queue");
                return await response.json();
            }
            async _currentTenantIsOwner(owner) {
                const settings = await this._getSettings();
                return "-" == owner || settings.tenant_handle === owner;
            }
            async _ownerConflictError(action, owner) {
                const settings = await this._getSettings();
                return new Error(`Cannot ${action} for another tenant.\n
      Current tenant: ${settings.tenant_handle}\n
      Requested tenant: ${owner}`);
            }
            async _getLatestCommitHash(promptOwnerAndName) {
                const res = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=1&offset=0`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                const json = await res.json();
                if (!res.ok) {
                    const detail = "string" == typeof json.detail ? json.detail : JSON.stringify(json.detail);
                    const error = new Error(`Error ${res.status}: ${res.statusText}\n${detail}`);
                    error.statusCode = res.status;
                    throw error;
                }
                if (0 === json.commits.length) return;
                return json.commits[0].commit_hash;
            }
            async _likeOrUnlikePrompt(promptIdentifier, like) {
                const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/likes/${owner}/${promptName}`, {
                    method: "POST",
                    body: JSON.stringify({
                        like: like
                    }),
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, `${like ? "like" : "unlike"} prompt`);
                return await response.json();
            }
            async _getPromptUrl(promptIdentifier) {
                const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
                if (await this._currentTenantIsOwner(owner)) {
                    const settings = await this._getSettings();
                    if ("latest" !== commitHash) return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
                    return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
                }
                if ("latest" !== commitHash) return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
            }
            async promptExists(promptIdentifier) {
                const prompt = await this.getPrompt(promptIdentifier);
                return !!prompt;
            }
            async likePrompt(promptIdentifier) {
                return this._likeOrUnlikePrompt(promptIdentifier, true);
            }
            async unlikePrompt(promptIdentifier) {
                return this._likeOrUnlikePrompt(promptIdentifier, false);
            }
            async *listCommits(promptOwnerAndName) {
                for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res)=>res.commits))yield* commits;
            }
            async *listPrompts(options) {
                const params = new URLSearchParams();
                params.append("sort_field", options?.sortField ?? "updated_at");
                params.append("sort_direction", "desc");
                params.append("is_archived", (!!options?.isArchived).toString());
                if (options?.isPublic !== void 0) params.append("is_public", options.isPublic.toString());
                if (options?.query) params.append("query", options.query);
                for await (const prompts of this._getPaginated("/repos", params, (res)=>res.repos))yield* prompts;
            }
            async getPrompt(promptIdentifier) {
                const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                if (404 === response.status) return null;
                await raiseForStatus(response, "get prompt");
                const result = await response.json();
                if (result.repo) return result.repo;
                return null;
            }
            async createPrompt(promptIdentifier, options) {
                const settings = await this._getSettings();
                if (options?.isPublic && !settings.tenant_handle) throw new Error(`Cannot create a public prompt without first\n
        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:\n
        https://smith.langchain.com/prompts`);
                const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
                if (!await this._currentTenantIsOwner(owner)) throw await this._ownerConflictError("create a prompt", owner);
                const data = {
                    repo_handle: promptName,
                    ...options?.description && {
                        description: options.description
                    },
                    ...options?.readme && {
                        readme: options.readme
                    },
                    ...options?.tags && {
                        tags: options.tags
                    },
                    is_public: !!options?.isPublic
                };
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(data),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "create prompt");
                const { repo } = await response.json();
                return repo;
            }
            async createCommit(promptIdentifier, object, options) {
                if (!await this.promptExists(promptIdentifier)) throw new Error("Prompt does not exist, you must create it first.");
                const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
                const resolvedParentCommitHash = options?.parentCommitHash !== "latest" && options?.parentCommitHash ? options?.parentCommitHash : await this._getLatestCommitHash(`${owner}/${promptName}`);
                const payload = {
                    manifest: JSON.parse(JSON.stringify(object)),
                    parent_commit: resolvedParentCommitHash
                };
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${owner}/${promptName}`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(payload),
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "create commit");
                const result = await response.json();
                return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
            }
            async updateExamplesMultipart(datasetId, updates = []) {
                return this._updateExamplesMultipart(datasetId, updates);
            }
            async _updateExamplesMultipart(datasetId, updates = []) {
                if (!await this._getMultiPartSupport()) throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
                const formData = new FormData();
                for (const example of updates){
                    const exampleId = example.id;
                    const exampleBody = {
                        ...example.metadata && {
                            metadata: example.metadata
                        },
                        ...example.split && {
                            split: example.split
                        }
                    };
                    const stringifiedExample = serialize(exampleBody);
                    const exampleBlob = new Blob([
                        stringifiedExample
                    ], {
                        type: "application/json"
                    });
                    formData.append(exampleId, exampleBlob);
                    if (example.inputs) {
                        const stringifiedInputs = serialize(example.inputs);
                        const inputsBlob = new Blob([
                            stringifiedInputs
                        ], {
                            type: "application/json"
                        });
                        formData.append(`${exampleId}.inputs`, inputsBlob);
                    }
                    if (example.outputs) {
                        const stringifiedOutputs = serialize(example.outputs);
                        const outputsBlob = new Blob([
                            stringifiedOutputs
                        ], {
                            type: "application/json"
                        });
                        formData.append(`${exampleId}.outputs`, outputsBlob);
                    }
                    if (example.attachments) for (const [name, attachment] of Object.entries(example.attachments)){
                        let mimeType;
                        let data;
                        if (Array.isArray(attachment)) [mimeType, data] = attachment;
                        else {
                            mimeType = attachment.mimeType;
                            data = attachment.data;
                        }
                        const attachmentBlob = new Blob([
                            data
                        ], {
                            type: `${mimeType}; length=${data.byteLength}`
                        });
                        formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
                    }
                    if (example.attachments_operations) {
                        const stringifiedAttachmentsOperations = serialize(example.attachments_operations);
                        const attachmentsOperationsBlob = new Blob([
                            stringifiedAttachmentsOperations
                        ], {
                            type: "application/json"
                        });
                        formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);
                    }
                }
                const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/v1/platform/datasets/${datasetIdToUse}/examples`, {
                    method: "PATCH",
                    headers: this.headers,
                    body: formData
                });
                const result = await response.json();
                return result;
            }
            async uploadExamplesMultipart(datasetId, uploads = []) {
                return this._uploadExamplesMultipart(datasetId, uploads);
            }
            async _uploadExamplesMultipart(datasetId, uploads = []) {
                if (!await this._getMultiPartSupport()) throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
                const formData = new FormData();
                for (const example of uploads){
                    const exampleId = (example.id ?? dist_esm_node_v4()).toString();
                    const exampleBody = {
                        created_at: example.created_at,
                        ...example.metadata && {
                            metadata: example.metadata
                        },
                        ...example.split && {
                            split: example.split
                        },
                        ...example.source_run_id && {
                            source_run_id: example.source_run_id
                        },
                        ...example.use_source_run_io && {
                            use_source_run_io: example.use_source_run_io
                        },
                        ...example.use_source_run_attachments && {
                            use_source_run_attachments: example.use_source_run_attachments
                        }
                    };
                    const stringifiedExample = serialize(exampleBody);
                    const exampleBlob = new Blob([
                        stringifiedExample
                    ], {
                        type: "application/json"
                    });
                    formData.append(exampleId, exampleBlob);
                    if (example.inputs) {
                        const stringifiedInputs = serialize(example.inputs);
                        const inputsBlob = new Blob([
                            stringifiedInputs
                        ], {
                            type: "application/json"
                        });
                        formData.append(`${exampleId}.inputs`, inputsBlob);
                    }
                    if (example.outputs) {
                        const stringifiedOutputs = serialize(example.outputs);
                        const outputsBlob = new Blob([
                            stringifiedOutputs
                        ], {
                            type: "application/json"
                        });
                        formData.append(`${exampleId}.outputs`, outputsBlob);
                    }
                    if (example.attachments) for (const [name, attachment] of Object.entries(example.attachments)){
                        let mimeType;
                        let data;
                        if (Array.isArray(attachment)) [mimeType, data] = attachment;
                        else {
                            mimeType = attachment.mimeType;
                            data = attachment.data;
                        }
                        const attachmentBlob = new Blob([
                            data
                        ], {
                            type: `${mimeType}; length=${data.byteLength}`
                        });
                        formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
                    }
                }
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/v1/platform/datasets/${datasetId}/examples`, {
                    method: "POST",
                    headers: this.headers,
                    body: formData
                });
                const result = await response.json();
                return result;
            }
            async updatePrompt(promptIdentifier, options) {
                if (!await this.promptExists(promptIdentifier)) throw new Error("Prompt does not exist, you must create it first.");
                const [owner, promptName] = parsePromptIdentifier(promptIdentifier);
                if (!await this._currentTenantIsOwner(owner)) throw await this._ownerConflictError("update a prompt", owner);
                const payload = {};
                if (options?.description !== void 0) payload.description = options.description;
                if (options?.readme !== void 0) payload.readme = options.readme;
                if (options?.tags !== void 0) payload.tags = options.tags;
                if (options?.isPublic !== void 0) payload.is_public = options.isPublic;
                if (options?.isArchived !== void 0) payload.is_archived = options.isArchived;
                if (0 === Object.keys(payload).length) throw new Error("No valid update options provided");
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
                    method: "PATCH",
                    body: JSON.stringify(payload),
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "update prompt");
                return response.json();
            }
            async deletePrompt(promptIdentifier) {
                if (!await this.promptExists(promptIdentifier)) throw new Error("Prompt does not exist, you must create it first.");
                const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
                if (!await this._currentTenantIsOwner(owner)) throw await this._ownerConflictError("delete a prompt", owner);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
                    method: "DELETE",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                return await response.json();
            }
            async pullPromptCommit(promptIdentifier, options) {
                const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
                const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? "?include_model=true" : ""}`, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await raiseForStatus(response, "pull prompt commit");
                const result = await response.json();
                return {
                    owner,
                    repo: promptName,
                    commit_hash: result.commit_hash,
                    manifest: result.manifest,
                    examples: result.examples
                };
            }
            async _pullPrompt(promptIdentifier, options) {
                const promptObject = await this.pullPromptCommit(promptIdentifier, {
                    includeModel: options?.includeModel
                });
                const prompt = JSON.stringify(promptObject.manifest);
                return prompt;
            }
            async pushPrompt(promptIdentifier, options) {
                if (await this.promptExists(promptIdentifier)) {
                    if (options && Object.keys(options).some((key)=>"object" !== key)) await this.updatePrompt(promptIdentifier, {
                        description: options?.description,
                        readme: options?.readme,
                        tags: options?.tags,
                        isPublic: options?.isPublic
                    });
                } else await this.createPrompt(promptIdentifier, {
                    description: options?.description,
                    readme: options?.readme,
                    tags: options?.tags,
                    isPublic: options?.isPublic
                });
                if (!options?.object) return await this._getPromptUrl(promptIdentifier);
                const url = await this.createCommit(promptIdentifier, options?.object, {
                    parentCommitHash: options?.parentCommitHash
                });
                return url;
            }
            async clonePublicDataset(tokenOrUrl, options = {}) {
                const { sourceApiUrl = this.apiUrl, datasetName } = options;
                const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
                const sourceClient = new Client({
                    apiUrl: parsedApiUrl,
                    apiKey: "placeholder"
                });
                const ds = await sourceClient.readSharedDataset(tokenUuid);
                const finalDatasetName = datasetName || ds.name;
                try {
                    if (await this.hasDataset({
                        datasetId: finalDatasetName
                    })) {
                        console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
                        return;
                    }
                } catch (_) {}
                const examples = await sourceClient.listSharedExamples(tokenUuid);
                const dataset = await this.createDataset(finalDatasetName, {
                    description: ds.description,
                    dataType: ds.data_type || "kv",
                    inputsSchema: ds.inputs_schema_definition ?? void 0,
                    outputsSchema: ds.outputs_schema_definition ?? void 0
                });
                try {
                    await this.createExamples({
                        inputs: examples.map((e)=>e.inputs),
                        outputs: examples.flatMap((e)=>e.outputs ? [
                                e.outputs
                            ] : []),
                        datasetId: dataset.id
                    });
                } catch (e) {
                    console.error(`An error occurred while creating dataset ${finalDatasetName}. You should delete it manually.`);
                    throw e;
                }
            }
            parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = "dataset") {
                try {
                    assertUuid(urlOrToken);
                    return [
                        apiUrl,
                        urlOrToken
                    ];
                } catch (_) {}
                try {
                    const parsedUrl = new URL(urlOrToken);
                    const pathParts = parsedUrl.pathname.split("/").filter((part)=>"" !== part);
                    if (pathParts.length >= numParts) {
                        const tokenUuid = pathParts[pathParts.length - numParts];
                        return [
                            apiUrl,
                            tokenUuid
                        ];
                    }
                    throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);
                } catch (error) {
                    throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);
                }
            }
            awaitPendingTraceBatches() {
                if (this.manualFlushMode) {
                    console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.");
                    return Promise.resolve();
                }
                return Promise.all([
                    ...this.autoBatchQueue.items.map(({ itemPromise })=>itemPromise),
                    this.batchIngestCaller.queue.onIdle()
                ]);
            }
        }
        function isExampleCreate(input) {
            return "dataset_id" in input || "dataset_name" in input;
        }
        const __version__ = "0.3.14";
        let globalEnv;
        const isBrowser = ()=>"undefined" != typeof window && void 0 !== window.document;
        const isWebWorker = ()=>"object" == typeof globalThis && globalThis.constructor && "DedicatedWorkerGlobalScope" === globalThis.constructor.name;
        const isJsDom = ()=>"undefined" != typeof window && "nodejs" === window.name || "undefined" != typeof navigator && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
        const isDeno = ()=>"undefined" != typeof Deno;
        const isNode = ()=>"undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node && !isDeno();
        const getEnv = ()=>{
            if (globalEnv) return globalEnv;
            globalEnv = isBrowser() ? "browser" : isNode() ? "node" : isWebWorker() ? "webworker" : isJsDom() ? "jsdom" : isDeno() ? "deno" : "other";
            return globalEnv;
        };
        let runtimeEnvironment;
        function getRuntimeEnvironment() {
            if (void 0 === runtimeEnvironment) {
                const env = getEnv();
                const releaseEnv = getShas();
                runtimeEnvironment = {
                    library: "langsmith",
                    runtime: env,
                    sdk: "langsmith-js",
                    sdk_version: __version__,
                    ...releaseEnv
                };
            }
            return runtimeEnvironment;
        }
        function getLangChainEnvVarsMetadata() {
            const allEnvVars = getEnvironmentVariables() || {};
            const envVars = {};
            const excluded = [
                "LANGCHAIN_API_KEY",
                "LANGCHAIN_ENDPOINT",
                "LANGCHAIN_TRACING_V2",
                "LANGCHAIN_PROJECT",
                "LANGCHAIN_SESSION",
                "LANGSMITH_API_KEY",
                "LANGSMITH_ENDPOINT",
                "LANGSMITH_TRACING_V2",
                "LANGSMITH_PROJECT",
                "LANGSMITH_SESSION"
            ];
            for (const [key, value] of Object.entries(allEnvVars))if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && "string" == typeof value && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
                if ("LANGCHAIN_REVISION_ID" === key) envVars["revision_id"] = value;
                else envVars[key] = value;
            }
            return envVars;
        }
        function getEnvironmentVariables() {
            try {
                if ("undefined" != typeof process && process.env) return Object.entries(process.env).reduce((acc, [key, value])=>{
                    acc[key] = String(value);
                    return acc;
                }, {});
                return;
            } catch (e) {
                return;
            }
        }
        function getEnvironmentVariable(name) {
            try {
                return "undefined" != typeof process ? process.env?.[name] : void 0;
            } catch (e) {
                return;
            }
        }
        function getLangSmithEnvironmentVariable(name) {
            return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);
        }
        let cachedCommitSHAs;
        function getShas() {
            if (void 0 !== cachedCommitSHAs) return cachedCommitSHAs;
            const common_release_envs = [
                "VERCEL_GIT_COMMIT_SHA",
                "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
                "COMMIT_REF",
                "RENDER_GIT_COMMIT",
                "CI_COMMIT_SHA",
                "CIRCLE_SHA1",
                "CF_PAGES_COMMIT_SHA",
                "REACT_APP_GIT_SHA",
                "SOURCE_VERSION",
                "GITHUB_SHA",
                "TRAVIS_COMMIT",
                "GIT_COMMIT",
                "BUILD_VCS_NUMBER",
                "bamboo_planRepository_revision",
                "Build.SourceVersion",
                "BITBUCKET_COMMIT",
                "DRONE_COMMIT_SHA",
                "SEMAPHORE_GIT_SHA",
                "BUILDKITE_COMMIT"
            ];
            const shas = {};
            for (const env of common_release_envs){
                const envVar = getEnvironmentVariable(env);
                if (void 0 !== envVar) shas[env] = envVar;
            }
            cachedCommitSHAs = shas;
            return shas;
        }
        const isTracingEnabled = (tracingEnabled)=>{
            if (void 0 !== tracingEnabled) return tracingEnabled;
            const envVars = [
                "TRACING_V2",
                "TRACING"
            ];
            return !!envVars.find((envVar)=>"true" === getLangSmithEnvironmentVariable(envVar));
        };
        const _LC_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
        function stripNonAlphanumeric(input) {
            return input.replace(/[-:.]/g, "");
        }
        function convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {
            const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
            return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
        }
        class Baggage {
            constructor(metadata, tags){
                Object.defineProperty(this, "metadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "tags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.metadata = metadata;
                this.tags = tags;
            }
            static fromHeader(value) {
                const items = value.split(",");
                let metadata = {};
                let tags = [];
                for (const item of items){
                    const [key, uriValue] = item.split("=");
                    const value = decodeURIComponent(uriValue);
                    if ("langsmith-metadata" === key) metadata = JSON.parse(value);
                    else if ("langsmith-tags" === key) tags = value.split(",");
                }
                return new Baggage(metadata, tags);
            }
            toHeader() {
                const items = [];
                if (this.metadata && Object.keys(this.metadata).length > 0) items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
                if (this.tags && this.tags.length > 0) items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
                return items.join(",");
            }
        }
        class run_trees_RunTree {
            constructor(originalConfig){
                Object.defineProperty(this, "id", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "run_type", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "project_name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "parent_run", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "child_runs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "start_time", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "end_time", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "extra", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "tags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "error", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "serialized", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "inputs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "outputs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "reference_example_id", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "client", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "events", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "trace_id", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "dotted_order", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "tracingEnabled", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "execution_order", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "child_execution_order", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "attachments", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                if (run_trees_isRunTree(originalConfig)) {
                    Object.assign(this, {
                        ...originalConfig
                    });
                    return;
                }
                const defaultConfig = run_trees_RunTree.getDefaultConfig();
                const { metadata, ...config } = originalConfig;
                const client = config.client ?? run_trees_RunTree.getSharedClient();
                const dedupedMetadata = {
                    ...metadata,
                    ...config?.extra?.metadata
                };
                config.extra = {
                    ...config.extra,
                    metadata: dedupedMetadata
                };
                Object.assign(this, {
                    ...defaultConfig,
                    ...config,
                    client
                });
                if (!this.trace_id) {
                    if (this.parent_run) this.trace_id = this.parent_run.trace_id ?? this.id;
                    else this.trace_id = this.id;
                }
                this.execution_order ??= 1;
                this.child_execution_order ??= 1;
                if (!this.dotted_order) {
                    const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);
                    if (this.parent_run) this.dotted_order = this.parent_run.dotted_order + "." + currentDottedOrder;
                    else this.dotted_order = currentDottedOrder;
                }
            }
            static getDefaultConfig() {
                return {
                    id: dist_esm_node_v4(),
                    run_type: "chain",
                    project_name: getLangSmithEnvironmentVariable("PROJECT") ?? getEnvironmentVariable("LANGCHAIN_SESSION") ?? "default",
                    child_runs: [],
                    api_url: getEnvironmentVariable("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
                    api_key: getEnvironmentVariable("LANGCHAIN_API_KEY"),
                    caller_options: {},
                    start_time: Date.now(),
                    serialized: {},
                    inputs: {},
                    extra: {}
                };
            }
            static getSharedClient() {
                if (!run_trees_RunTree.sharedClient) run_trees_RunTree.sharedClient = new Client();
                return run_trees_RunTree.sharedClient;
            }
            createChild(config) {
                const child_execution_order = this.child_execution_order + 1;
                const child = new run_trees_RunTree({
                    ...config,
                    parent_run: this,
                    project_name: this.project_name,
                    client: this.client,
                    tracingEnabled: this.tracingEnabled,
                    execution_order: child_execution_order,
                    child_execution_order: child_execution_order
                });
                if (_LC_CONTEXT_VARIABLES_KEY in this) child[_LC_CONTEXT_VARIABLES_KEY] = this[_LC_CONTEXT_VARIABLES_KEY];
                const LC_CHILD = Symbol.for("lc:child_config");
                const presentConfig = config.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];
                if (isRunnableConfigLike(presentConfig)) {
                    const newConfig = {
                        ...presentConfig
                    };
                    const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : void 0;
                    if (callbacks) {
                        Object.assign(callbacks, {
                            _parentRunId: child.id
                        });
                        callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);
                        newConfig.callbacks = callbacks;
                    }
                    child.extra[LC_CHILD] = newConfig;
                }
                const visited = new Set();
                let current = this;
                while(null != current && !visited.has(current.id)){
                    visited.add(current.id);
                    current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
                    current = current.parent_run;
                }
                this.child_runs.push(child);
                return child;
            }
            async end(outputs, error, endTime = Date.now(), metadata) {
                this.outputs = this.outputs ?? outputs;
                this.error = this.error ?? error;
                this.end_time = this.end_time ?? endTime;
                if (metadata && Object.keys(metadata).length > 0) this.extra = this.extra ? {
                    ...this.extra,
                    metadata: {
                        ...this.extra.metadata,
                        ...metadata
                    }
                } : {
                    metadata
                };
            }
            _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
                const runExtra = run.extra ?? {};
                if (!runExtra.runtime) runExtra.runtime = {};
                if (runtimeEnv) {
                    for (const [k, v] of Object.entries(runtimeEnv))if (!runExtra.runtime[k]) runExtra.runtime[k] = v;
                }
                let child_runs;
                let parent_run_id;
                if (excludeChildRuns) {
                    parent_run_id = run.parent_run?.id;
                    child_runs = [];
                } else {
                    child_runs = run.child_runs.map((child_run)=>this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
                    parent_run_id = void 0;
                }
                const persistedRun = {
                    id: run.id,
                    name: run.name,
                    start_time: run.start_time,
                    end_time: run.end_time,
                    run_type: run.run_type,
                    reference_example_id: run.reference_example_id,
                    extra: runExtra,
                    serialized: run.serialized,
                    error: run.error,
                    inputs: run.inputs,
                    outputs: run.outputs,
                    session_name: run.project_name,
                    child_runs: child_runs,
                    parent_run_id: parent_run_id,
                    trace_id: run.trace_id,
                    dotted_order: run.dotted_order,
                    tags: run.tags,
                    attachments: run.attachments
                };
                return persistedRun;
            }
            async postRun(excludeChildRuns = true) {
                try {
                    const runtimeEnv = getRuntimeEnvironment();
                    const runCreate = await this._convertToCreate(this, runtimeEnv, true);
                    await this.client.createRun(runCreate);
                    if (!excludeChildRuns) {
                        warnOnce("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
                        for (const childRun of this.child_runs)await childRun.postRun(false);
                    }
                } catch (error) {
                    console.error(`Error in postRun for run ${this.id}:`, error);
                }
            }
            async patchRun() {
                try {
                    const runUpdate = {
                        end_time: this.end_time,
                        error: this.error,
                        inputs: this.inputs,
                        outputs: this.outputs,
                        parent_run_id: this.parent_run?.id,
                        reference_example_id: this.reference_example_id,
                        extra: this.extra,
                        events: this.events,
                        dotted_order: this.dotted_order,
                        trace_id: this.trace_id,
                        tags: this.tags,
                        attachments: this.attachments
                    };
                    await this.client.updateRun(this.id, runUpdate);
                } catch (error) {
                    console.error(`Error in patchRun for run ${this.id}`, error);
                }
            }
            toJSON() {
                return this._convertToCreate(this, void 0, false);
            }
            addEvent(event) {
                if (!this.events) this.events = [];
                if ("string" == typeof event) this.events.push({
                    name: "event",
                    time: new Date().toISOString(),
                    message: event
                });
                else this.events.push({
                    ...event,
                    time: event.time ?? new Date().toISOString()
                });
            }
            static fromRunnableConfig(parentConfig, props) {
                const callbackManager = parentConfig?.callbacks;
                let parentRun;
                let projectName;
                let client;
                let tracingEnabled = isTracingEnabled();
                if (callbackManager) {
                    const parentRunId = callbackManager?.getParentRunId?.() ?? "";
                    const langChainTracer = callbackManager?.handlers?.find((handler)=>handler?.name == "langchain_tracer");
                    parentRun = langChainTracer?.getRun?.(parentRunId);
                    projectName = langChainTracer?.projectName;
                    client = langChainTracer?.client;
                    tracingEnabled = tracingEnabled || !!langChainTracer;
                }
                if (!parentRun) return new run_trees_RunTree({
                    ...props,
                    client,
                    tracingEnabled,
                    project_name: projectName
                });
                const parentRunTree = new run_trees_RunTree({
                    name: parentRun.name,
                    id: parentRun.id,
                    trace_id: parentRun.trace_id,
                    dotted_order: parentRun.dotted_order,
                    client,
                    tracingEnabled,
                    project_name: projectName,
                    tags: [
                        ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))
                    ],
                    extra: {
                        metadata: {
                            ...parentRun?.extra?.metadata,
                            ...parentConfig?.metadata
                        }
                    }
                });
                return parentRunTree.createChild(props);
            }
            static fromDottedOrder(dottedOrder) {
                return this.fromHeaders({
                    "langsmith-trace": dottedOrder
                });
            }
            static fromHeaders(headers, inheritArgs) {
                const rawHeaders = "get" in headers && "function" == typeof headers.get ? {
                    "langsmith-trace": headers.get("langsmith-trace"),
                    baggage: headers.get("baggage")
                } : headers;
                const headerTrace = rawHeaders["langsmith-trace"];
                if (!headerTrace || "string" != typeof headerTrace) return;
                const parentDottedOrder = headerTrace.trim();
                const parsedDottedOrder = parentDottedOrder.split(".").map((part)=>{
                    const [strTime, uuid] = part.split("Z");
                    return {
                        strTime,
                        time: Date.parse(strTime + "Z"),
                        uuid
                    };
                });
                const traceId = parsedDottedOrder[0].uuid;
                const config = {
                    ...inheritArgs,
                    name: inheritArgs?.["name"] ?? "parent",
                    run_type: inheritArgs?.["run_type"] ?? "chain",
                    start_time: inheritArgs?.["start_time"] ?? Date.now(),
                    id: parsedDottedOrder.at(-1)?.uuid,
                    trace_id: traceId,
                    dotted_order: parentDottedOrder
                };
                if (rawHeaders["baggage"] && "string" == typeof rawHeaders["baggage"]) {
                    const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
                    config.metadata = baggage.metadata;
                    config.tags = baggage.tags;
                }
                return new run_trees_RunTree(config);
            }
            toHeaders(headers) {
                const result = {
                    "langsmith-trace": this.dotted_order,
                    baggage: new Baggage(this.extra?.metadata, this.tags).toHeader()
                };
                if (headers) for (const [key, value] of Object.entries(result))headers.set(key, value);
                return result;
            }
        }
        Object.defineProperty(run_trees_RunTree, "sharedClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        function run_trees_isRunTree(x) {
            return void 0 !== x && "function" == typeof x.createChild && "function" == typeof x.postRun;
        }
        function isLangChainTracerLike(x) {
            return "object" == typeof x && null != x && "string" == typeof x.name && "langchain_tracer" === x.name;
        }
        function containsLangChainTracerLike(x) {
            return Array.isArray(x) && x.some((callback)=>isLangChainTracerLike(callback));
        }
        function isCallbackManagerLike(x) {
            return "object" == typeof x && null != x && Array.isArray(x.handlers);
        }
        function isRunnableConfigLike(x) {
            return void 0 !== x && "object" == typeof x.callbacks && (containsLangChainTracerLike(x.callbacks?.handlers) || containsLangChainTracerLike(x.callbacks));
        }
        class MockAsyncLocalStorage {
            getStore() {}
            run(_, callback) {
                return callback();
            }
        }
        const TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
        const mockAsyncLocalStorage = new MockAsyncLocalStorage();
        class AsyncLocalStorageProvider {
            getInstance() {
                return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;
            }
            initializeGlobalInstance(instance) {
                if (void 0 === globalThis[TRACING_ALS_KEY]) globalThis[TRACING_ALS_KEY] = instance;
            }
        }
        const AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
        const getCurrentRunTree = ()=>{
            const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();
            if (!run_trees_isRunTree(runTree)) throw new Error("Could not get the current run tree.\n\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.");
            return runTree;
        };
        Symbol.for("langsmith:traceable:root");
        function isTraceableFunction(x) {
            return "function" == typeof x && "langsmith:traceable" in x;
        }
        /*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */ const _hasOwnProperty = Object.prototype.hasOwnProperty;
        function helpers_hasOwnProperty(obj, key) {
            return _hasOwnProperty.call(obj, key);
        }
        function helpers_objectKeys(obj) {
            if (Array.isArray(obj)) {
                const keys = new Array(obj.length);
                for(let k = 0; k < keys.length; k++)keys[k] = "" + k;
                return keys;
            }
            if (Object.keys) return Object.keys(obj);
            let keys = [];
            for(let i in obj)if (helpers_hasOwnProperty(obj, i)) keys.push(i);
            return keys;
        }
        function helpers_deepClone(obj) {
            switch(typeof obj){
                case "object":
                    return JSON.parse(JSON.stringify(obj));
                case "undefined":
                    return null;
                default:
                    return obj;
            }
        }
        function isInteger(str) {
            let i = 0;
            const len = str.length;
            let charCode;
            while(i < len){
                charCode = str.charCodeAt(i);
                if (charCode >= 48 && charCode <= 57) {
                    i++;
                    continue;
                }
                return false;
            }
            return true;
        }
        function unescapePathComponent(path) {
            return path.replace(/~1/g, "/").replace(/~0/g, "~");
        }
        function hasUndefined(obj) {
            if (void 0 === obj) return true;
            if (obj) {
                if (Array.isArray(obj)) {
                    for(let i = 0, len = obj.length; i < len; i++)if (hasUndefined(obj[i])) return true;
                } else if ("object" == typeof obj) {
                    const objKeys = helpers_objectKeys(obj);
                    const objKeysLength = objKeys.length;
                    for(var i = 0; i < objKeysLength; i++)if (hasUndefined(obj[objKeys[i]])) return true;
                }
            }
            return false;
        }
        function patchErrorMessageFormatter(message, args) {
            const messageParts = [
                message
            ];
            for(const key in args){
                const value = "object" == typeof args[key] ? JSON.stringify(args[key], null, 2) : args[key];
                if (void 0 !== value) messageParts.push(`${key}: ${value}`);
            }
            return messageParts.join("\n");
        }
        class PatchError extends Error {
            constructor(message, name, index, operation, tree){
                super(patchErrorMessageFormatter(message, {
                    name,
                    index,
                    operation,
                    tree
                }));
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: name
                });
                Object.defineProperty(this, "index", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: index
                });
                Object.defineProperty(this, "operation", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: operation
                });
                Object.defineProperty(this, "tree", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: tree
                });
                Object.setPrototypeOf(this, new.target.prototype);
                this.message = patchErrorMessageFormatter(message, {
                    name,
                    index,
                    operation,
                    tree
                });
            }
        }
        const JsonPatchError = PatchError;
        const deepClone = helpers_deepClone;
        const objOps = {
            add: function(obj, key, document1) {
                obj[key] = this.value;
                return {
                    newDocument: document1
                };
            },
            remove: function(obj, key, document1) {
                var removed = obj[key];
                delete obj[key];
                return {
                    newDocument: document1,
                    removed
                };
            },
            replace: function(obj, key, document1) {
                var removed = obj[key];
                obj[key] = this.value;
                return {
                    newDocument: document1,
                    removed
                };
            },
            move: function(obj, key, document1) {
                let removed = getValueByPointer(document1, this.path);
                if (removed) removed = helpers_deepClone(removed);
                const originalValue = applyOperation(document1, {
                    op: "remove",
                    path: this.from
                }).removed;
                applyOperation(document1, {
                    op: "add",
                    path: this.path,
                    value: originalValue
                });
                return {
                    newDocument: document1,
                    removed
                };
            },
            copy: function(obj, key, document1) {
                const valueToCopy = getValueByPointer(document1, this.from);
                applyOperation(document1, {
                    op: "add",
                    path: this.path,
                    value: helpers_deepClone(valueToCopy)
                });
                return {
                    newDocument: document1
                };
            },
            test: function(obj, key, document1) {
                return {
                    newDocument: document1,
                    test: _areEquals(obj[key], this.value)
                };
            },
            _get: function(obj, key, document1) {
                this.value = obj[key];
                return {
                    newDocument: document1
                };
            }
        };
        var arrOps = {
            add: function(arr, i, document1) {
                if (isInteger(i)) arr.splice(i, 0, this.value);
                else arr[i] = this.value;
                return {
                    newDocument: document1,
                    index: i
                };
            },
            remove: function(arr, i, document1) {
                var removedList = arr.splice(i, 1);
                return {
                    newDocument: document1,
                    removed: removedList[0]
                };
            },
            replace: function(arr, i, document1) {
                var removed = arr[i];
                arr[i] = this.value;
                return {
                    newDocument: document1,
                    removed
                };
            },
            move: objOps.move,
            copy: objOps.copy,
            test: objOps.test,
            _get: objOps._get
        };
        function getValueByPointer(document1, pointer) {
            if ("" == pointer) return document1;
            var getOriginalDestination = {
                op: "_get",
                path: pointer
            };
            applyOperation(document1, getOriginalDestination);
            return getOriginalDestination.value;
        }
        function applyOperation(document1, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {
            if (validateOperation) {
                if ("function" == typeof validateOperation) validateOperation(operation, 0, document1, operation.path);
                else validator(operation, 0);
            }
            if ("" === operation.path) {
                let returnValue = {
                    newDocument: document1
                };
                if ("add" === operation.op) {
                    returnValue.newDocument = operation.value;
                    return returnValue;
                }
                if ("replace" === operation.op) {
                    returnValue.newDocument = operation.value;
                    returnValue.removed = document1;
                    return returnValue;
                }
                if ("move" === operation.op || "copy" === operation.op) {
                    returnValue.newDocument = getValueByPointer(document1, operation.from);
                    if ("move" === operation.op) returnValue.removed = document1;
                    return returnValue;
                } else if ("test" === operation.op) {
                    returnValue.test = _areEquals(document1, operation.value);
                    if (false === returnValue.test) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document1);
                    returnValue.newDocument = document1;
                    return returnValue;
                } else if ("remove" === operation.op) {
                    returnValue.removed = document1;
                    returnValue.newDocument = null;
                    return returnValue;
                } else if ("_get" === operation.op) {
                    operation.value = document1;
                    return returnValue;
                } else {
                    if (!validateOperation) return returnValue;
                    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document1);
                }
            }
            {
                if (!mutateDocument) document1 = helpers_deepClone(document1);
                const path = operation.path || "";
                const keys = path.split("/");
                let obj = document1;
                let t = 1;
                let len = keys.length;
                let existingPathFragment;
                let key;
                let validateFunction;
                validateFunction = "function" == typeof validateOperation ? validateOperation : validator;
                while(true){
                    key = keys[t];
                    if (key && -1 != key.indexOf("~")) key = unescapePathComponent(key);
                    if (banPrototypeModifications && ("__proto__" == key || "prototype" == key && t > 0 && "constructor" == keys[t - 1])) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
                    if (validateOperation) {
                        if (void 0 === existingPathFragment) {
                            if (void 0 === obj[key]) existingPathFragment = keys.slice(0, t).join("/");
                            else if (t == len - 1) existingPathFragment = operation.path;
                            if (void 0 !== existingPathFragment) validateFunction(operation, 0, document1, existingPathFragment);
                        }
                    }
                    t++;
                    if (Array.isArray(obj)) {
                        if ("-" === key) key = obj.length;
                        else {
                            if (validateOperation && !isInteger(key)) throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document1);
                            if (isInteger(key)) key = ~~key;
                        }
                        if (t >= len) {
                            if (validateOperation && "add" === operation.op && key > obj.length) throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document1);
                            const returnValue = arrOps[operation.op].call(operation, obj, key, document1);
                            if (false === returnValue.test) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document1);
                            return returnValue;
                        }
                    } else if (t >= len) {
                        const returnValue = objOps[operation.op].call(operation, obj, key, document1);
                        if (false === returnValue.test) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document1);
                        return returnValue;
                    }
                    obj = obj[key];
                    if (validateOperation && t < len && (!obj || "object" != typeof obj)) throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document1);
                }
            }
        }
        function core_applyPatch(document1, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
            if (validateOperation) {
                if (!Array.isArray(patch)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
            }
            if (!mutateDocument) document1 = helpers_deepClone(document1);
            const results = new Array(patch.length);
            for(let i = 0, length = patch.length; i < length; i++){
                results[i] = applyOperation(document1, patch[i], validateOperation, true, banPrototypeModifications, i);
                document1 = results[i].newDocument;
            }
            results.newDocument = document1;
            return results;
        }
        function applyReducer(document1, operation, index) {
            const operationResult = applyOperation(document1, operation);
            if (false === operationResult.test) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document1);
            return operationResult.newDocument;
        }
        function validator(operation, index, document1, existingPathFragment) {
            if ("object" != typeof operation || null === operation || Array.isArray(operation)) throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document1);
            if (objOps[operation.op]) {
                if ("string" != typeof operation.path) throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document1);
                if (0 !== operation.path.indexOf("/") && operation.path.length > 0) throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document1);
                else if (("move" === operation.op || "copy" === operation.op) && "string" != typeof operation.from) throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document1);
                else if (("add" === operation.op || "replace" === operation.op || "test" === operation.op) && void 0 === operation.value) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document1);
                else if (("add" === operation.op || "replace" === operation.op || "test" === operation.op) && hasUndefined(operation.value)) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document1);
                else if (document1) {
                    if ("add" == operation.op) {
                        var pathLen = operation.path.split("/").length;
                        var existingPathLen = existingPathFragment.split("/").length;
                        if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document1);
                    } else if ("replace" === operation.op || "remove" === operation.op || "_get" === operation.op) {
                        if (operation.path !== existingPathFragment) throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document1);
                    } else if ("move" === operation.op || "copy" === operation.op) {
                        var existingValue = {
                            op: "_get",
                            path: operation.from,
                            value: void 0
                        };
                        var error = core_validate([
                            existingValue
                        ], document1);
                        if (error && "OPERATION_PATH_UNRESOLVABLE" === error.name) throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document1);
                    }
                }
            } else throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document1);
        }
        function core_validate(sequence, document1, externalValidator) {
            try {
                if (!Array.isArray(sequence)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
                if (document1) core_applyPatch(helpers_deepClone(document1), helpers_deepClone(sequence), externalValidator || true);
                else {
                    externalValidator = externalValidator || validator;
                    for(var i = 0; i < sequence.length; i++)externalValidator(sequence[i], i, document1, void 0);
                }
            } catch (e) {
                if (e instanceof JsonPatchError) return e;
                throw e;
            }
        }
        function _areEquals(a, b) {
            if (a === b) return true;
            if (a && b && "object" == typeof a && "object" == typeof b) {
                var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
                if (arrA && arrB) {
                    length = a.length;
                    if (length != b.length) return false;
                    for(i = length; 0 !== i--;)if (!_areEquals(a[i], b[i])) return false;
                    return true;
                }
                if (arrA != arrB) return false;
                var keys = Object.keys(a);
                length = keys.length;
                if (length !== Object.keys(b).length) return false;
                for(i = length; 0 !== i--;)if (!b.hasOwnProperty(keys[i])) return false;
                for(i = length; 0 !== i--;){
                    key = keys[i];
                    if (!_areEquals(a[key], b[key])) return false;
                }
                return true;
            }
            return a !== a && b !== b;
        }
        /*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2013-2021 Joachim Wester
 * MIT license
 */ new WeakMap();
        ({
            ...core_namespaceObject
        });
        var serializable = __webpack_require__("../../../../node_modules/@langchain/core/dist/load/serializable.js");
        const env_isBrowser = ()=>"undefined" != typeof window && void 0 !== window.document;
        const env_isWebWorker = ()=>"object" == typeof globalThis && globalThis.constructor && "DedicatedWorkerGlobalScope" === globalThis.constructor.name;
        const env_isJsDom = ()=>"undefined" != typeof window && "nodejs" === window.name || "undefined" != typeof navigator && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
        const env_isDeno = ()=>"undefined" != typeof Deno;
        const env_isNode = ()=>"undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node && !env_isDeno();
        const env_getEnv = ()=>{
            let env;
            env = env_isBrowser() ? "browser" : env_isNode() ? "node" : env_isWebWorker() ? "webworker" : env_isJsDom() ? "jsdom" : env_isDeno() ? "deno" : "other";
            return env;
        };
        let env_runtimeEnvironment;
        async function env_getRuntimeEnvironment() {
            if (void 0 === env_runtimeEnvironment) {
                const env = env_getEnv();
                env_runtimeEnvironment = {
                    library: "langchain-js",
                    runtime: env
                };
            }
            return env_runtimeEnvironment;
        }
        function env_getEnvironmentVariable(name) {
            try {
                if ("undefined" != typeof process) return process.env?.[name];
                if (env_isDeno()) return Deno?.env.get(name);
                return;
            } catch (e) {
                return;
            }
        }
        class BaseCallbackHandlerMethodsClass {
        }
        class BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {
            get lc_namespace() {
                return [
                    "langchain_core",
                    "callbacks",
                    this.name
                ];
            }
            get lc_secrets() {}
            get lc_attributes() {}
            get lc_aliases() {}
            get lc_serializable_keys() {}
            static lc_name() {
                return this.name;
            }
            get lc_id() {
                return [
                    ...this.lc_namespace,
                    (0, serializable.j)(this.constructor)
                ];
            }
            constructor(input){
                super();
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "lc_kwargs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "ignoreLLM", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "ignoreChain", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "ignoreAgent", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "ignoreRetriever", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "ignoreCustomEvent", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "raiseError", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "awaitHandlers", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "false" === env_getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND")
                });
                this.lc_kwargs = input || {};
                if (input) {
                    this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;
                    this.ignoreChain = input.ignoreChain ?? this.ignoreChain;
                    this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;
                    this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;
                    this.ignoreCustomEvent = input.ignoreCustomEvent ?? this.ignoreCustomEvent;
                    this.raiseError = input.raiseError ?? this.raiseError;
                    this.awaitHandlers = this.raiseError || (input._awaitHandler ?? this.awaitHandlers);
                }
            }
            copy() {
                return new this.constructor(this);
            }
            toJSON() {
                return serializable.i.prototype.toJSON.call(this);
            }
            toJSONNotImplemented() {
                return serializable.i.prototype.toJSONNotImplemented.call(this);
            }
            static fromMethods(methods) {
                class Handler extends BaseCallbackHandler {
                    constructor(){
                        super();
                        Object.defineProperty(this, "name", {
                            enumerable: true,
                            configurable: true,
                            writable: true,
                            value: esm_node_v4()
                        });
                        Object.assign(this, methods);
                    }
                }
                return new Handler();
            }
        }
        const isBaseCallbackHandler = (x)=>{
            const callbackHandler = x;
            return void 0 !== callbackHandler && "function" == typeof callbackHandler.copy && "string" == typeof callbackHandler.name && "boolean" == typeof callbackHandler.awaitHandlers;
        };
        function _coerceToDict(value, defaultKey) {
            return value && !Array.isArray(value) && "object" == typeof value ? value : {
                [defaultKey]: value
            };
        }
        function base_stripNonAlphanumeric(input) {
            return input.replace(/[-:.]/g, "");
        }
        function base_convertToDottedOrderFormat(epoch, runId, executionOrder) {
            const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
            return base_stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
        }
        function isBaseTracer(x) {
            return "function" == typeof x._addRunToRunMap;
        }
        class BaseTracer extends BaseCallbackHandler {
            constructor(_fields){
                super(...arguments);
                Object.defineProperty(this, "runMap", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: new Map()
                });
            }
            copy() {
                return this;
            }
            stringifyError(error) {
                if (error instanceof Error) return error.message + (error?.stack ? `\n\n${error.stack}` : "");
                if ("string" == typeof error) return error;
                return `${error}`;
            }
            _addChildRun(parentRun, childRun) {
                parentRun.child_runs.push(childRun);
            }
            _addRunToRunMap(run) {
                const currentDottedOrder = base_convertToDottedOrderFormat(run.start_time, run.id, run.execution_order);
                const storedRun = {
                    ...run
                };
                if (void 0 !== storedRun.parent_run_id) {
                    const parentRun = this.runMap.get(storedRun.parent_run_id);
                    if (parentRun) {
                        this._addChildRun(parentRun, storedRun);
                        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
                        storedRun.trace_id = parentRun.trace_id;
                        if (void 0 !== parentRun.dotted_order) storedRun.dotted_order = [
                            parentRun.dotted_order,
                            currentDottedOrder
                        ].join(".");
                    }
                } else {
                    storedRun.trace_id = storedRun.id;
                    storedRun.dotted_order = currentDottedOrder;
                }
                this.runMap.set(storedRun.id, storedRun);
                return storedRun;
            }
            async _endTrace(run) {
                const parentRun = void 0 !== run.parent_run_id && this.runMap.get(run.parent_run_id);
                if (parentRun) parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
                else await this.persistRun(run);
                this.runMap.delete(run.id);
                await this.onRunUpdate?.(run);
            }
            _getExecutionOrder(parentRunId) {
                const parentRun = void 0 !== parentRunId && this.runMap.get(parentRunId);
                if (!parentRun) return 1;
                return parentRun.child_execution_order + 1;
            }
            _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
                const execution_order = this._getExecutionOrder(parentRunId);
                const start_time = Date.now();
                const finalExtraParams = metadata ? {
                    ...extraParams,
                    metadata
                } : extraParams;
                const run = {
                    id: runId,
                    name: name ?? llm.id[llm.id.length - 1],
                    parent_run_id: parentRunId,
                    start_time,
                    serialized: llm,
                    events: [
                        {
                            name: "start",
                            time: new Date(start_time).toISOString()
                        }
                    ],
                    inputs: {
                        prompts
                    },
                    execution_order,
                    child_runs: [],
                    child_execution_order: execution_order,
                    run_type: "llm",
                    extra: finalExtraParams ?? {},
                    tags: tags || []
                };
                return this._addRunToRunMap(run);
            }
            async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
                const run = this.runMap.get(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
                await this.onRunCreate?.(run);
                await this.onLLMStart?.(run);
                return run;
            }
            _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
                const execution_order = this._getExecutionOrder(parentRunId);
                const start_time = Date.now();
                const finalExtraParams = metadata ? {
                    ...extraParams,
                    metadata
                } : extraParams;
                const run = {
                    id: runId,
                    name: name ?? llm.id[llm.id.length - 1],
                    parent_run_id: parentRunId,
                    start_time,
                    serialized: llm,
                    events: [
                        {
                            name: "start",
                            time: new Date(start_time).toISOString()
                        }
                    ],
                    inputs: {
                        messages
                    },
                    execution_order,
                    child_runs: [],
                    child_execution_order: execution_order,
                    run_type: "llm",
                    extra: finalExtraParams ?? {},
                    tags: tags || []
                };
                return this._addRunToRunMap(run);
            }
            async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
                const run = this.runMap.get(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
                await this.onRunCreate?.(run);
                await this.onLLMStart?.(run);
                return run;
            }
            async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "llm") throw new Error("No LLM run to end.");
                run.end_time = Date.now();
                run.outputs = output;
                run.events.push({
                    name: "end",
                    time: new Date(run.end_time).toISOString()
                });
                run.extra = {
                    ...run.extra,
                    ...extraParams
                };
                await this.onLLMEnd?.(run);
                await this._endTrace(run);
                return run;
            }
            async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "llm") throw new Error("No LLM run to end.");
                run.end_time = Date.now();
                run.error = this.stringifyError(error);
                run.events.push({
                    name: "error",
                    time: new Date(run.end_time).toISOString()
                });
                run.extra = {
                    ...run.extra,
                    ...extraParams
                };
                await this.onLLMError?.(run);
                await this._endTrace(run);
                return run;
            }
            _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
                const execution_order = this._getExecutionOrder(parentRunId);
                const start_time = Date.now();
                const run = {
                    id: runId,
                    name: name ?? chain.id[chain.id.length - 1],
                    parent_run_id: parentRunId,
                    start_time,
                    serialized: chain,
                    events: [
                        {
                            name: "start",
                            time: new Date(start_time).toISOString()
                        }
                    ],
                    inputs,
                    execution_order,
                    child_execution_order: execution_order,
                    run_type: runType ?? "chain",
                    child_runs: [],
                    extra: metadata ? {
                        metadata
                    } : {},
                    tags: tags || []
                };
                return this._addRunToRunMap(run);
            }
            async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
                const run = this.runMap.get(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
                await this.onRunCreate?.(run);
                await this.onChainStart?.(run);
                return run;
            }
            async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
                const run = this.runMap.get(runId);
                if (!run) throw new Error("No chain run to end.");
                run.end_time = Date.now();
                run.outputs = _coerceToDict(outputs, "output");
                run.events.push({
                    name: "end",
                    time: new Date(run.end_time).toISOString()
                });
                if (kwargs?.inputs !== void 0) run.inputs = _coerceToDict(kwargs.inputs, "input");
                await this.onChainEnd?.(run);
                await this._endTrace(run);
                return run;
            }
            async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
                const run = this.runMap.get(runId);
                if (!run) throw new Error("No chain run to end.");
                run.end_time = Date.now();
                run.error = this.stringifyError(error);
                run.events.push({
                    name: "error",
                    time: new Date(run.end_time).toISOString()
                });
                if (kwargs?.inputs !== void 0) run.inputs = _coerceToDict(kwargs.inputs, "input");
                await this.onChainError?.(run);
                await this._endTrace(run);
                return run;
            }
            _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
                const execution_order = this._getExecutionOrder(parentRunId);
                const start_time = Date.now();
                const run = {
                    id: runId,
                    name: name ?? tool.id[tool.id.length - 1],
                    parent_run_id: parentRunId,
                    start_time,
                    serialized: tool,
                    events: [
                        {
                            name: "start",
                            time: new Date(start_time).toISOString()
                        }
                    ],
                    inputs: {
                        input
                    },
                    execution_order,
                    child_execution_order: execution_order,
                    run_type: "tool",
                    child_runs: [],
                    extra: metadata ? {
                        metadata
                    } : {},
                    tags: tags || []
                };
                return this._addRunToRunMap(run);
            }
            async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
                const run = this.runMap.get(runId) ?? this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);
                await this.onRunCreate?.(run);
                await this.onToolStart?.(run);
                return run;
            }
            async handleToolEnd(output, runId) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "tool") throw new Error("No tool run to end");
                run.end_time = Date.now();
                run.outputs = {
                    output
                };
                run.events.push({
                    name: "end",
                    time: new Date(run.end_time).toISOString()
                });
                await this.onToolEnd?.(run);
                await this._endTrace(run);
                return run;
            }
            async handleToolError(error, runId) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "tool") throw new Error("No tool run to end");
                run.end_time = Date.now();
                run.error = this.stringifyError(error);
                run.events.push({
                    name: "error",
                    time: new Date(run.end_time).toISOString()
                });
                await this.onToolError?.(run);
                await this._endTrace(run);
                return run;
            }
            async handleAgentAction(action, runId) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "chain") return;
                const agentRun = run;
                agentRun.actions = agentRun.actions || [];
                agentRun.actions.push(action);
                agentRun.events.push({
                    name: "agent_action",
                    time: new Date().toISOString(),
                    kwargs: {
                        action
                    }
                });
                await this.onAgentAction?.(run);
            }
            async handleAgentEnd(action, runId) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "chain") return;
                run.events.push({
                    name: "agent_end",
                    time: new Date().toISOString(),
                    kwargs: {
                        action
                    }
                });
                await this.onAgentEnd?.(run);
            }
            _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
                const execution_order = this._getExecutionOrder(parentRunId);
                const start_time = Date.now();
                const run = {
                    id: runId,
                    name: name ?? retriever.id[retriever.id.length - 1],
                    parent_run_id: parentRunId,
                    start_time,
                    serialized: retriever,
                    events: [
                        {
                            name: "start",
                            time: new Date(start_time).toISOString()
                        }
                    ],
                    inputs: {
                        query
                    },
                    execution_order,
                    child_execution_order: execution_order,
                    run_type: "retriever",
                    child_runs: [],
                    extra: metadata ? {
                        metadata
                    } : {},
                    tags: tags || []
                };
                return this._addRunToRunMap(run);
            }
            async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
                const run = this.runMap.get(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
                await this.onRunCreate?.(run);
                await this.onRetrieverStart?.(run);
                return run;
            }
            async handleRetrieverEnd(documents, runId) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "retriever") throw new Error("No retriever run to end");
                run.end_time = Date.now();
                run.outputs = {
                    documents
                };
                run.events.push({
                    name: "end",
                    time: new Date(run.end_time).toISOString()
                });
                await this.onRetrieverEnd?.(run);
                await this._endTrace(run);
                return run;
            }
            async handleRetrieverError(error, runId) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "retriever") throw new Error("No retriever run to end");
                run.end_time = Date.now();
                run.error = this.stringifyError(error);
                run.events.push({
                    name: "error",
                    time: new Date(run.end_time).toISOString()
                });
                await this.onRetrieverError?.(run);
                await this._endTrace(run);
                return run;
            }
            async handleText(text, runId) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "chain") return;
                run.events.push({
                    name: "text",
                    time: new Date().toISOString(),
                    kwargs: {
                        text
                    }
                });
                await this.onText?.(run);
            }
            async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
                const run = this.runMap.get(runId);
                if (!run || run?.run_type !== "llm") throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
                run.events.push({
                    name: "new_token",
                    time: new Date().toISOString(),
                    kwargs: {
                        token,
                        idx,
                        chunk: fields?.chunk
                    }
                });
                await this.onLLMNewToken?.(run, token, {
                    chunk: fields?.chunk
                });
                return run;
            }
        }
        var ansi_styles = __webpack_require__("../../../../node_modules/@langchain/core/node_modules/ansi-styles/index.js");
        function wrap(style, text) {
            return `${style.open}${text}${style.close}`;
        }
        function tryJsonStringify(obj, fallback) {
            try {
                return JSON.stringify(obj, null, 2);
            } catch (err) {
                return fallback;
            }
        }
        function formatKVMapItem(value) {
            if ("string" == typeof value) return value.trim();
            if (null == value) return value;
            return tryJsonStringify(value, value.toString());
        }
        function console_elapsed(run) {
            if (!run.end_time) return "";
            const elapsed = run.end_time - run.start_time;
            if (elapsed < 1000) return `${elapsed}ms`;
            return `${(elapsed / 1000).toFixed(2)}s`;
        }
        const { color: console_color } = ansi_styles;
        class ConsoleCallbackHandler extends BaseTracer {
            constructor(){
                super(...arguments);
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "console_callback_handler"
                });
            }
            persistRun(_run) {
                return Promise.resolve();
            }
            getParents(run) {
                const parents = [];
                let currentRun = run;
                while(currentRun.parent_run_id){
                    const parent = this.runMap.get(currentRun.parent_run_id);
                    if (parent) {
                        parents.push(parent);
                        currentRun = parent;
                    } else break;
                }
                return parents;
            }
            getBreadcrumbs(run) {
                const parents = this.getParents(run).reverse();
                const string = [
                    ...parents,
                    run
                ].map((parent, i, arr)=>{
                    const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
                    return i === arr.length - 1 ? wrap(ansi_styles.bold, name) : name;
                }).join(" > ");
                return wrap(console_color.grey, string);
            }
            onChainStart(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
            }
            onChainEnd(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.cyan, "[chain/end]")} [${crumbs}] [${console_elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
            }
            onChainError(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.red, "[chain/error]")} [${crumbs}] [${console_elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
            }
            onLLMStart(run) {
                const crumbs = this.getBreadcrumbs(run);
                const inputs = "prompts" in run.inputs ? {
                    prompts: run.inputs.prompts.map((p)=>p.trim())
                } : run.inputs;
                console.log(`${wrap(console_color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
            }
            onLLMEnd(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.cyan, "[llm/end]")} [${crumbs}] [${console_elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
            }
            onLLMError(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.red, "[llm/error]")} [${crumbs}] [${console_elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
            }
            onToolStart(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
            }
            onToolEnd(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.cyan, "[tool/end]")} [${crumbs}] [${console_elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem(run.outputs?.output)}"`);
            }
            onToolError(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.red, "[tool/error]")} [${crumbs}] [${console_elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
            }
            onRetrieverStart(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
            }
            onRetrieverEnd(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.cyan, "[retriever/end]")} [${crumbs}] [${console_elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
            }
            onRetrieverError(run) {
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.red, "[retriever/error]")} [${crumbs}] [${console_elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
            }
            onAgentAction(run) {
                const agentRun = run;
                const crumbs = this.getBreadcrumbs(run);
                console.log(`${wrap(console_color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
            }
        }
        var utils = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/utils.js");
        let tracer_client;
        const getDefaultLangChainClientSingleton = ()=>{
            if (void 0 === tracer_client) {
                const clientParams = "false" === env_getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") ? {
                    blockOnRootRunFinalization: true
                } : {};
                tracer_client = new Client(clientParams);
            }
            return tracer_client;
        };
        class tracer_langchain_LangChainTracer extends BaseTracer {
            constructor(fields = {}){
                super(fields);
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "langchain_tracer"
                });
                Object.defineProperty(this, "projectName", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "exampleId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "client", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                const { exampleId, projectName, client } = fields;
                this.projectName = projectName ?? env_getEnvironmentVariable("LANGCHAIN_PROJECT") ?? env_getEnvironmentVariable("LANGCHAIN_SESSION");
                this.exampleId = exampleId;
                this.client = client ?? getDefaultLangChainClientSingleton();
                const traceableTree = tracer_langchain_LangChainTracer.getTraceableRunTree();
                if (traceableTree) this.updateFromRunTree(traceableTree);
            }
            async _convertToCreate(run, example_id) {
                return {
                    ...run,
                    extra: {
                        ...run.extra,
                        runtime: await env_getRuntimeEnvironment()
                    },
                    child_runs: void 0,
                    session_name: this.projectName,
                    reference_example_id: run.parent_run_id ? void 0 : example_id
                };
            }
            async persistRun(_run) {}
            async onRunCreate(run) {
                const persistedRun = await this._convertToCreate(run, this.exampleId);
                await this.client.createRun(persistedRun);
            }
            async onRunUpdate(run) {
                const runUpdate = {
                    end_time: run.end_time,
                    error: run.error,
                    outputs: run.outputs,
                    events: run.events,
                    inputs: run.inputs,
                    trace_id: run.trace_id,
                    dotted_order: run.dotted_order,
                    parent_run_id: run.parent_run_id,
                    extra: run.extra
                };
                await this.client.updateRun(run.id, runUpdate);
            }
            getRun(id) {
                return this.runMap.get(id);
            }
            updateFromRunTree(runTree) {
                let rootRun = runTree;
                const visited = new Set();
                while(rootRun.parent_run){
                    if (visited.has(rootRun.id)) break;
                    visited.add(rootRun.id);
                    if (!rootRun.parent_run) break;
                    rootRun = rootRun.parent_run;
                }
                visited.clear();
                const queue = [
                    rootRun
                ];
                while(queue.length > 0){
                    const current = queue.shift();
                    if (!current || visited.has(current.id)) continue;
                    visited.add(current.id);
                    this.runMap.set(current.id, current);
                    if (current.child_runs) queue.push(...current.child_runs);
                }
                this.client = runTree.client ?? this.client;
                this.projectName = runTree.project_name ?? this.projectName;
                this.exampleId = runTree.reference_example_id ?? this.exampleId;
            }
            convertToRunTree(id) {
                const runTreeMap = {};
                const runTreeList = [];
                for (const [id, run] of this.runMap){
                    const runTree = new run_trees_RunTree({
                        ...run,
                        child_runs: [],
                        parent_run: void 0,
                        client: this.client,
                        project_name: this.projectName,
                        reference_example_id: this.exampleId,
                        tracingEnabled: true
                    });
                    runTreeMap[id] = runTree;
                    runTreeList.push([
                        id,
                        run.dotted_order
                    ]);
                }
                runTreeList.sort((a, b)=>{
                    if (!a[1] || !b[1]) return 0;
                    return a[1].localeCompare(b[1]);
                });
                for (const [id] of runTreeList){
                    const run = this.runMap.get(id);
                    const runTree = runTreeMap[id];
                    if (!!run && !!runTree) {
                        if (run.parent_run_id) {
                            const parentRunTree = runTreeMap[run.parent_run_id];
                            if (parentRunTree) {
                                parentRunTree.child_runs.push(runTree);
                                runTree.parent_run = parentRunTree;
                            }
                        }
                    }
                }
                return runTreeMap[id];
            }
            static getTraceableRunTree() {
                try {
                    return getCurrentRunTree();
                } catch  {
                    return;
                }
            }
        }
        const globals_TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
        const globals_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
        const setGlobalAsyncLocalStorageInstance = (instance)=>{
            globalThis[globals_TRACING_ALS_KEY] = instance;
        };
        const globals_getGlobalAsyncLocalStorageInstance = ()=>globalThis[globals_TRACING_ALS_KEY];
        let callbacks_queue;
        function createQueue() {
            const PQueue = "default" in dist ? dist["default"] : dist;
            return new PQueue({
                autoStart: true,
                concurrency: 1
            });
        }
        function getQueue() {
            if (void 0 === callbacks_queue) callbacks_queue = createQueue();
            return callbacks_queue;
        }
        async function consumeCallback(promiseFn, wait) {
            if (true === wait) {
                const asyncLocalStorageInstance = globals_getGlobalAsyncLocalStorageInstance();
                if (void 0 !== asyncLocalStorageInstance) await asyncLocalStorageInstance.run(void 0, async ()=>promiseFn());
                else await promiseFn();
            } else {
                callbacks_queue = getQueue();
                callbacks_queue.add(async ()=>{
                    const asyncLocalStorageInstance = globals_getGlobalAsyncLocalStorageInstance();
                    if (void 0 !== asyncLocalStorageInstance) await asyncLocalStorageInstance.run(void 0, async ()=>promiseFn());
                    else await promiseFn();
                });
            }
        }
        const callbacks_isTracingEnabled = (tracingEnabled)=>{
            if (void 0 !== tracingEnabled) return tracingEnabled;
            const envVars = [
                "LANGSMITH_TRACING_V2",
                "LANGCHAIN_TRACING_V2",
                "LANGSMITH_TRACING",
                "LANGCHAIN_TRACING"
            ];
            return !!envVars.find((envVar)=>"true" === env_getEnvironmentVariable(envVar));
        };
        function getContextVariable(name) {
            const asyncLocalStorageInstance = globals_getGlobalAsyncLocalStorageInstance();
            if (void 0 === asyncLocalStorageInstance) return;
            const runTree = asyncLocalStorageInstance.getStore();
            return runTree?.[globals_CONTEXT_VARIABLES_KEY]?.[name];
        }
        const LC_CONFIGURE_HOOKS_KEY = Symbol("lc:configure_hooks");
        const _getConfigureHooks = ()=>getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];
        class BaseCallbackManager {
            setHandler(handler) {
                return this.setHandlers([
                    handler
                ]);
            }
        }
        class BaseRunManager {
            constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId){
                Object.defineProperty(this, "runId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: runId
                });
                Object.defineProperty(this, "handlers", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: handlers
                });
                Object.defineProperty(this, "inheritableHandlers", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: inheritableHandlers
                });
                Object.defineProperty(this, "tags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: tags
                });
                Object.defineProperty(this, "inheritableTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: inheritableTags
                });
                Object.defineProperty(this, "metadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: metadata
                });
                Object.defineProperty(this, "inheritableMetadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: inheritableMetadata
                });
                Object.defineProperty(this, "_parentRunId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: _parentRunId
                });
            }
            get parentRunId() {
                return this._parentRunId;
            }
            async handleText(text) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        try {
                            await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        try {
                            await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
        }
        class CallbackManagerForRetrieverRun extends BaseRunManager {
            getChild(tag) {
                const manager = new CallbackManager(this.runId);
                manager.setHandlers(this.inheritableHandlers);
                manager.addTags(this.inheritableTags);
                manager.addMetadata(this.inheritableMetadata);
                if (tag) manager.addTags([
                    tag
                ], false);
                return manager;
            }
            async handleRetrieverEnd(documents) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreRetriever) try {
                            await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            async handleRetrieverError(err) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreRetriever) try {
                            await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);
                        } catch (error) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
        }
        class CallbackManagerForLLMRun extends BaseRunManager {
            async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreLLM) try {
                            await handler.handleLLMNewToken?.(token, idx ?? {
                                prompt: 0,
                                completion: 0
                            }, this.runId, this._parentRunId, this.tags, fields);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreLLM) try {
                            await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreLLM) try {
                            await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
        }
        class CallbackManagerForChainRun extends BaseRunManager {
            getChild(tag) {
                const manager = new CallbackManager(this.runId);
                manager.setHandlers(this.inheritableHandlers);
                manager.addTags(this.inheritableTags);
                manager.addMetadata(this.inheritableMetadata);
                if (tag) manager.addTags([
                    tag
                ], false);
                return manager;
            }
            async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreChain) try {
                            await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreChain) try {
                            await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            async handleAgentAction(action) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreAgent) try {
                            await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            async handleAgentEnd(action) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreAgent) try {
                            await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
        }
        class CallbackManagerForToolRun extends BaseRunManager {
            getChild(tag) {
                const manager = new CallbackManager(this.runId);
                manager.setHandlers(this.inheritableHandlers);
                manager.addTags(this.inheritableTags);
                manager.addMetadata(this.inheritableMetadata);
                if (tag) manager.addTags([
                    tag
                ], false);
                return manager;
            }
            async handleToolError(err) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreAgent) try {
                            await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            async handleToolEnd(output) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreAgent) try {
                            await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
        }
        class CallbackManager extends BaseCallbackManager {
            constructor(parentRunId, options){
                super();
                Object.defineProperty(this, "handlers", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "inheritableHandlers", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "tags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "inheritableTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "metadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: {}
                });
                Object.defineProperty(this, "inheritableMetadata", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: {}
                });
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "callback_manager"
                });
                Object.defineProperty(this, "_parentRunId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.handlers = options?.handlers ?? this.handlers;
                this.inheritableHandlers = options?.inheritableHandlers ?? this.inheritableHandlers;
                this.tags = options?.tags ?? this.tags;
                this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;
                this.metadata = options?.metadata ?? this.metadata;
                this.inheritableMetadata = options?.inheritableMetadata ?? this.inheritableMetadata;
                this._parentRunId = parentRunId;
            }
            getParentRunId() {
                return this._parentRunId;
            }
            async handleLLMStart(llm, prompts, runId, _parentRunId, extraParams, _tags, _metadata, runName) {
                return Promise.all(prompts.map(async (prompt, idx)=>{
                    const runId_ = 0 === idx && runId ? runId : esm_node_v4();
                    await Promise.all(this.handlers.map((handler)=>{
                        if (handler.ignoreLLM) return;
                        if (isBaseTracer(handler)) handler._createRunForLLMStart(llm, [
                            prompt
                        ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                        return consumeCallback(async ()=>{
                            try {
                                await handler.handleLLMStart?.(llm, [
                                    prompt
                                ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                            } catch (err) {
                                const logFunction = handler.raiseError ? console.error : console.warn;
                                logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
                                if (handler.raiseError) throw err;
                            }
                        }, handler.awaitHandlers);
                    }));
                    return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
                }));
            }
            async handleChatModelStart(llm, messages, runId, _parentRunId, extraParams, _tags, _metadata, runName) {
                return Promise.all(messages.map(async (messageGroup, idx)=>{
                    const runId_ = 0 === idx && runId ? runId : esm_node_v4();
                    await Promise.all(this.handlers.map((handler)=>{
                        if (handler.ignoreLLM) return;
                        if (isBaseTracer(handler)) handler._createRunForChatModelStart(llm, [
                            messageGroup
                        ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                        return consumeCallback(async ()=>{
                            try {
                                if (handler.handleChatModelStart) await handler.handleChatModelStart?.(llm, [
                                    messageGroup
                                ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                                else if (handler.handleLLMStart) {
                                    const messageString = (0, utils.zs)(messageGroup);
                                    await handler.handleLLMStart?.(llm, [
                                        messageString
                                    ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                                }
                            } catch (err) {
                                const logFunction = handler.raiseError ? console.error : console.warn;
                                logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
                                if (handler.raiseError) throw err;
                            }
                        }, handler.awaitHandlers);
                    }));
                    return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
                }));
            }
            async handleChainStart(chain, inputs, runId = esm_node_v4(), runType, _tags, _metadata, runName) {
                await Promise.all(this.handlers.map((handler)=>{
                    if (handler.ignoreChain) return;
                    if (isBaseTracer(handler)) handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
                    return consumeCallback(async ()=>{
                        try {
                            await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers);
                }));
                return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
            }
            async handleToolStart(tool, input, runId = esm_node_v4(), _parentRunId, _tags, _metadata, runName) {
                await Promise.all(this.handlers.map((handler)=>{
                    if (handler.ignoreAgent) return;
                    if (isBaseTracer(handler)) handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
                    return consumeCallback(async ()=>{
                        try {
                            await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers);
                }));
                return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
            }
            async handleRetrieverStart(retriever, query, runId = esm_node_v4(), _parentRunId, _tags, _metadata, runName) {
                await Promise.all(this.handlers.map((handler)=>{
                    if (handler.ignoreRetriever) return;
                    if (isBaseTracer(handler)) handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
                    return consumeCallback(async ()=>{
                        try {
                            await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers);
                }));
                return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
            }
            async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
                await Promise.all(this.handlers.map((handler)=>consumeCallback(async ()=>{
                        if (!handler.ignoreCustomEvent) try {
                            await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);
                        } catch (err) {
                            const logFunction = handler.raiseError ? console.error : console.warn;
                            logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
                            if (handler.raiseError) throw err;
                        }
                    }, handler.awaitHandlers)));
            }
            addHandler(handler, inherit = true) {
                this.handlers.push(handler);
                if (inherit) this.inheritableHandlers.push(handler);
            }
            removeHandler(handler) {
                this.handlers = this.handlers.filter((_handler)=>_handler !== handler);
                this.inheritableHandlers = this.inheritableHandlers.filter((_handler)=>_handler !== handler);
            }
            setHandlers(handlers, inherit = true) {
                this.handlers = [];
                this.inheritableHandlers = [];
                for (const handler of handlers)this.addHandler(handler, inherit);
            }
            addTags(tags, inherit = true) {
                this.removeTags(tags);
                this.tags.push(...tags);
                if (inherit) this.inheritableTags.push(...tags);
            }
            removeTags(tags) {
                this.tags = this.tags.filter((tag)=>!tags.includes(tag));
                this.inheritableTags = this.inheritableTags.filter((tag)=>!tags.includes(tag));
            }
            addMetadata(metadata, inherit = true) {
                this.metadata = {
                    ...this.metadata,
                    ...metadata
                };
                if (inherit) this.inheritableMetadata = {
                    ...this.inheritableMetadata,
                    ...metadata
                };
            }
            removeMetadata(metadata) {
                for (const key of Object.keys(metadata)){
                    delete this.metadata[key];
                    delete this.inheritableMetadata[key];
                }
            }
            copy(additionalHandlers = [], inherit = true) {
                const manager = new CallbackManager(this._parentRunId);
                for (const handler of this.handlers){
                    const inheritable = this.inheritableHandlers.includes(handler);
                    manager.addHandler(handler, inheritable);
                }
                for (const tag of this.tags){
                    const inheritable = this.inheritableTags.includes(tag);
                    manager.addTags([
                        tag
                    ], inheritable);
                }
                for (const key of Object.keys(this.metadata)){
                    const inheritable = Object.keys(this.inheritableMetadata).includes(key);
                    manager.addMetadata({
                        [key]: this.metadata[key]
                    }, inheritable);
                }
                for (const handler of additionalHandlers)if (!manager.handlers.filter((h)=>"console_callback_handler" === h.name).some((h)=>h.name === handler.name)) manager.addHandler(handler, inherit);
                return manager;
            }
            static fromHandlers(handlers) {
                class Handler extends BaseCallbackHandler {
                    constructor(){
                        super();
                        Object.defineProperty(this, "name", {
                            enumerable: true,
                            configurable: true,
                            writable: true,
                            value: esm_node_v4()
                        });
                        Object.assign(this, handlers);
                    }
                }
                const manager = new this();
                manager.addHandler(new Handler());
                return manager;
            }
            static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
                return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
            }
            static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
                let callbackManager;
                if (inheritableHandlers || localHandlers) {
                    if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
                        callbackManager = new CallbackManager();
                        callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);
                    } else callbackManager = inheritableHandlers;
                    callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers?.handlers, false);
                }
                const verboseEnabled = "true" === env_getEnvironmentVariable("LANGCHAIN_VERBOSE") || options?.verbose;
                const tracingV2Enabled = tracer_langchain_LangChainTracer.getTraceableRunTree()?.tracingEnabled || callbacks_isTracingEnabled();
                const tracingEnabled = tracingV2Enabled || (env_getEnvironmentVariable("LANGCHAIN_TRACING") ?? false);
                if (verboseEnabled || tracingEnabled) {
                    if (!callbackManager) callbackManager = new CallbackManager();
                    if (verboseEnabled && !callbackManager.handlers.some((handler)=>handler.name === ConsoleCallbackHandler.prototype.name)) {
                        const consoleHandler = new ConsoleCallbackHandler();
                        callbackManager.addHandler(consoleHandler, true);
                    }
                    if (tracingEnabled && !callbackManager.handlers.some((handler)=>"langchain_tracer" === handler.name)) {
                        if (tracingV2Enabled) {
                            const tracerV2 = new tracer_langchain_LangChainTracer();
                            callbackManager.addHandler(tracerV2, true);
                            callbackManager._parentRunId = tracer_langchain_LangChainTracer.getTraceableRunTree()?.id ?? callbackManager._parentRunId;
                        }
                    }
                }
                for (const { contextVar, inheritable = true, handlerClass, envVar } of _getConfigureHooks()){
                    const createIfNotInContext = envVar && "true" === env_getEnvironmentVariable(envVar) && handlerClass;
                    let handler;
                    const contextVarValue = void 0 !== contextVar ? getContextVariable(contextVar) : void 0;
                    if (contextVarValue && isBaseCallbackHandler(contextVarValue)) handler = contextVarValue;
                    else if (createIfNotInContext) handler = new handlerClass({});
                    if (void 0 !== handler) {
                        if (!callbackManager) callbackManager = new CallbackManager();
                        if (!callbackManager.handlers.some((h)=>h.name === handler.name)) callbackManager.addHandler(handler, inheritable);
                    }
                }
                if (inheritableTags || localTags) {
                    if (callbackManager) {
                        callbackManager.addTags(inheritableTags ?? []);
                        callbackManager.addTags(localTags ?? [], false);
                    }
                }
                if (inheritableMetadata || localMetadata) {
                    if (callbackManager) {
                        callbackManager.addMetadata(inheritableMetadata ?? {});
                        callbackManager.addMetadata(localMetadata ?? {}, false);
                    }
                }
                return callbackManager;
            }
        }
        function ensureHandler(handler) {
            if ("name" in handler) return handler;
            return BaseCallbackHandler.fromMethods(handler);
        }
        class async_local_storage_MockAsyncLocalStorage {
            getStore() {}
            run(_store, callback) {
                return callback();
            }
            enterWith(_store) {}
        }
        const async_local_storage_mockAsyncLocalStorage = new async_local_storage_MockAsyncLocalStorage();
        const LC_CHILD_KEY = Symbol.for("lc:child_config");
        class async_local_storage_AsyncLocalStorageProvider {
            getInstance() {
                return globals_getGlobalAsyncLocalStorageInstance() ?? async_local_storage_mockAsyncLocalStorage;
            }
            getRunnableConfig() {
                const storage = this.getInstance();
                return storage.getStore()?.extra?.[LC_CHILD_KEY];
            }
            runWithConfig(config, callback, avoidCreatingRootRunTree) {
                const callbackManager = CallbackManager._configureSync(config?.callbacks, void 0, config?.tags, void 0, config?.metadata);
                const storage = this.getInstance();
                const previousValue = storage.getStore();
                const parentRunId = callbackManager?.getParentRunId();
                const langChainTracer = callbackManager?.handlers?.find((handler)=>handler?.name === "langchain_tracer");
                let runTree;
                if (langChainTracer && parentRunId) runTree = langChainTracer.convertToRunTree(parentRunId);
                else if (!avoidCreatingRootRunTree) runTree = new run_trees_RunTree({
                    name: "<runnable_lambda>",
                    tracingEnabled: false
                });
                if (runTree) runTree.extra = {
                    ...runTree.extra,
                    [LC_CHILD_KEY]: config
                };
                if (void 0 !== previousValue && void 0 !== previousValue[globals_CONTEXT_VARIABLES_KEY]) {
                    if (void 0 === runTree) runTree = {};
                    runTree[globals_CONTEXT_VARIABLES_KEY] = previousValue[globals_CONTEXT_VARIABLES_KEY];
                }
                return storage.run(runTree, callback);
            }
            initializeGlobalInstance(instance) {
                if (void 0 === globals_getGlobalAsyncLocalStorageInstance()) setGlobalAsyncLocalStorageInstance(instance);
            }
        }
        const async_local_storage_AsyncLocalStorageProviderSingleton = new async_local_storage_AsyncLocalStorageProvider();
        const DEFAULT_RECURSION_LIMIT = 25;
        async function getCallbackManagerForConfig(config) {
            return CallbackManager._configureSync(config?.callbacks, void 0, config?.tags, void 0, config?.metadata);
        }
        function mergeConfigs(...configs) {
            const copy = {};
            for (const options of configs.filter((c)=>!!c))for (const key of Object.keys(options))if ("metadata" === key) copy[key] = {
                ...copy[key],
                ...options[key]
            };
            else if ("tags" === key) {
                const baseKeys = copy[key] ?? [];
                copy[key] = [
                    ...new Set(baseKeys.concat(options[key] ?? []))
                ];
            } else if ("configurable" === key) copy[key] = {
                ...copy[key],
                ...options[key]
            };
            else if ("timeout" === key) {
                if (void 0 === copy.timeout) copy.timeout = options.timeout;
                else if (void 0 !== options.timeout) copy.timeout = Math.min(copy.timeout, options.timeout);
            } else if ("signal" === key) {
                if (void 0 === copy.signal) copy.signal = options.signal;
                else if (void 0 !== options.signal) {
                    if ("any" in AbortSignal) copy.signal = AbortSignal.any([
                        copy.signal,
                        options.signal
                    ]);
                    else copy.signal = options.signal;
                }
            } else if ("callbacks" === key) {
                const baseCallbacks = copy.callbacks;
                const providedCallbacks = options.callbacks;
                if (Array.isArray(providedCallbacks)) {
                    if (baseCallbacks) {
                        if (Array.isArray(baseCallbacks)) copy.callbacks = baseCallbacks.concat(providedCallbacks);
                        else {
                            const manager = baseCallbacks.copy();
                            for (const callback of providedCallbacks)manager.addHandler(ensureHandler(callback), true);
                            copy.callbacks = manager;
                        }
                    } else copy.callbacks = providedCallbacks;
                } else if (providedCallbacks) {
                    if (baseCallbacks) {
                        if (Array.isArray(baseCallbacks)) {
                            const manager = providedCallbacks.copy();
                            for (const callback of baseCallbacks)manager.addHandler(ensureHandler(callback), true);
                            copy.callbacks = manager;
                        } else copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {
                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
                            metadata: {
                                ...baseCallbacks.metadata,
                                ...providedCallbacks.metadata
                            }
                        });
                    } else copy.callbacks = providedCallbacks;
                }
            } else {
                const typedKey = key;
                copy[typedKey] = options[typedKey] ?? copy[typedKey];
            }
            return copy;
        }
        const PRIMITIVES = new Set([
            "string",
            "number",
            "boolean"
        ]);
        function ensureConfig(config) {
            const implicitConfig = async_local_storage_AsyncLocalStorageProviderSingleton.getRunnableConfig();
            let empty = {
                tags: [],
                metadata: {},
                recursionLimit: 25,
                runId: void 0
            };
            if (implicitConfig) {
                const { runId, runName, ...rest } = implicitConfig;
                empty = Object.entries(rest).reduce((currentConfig, [key, value])=>{
                    if (void 0 !== value) currentConfig[key] = value;
                    return currentConfig;
                }, empty);
            }
            if (config) empty = Object.entries(config).reduce((currentConfig, [key, value])=>{
                if (void 0 !== value) currentConfig[key] = value;
                return currentConfig;
            }, empty);
            if (empty?.configurable) {
                for (const key of Object.keys(empty.configurable))if (PRIMITIVES.has(typeof empty.configurable[key]) && !empty.metadata?.[key]) {
                    if (!empty.metadata) empty.metadata = {};
                    empty.metadata[key] = empty.configurable[key];
                }
            }
            if (void 0 !== empty.timeout) {
                if (empty.timeout <= 0) throw new Error("Timeout must be a positive number");
                const timeoutSignal = AbortSignal.timeout(empty.timeout);
                if (void 0 !== empty.signal) {
                    if ("any" in AbortSignal) empty.signal = AbortSignal.any([
                        empty.signal,
                        timeoutSignal
                    ]);
                } else empty.signal = timeoutSignal;
                delete empty.timeout;
            }
            return empty;
        }
        function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId } = {}) {
            const newConfig = ensureConfig(config);
            if (void 0 !== callbacks) {
                delete newConfig.runName;
                newConfig.callbacks = callbacks;
            }
            if (void 0 !== recursionLimit) newConfig.recursionLimit = recursionLimit;
            if (void 0 !== maxConcurrency) newConfig.maxConcurrency = maxConcurrency;
            if (void 0 !== runName) newConfig.runName = runName;
            if (void 0 !== configurable) newConfig.configurable = {
                ...newConfig.configurable,
                ...configurable
            };
            if (void 0 !== runId) delete newConfig.runId;
            return newConfig;
        }
        function pickRunnableConfigKeys(config) {
            return config ? {
                configurable: config.configurable,
                recursionLimit: config.recursionLimit,
                callbacks: config.callbacks,
                tags: config.tags,
                metadata: config.metadata,
                maxConcurrency: config.maxConcurrency,
                timeout: config.timeout,
                signal: config.signal
            } : void 0;
        }
        async function raceWithSignal(promise, signal) {
            if (void 0 === signal) return promise;
            let listener;
            return Promise.race([
                promise.catch((err)=>{
                    if (signal?.aborted) return;
                    throw err;
                }),
                new Promise((_, reject)=>{
                    listener = ()=>{
                        reject(new Error("Aborted"));
                    };
                    signal.addEventListener("abort", listener);
                    if (signal.aborted) reject(new Error("Aborted"));
                })
            ]).finally(()=>signal.removeEventListener("abort", listener));
        }
        class IterableReadableStream extends ReadableStream {
            constructor(){
                super(...arguments);
                Object.defineProperty(this, "reader", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
            }
            ensureReader() {
                if (!this.reader) this.reader = this.getReader();
            }
            async next() {
                this.ensureReader();
                try {
                    const result = await this.reader.read();
                    if (!result.done) return {
                        done: false,
                        value: result.value
                    };
                    this.reader.releaseLock();
                    return {
                        done: true,
                        value: void 0
                    };
                } catch (e) {
                    this.reader.releaseLock();
                    throw e;
                }
            }
            async return() {
                this.ensureReader();
                if (this.locked) {
                    const cancelPromise = this.reader.cancel();
                    this.reader.releaseLock();
                    await cancelPromise;
                }
                return {
                    done: true,
                    value: void 0
                };
            }
            async throw(e) {
                this.ensureReader();
                if (this.locked) {
                    const cancelPromise = this.reader.cancel();
                    this.reader.releaseLock();
                    await cancelPromise;
                }
                throw e;
            }
            [Symbol.asyncIterator]() {
                return this;
            }
            async [Symbol.asyncDispose]() {
                await this.return();
            }
            static fromReadableStream(stream) {
                const reader = stream.getReader();
                return new IterableReadableStream({
                    start (controller) {
                        return pump();
                        function pump() {
                            return reader.read().then(({ done, value })=>{
                                if (done) {
                                    controller.close();
                                    return;
                                }
                                controller.enqueue(value);
                                return pump();
                            });
                        }
                    },
                    cancel () {
                        reader.releaseLock();
                    }
                });
            }
            static fromAsyncGenerator(generator) {
                return new IterableReadableStream({
                    async pull (controller) {
                        const { value, done } = await generator.next();
                        if (done) controller.close();
                        controller.enqueue(value);
                    },
                    async cancel (reason) {
                        await generator.return(reason);
                    }
                });
            }
        }
        function atee(iter, length = 2) {
            const buffers = Array.from({
                length
            }, ()=>[]);
            return buffers.map(async function*(buffer) {
                while(true)if (0 === buffer.length) {
                    const result = await iter.next();
                    for (const buffer of buffers)buffer.push(result);
                } else {
                    if (buffer[0].done) return;
                    yield buffer.shift().value;
                }
            });
        }
        function concat(first, second) {
            if (Array.isArray(first) && Array.isArray(second)) return first.concat(second);
            if ("string" == typeof first && "string" == typeof second) return first + second;
            if ("number" == typeof first && "number" == typeof second) return first + second;
            if ("concat" in first && "function" == typeof first.concat) return first.concat(second);
            if ("object" == typeof first && "object" == typeof second) {
                const chunk = {
                    ...first
                };
                for (const [key, value] of Object.entries(second))if (key in chunk && !Array.isArray(chunk[key])) chunk[key] = concat(chunk[key], value);
                else chunk[key] = value;
                return chunk;
            } else throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);
        }
        class AsyncGeneratorWithSetup {
            constructor(params){
                Object.defineProperty(this, "generator", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "setup", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "config", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "signal", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "firstResult", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "firstResultUsed", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                this.generator = params.generator;
                this.config = params.config;
                this.signal = params.signal ?? this.config?.signal;
                this.setup = new Promise((resolve, reject)=>{
                    async_local_storage_AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(params.config), async ()=>{
                        this.firstResult = params.generator.next();
                        if (params.startSetup) this.firstResult.then(params.startSetup).then(resolve, reject);
                        else this.firstResult.then((_result)=>resolve(void 0), reject);
                    }, true);
                });
            }
            async next(...args) {
                this.signal?.throwIfAborted();
                if (!this.firstResultUsed) {
                    this.firstResultUsed = true;
                    return this.firstResult;
                }
                return async_local_storage_AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(this.config), this.signal ? async ()=>raceWithSignal(this.generator.next(...args), this.signal) : async ()=>this.generator.next(...args), true);
            }
            async return(value) {
                return this.generator.return(value);
            }
            async throw(e) {
                return this.generator.throw(e);
            }
            [Symbol.asyncIterator]() {
                return this;
            }
            async [Symbol.asyncDispose]() {
                await this.return();
            }
        }
        async function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {
            const gen = new AsyncGeneratorWithSetup({
                generator,
                startSetup,
                signal
            });
            const setup = await gen.setup;
            return {
                output: to(gen, setup, ...args),
                setup
            };
        }
        var ai = __webpack_require__("../../../../node_modules/@langchain/core/dist/messages/ai.js");
        class RunLogPatch {
            constructor(fields){
                Object.defineProperty(this, "ops", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.ops = fields.ops ?? [];
            }
            concat(other) {
                const ops = this.ops.concat(other.ops);
                const states = core_applyPatch({}, ops);
                return new RunLog({
                    ops,
                    state: states[states.length - 1].newDocument
                });
            }
        }
        class RunLog extends RunLogPatch {
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "state", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.state = fields.state;
            }
            concat(other) {
                const ops = this.ops.concat(other.ops);
                const states = core_applyPatch(this.state, other.ops);
                return new RunLog({
                    ops,
                    state: states[states.length - 1].newDocument
                });
            }
            static fromRunLogPatch(patch) {
                const states = core_applyPatch({}, patch.ops);
                return new RunLog({
                    ops: patch.ops,
                    state: states[states.length - 1].newDocument
                });
            }
        }
        const isLogStreamHandler = (handler)=>"log_stream_tracer" === handler.name;
        async function _getStandardizedInputs(run, schemaFormat) {
            if ("original" === schemaFormat) throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
            const { inputs } = run;
            if ([
                "retriever",
                "llm",
                "prompt"
            ].includes(run.run_type)) return inputs;
            if (1 === Object.keys(inputs).length && inputs?.input === "") return;
            return inputs.input;
        }
        async function _getStandardizedOutputs(run, schemaFormat) {
            const { outputs } = run;
            if ("original" === schemaFormat) return outputs;
            if ([
                "retriever",
                "llm",
                "prompt"
            ].includes(run.run_type)) return outputs;
            if (void 0 !== outputs && 1 === Object.keys(outputs).length && outputs?.output !== void 0) return outputs.output;
            return outputs;
        }
        function isChatGenerationChunk(x) {
            return void 0 !== x && void 0 !== x.message;
        }
        class LogStreamCallbackHandler extends BaseTracer {
            constructor(fields){
                super({
                    _awaitHandler: true,
                    ...fields
                });
                Object.defineProperty(this, "autoClose", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "includeNames", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "includeTypes", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "includeTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeNames", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeTypes", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "_schemaFormat", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "original"
                });
                Object.defineProperty(this, "rootId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "keyMapByRunId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: {}
                });
                Object.defineProperty(this, "counterMapByRunName", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: {}
                });
                Object.defineProperty(this, "transformStream", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "writer", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "receiveStream", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "log_stream_tracer"
                });
                Object.defineProperty(this, "lc_prefer_streaming", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                this.autoClose = fields?.autoClose ?? true;
                this.includeNames = fields?.includeNames;
                this.includeTypes = fields?.includeTypes;
                this.includeTags = fields?.includeTags;
                this.excludeNames = fields?.excludeNames;
                this.excludeTypes = fields?.excludeTypes;
                this.excludeTags = fields?.excludeTags;
                this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;
                this.transformStream = new TransformStream();
                this.writer = this.transformStream.writable.getWriter();
                this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
            }
            [Symbol.asyncIterator]() {
                return this.receiveStream;
            }
            async persistRun(_run) {}
            _includeRun(run) {
                if (run.id === this.rootId) return false;
                const runTags = run.tags ?? [];
                let include = void 0 === this.includeNames && void 0 === this.includeTags && void 0 === this.includeTypes;
                if (void 0 !== this.includeNames) include = include || this.includeNames.includes(run.name);
                if (void 0 !== this.includeTypes) include = include || this.includeTypes.includes(run.run_type);
                if (void 0 !== this.includeTags) include = include || void 0 !== runTags.find((tag)=>this.includeTags?.includes(tag));
                if (void 0 !== this.excludeNames) include = include && !this.excludeNames.includes(run.name);
                if (void 0 !== this.excludeTypes) include = include && !this.excludeTypes.includes(run.run_type);
                if (void 0 !== this.excludeTags) include = include && runTags.every((tag)=>!this.excludeTags?.includes(tag));
                return include;
            }
            async *tapOutputIterable(runId, output) {
                for await (const chunk of output){
                    if (runId !== this.rootId) {
                        const key = this.keyMapByRunId[runId];
                        if (key) await this.writer.write(new RunLogPatch({
                            ops: [
                                {
                                    op: "add",
                                    path: `/logs/${key}/streamed_output/-`,
                                    value: chunk
                                }
                            ]
                        }));
                    }
                    yield chunk;
                }
            }
            async onRunCreate(run) {
                if (void 0 === this.rootId) {
                    this.rootId = run.id;
                    await this.writer.write(new RunLogPatch({
                        ops: [
                            {
                                op: "replace",
                                path: "",
                                value: {
                                    id: run.id,
                                    name: run.name,
                                    type: run.run_type,
                                    streamed_output: [],
                                    final_output: void 0,
                                    logs: {}
                                }
                            }
                        ]
                    }));
                }
                if (!this._includeRun(run)) return;
                if (void 0 === this.counterMapByRunName[run.name]) this.counterMapByRunName[run.name] = 0;
                this.counterMapByRunName[run.name] += 1;
                const count = this.counterMapByRunName[run.name];
                this.keyMapByRunId[run.id] = 1 === count ? run.name : `${run.name}:${count}`;
                const logEntry = {
                    id: run.id,
                    name: run.name,
                    type: run.run_type,
                    tags: run.tags ?? [],
                    metadata: run.extra?.metadata ?? {},
                    start_time: new Date(run.start_time).toISOString(),
                    streamed_output: [],
                    streamed_output_str: [],
                    final_output: void 0,
                    end_time: void 0
                };
                if ("streaming_events" === this._schemaFormat) logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);
                await this.writer.write(new RunLogPatch({
                    ops: [
                        {
                            op: "add",
                            path: `/logs/${this.keyMapByRunId[run.id]}`,
                            value: logEntry
                        }
                    ]
                }));
            }
            async onRunUpdate(run) {
                try {
                    const runName = this.keyMapByRunId[run.id];
                    if (void 0 === runName) return;
                    const ops = [];
                    if ("streaming_events" === this._schemaFormat) ops.push({
                        op: "replace",
                        path: `/logs/${runName}/inputs`,
                        value: await _getStandardizedInputs(run, this._schemaFormat)
                    });
                    ops.push({
                        op: "add",
                        path: `/logs/${runName}/final_output`,
                        value: await _getStandardizedOutputs(run, this._schemaFormat)
                    });
                    if (void 0 !== run.end_time) ops.push({
                        op: "add",
                        path: `/logs/${runName}/end_time`,
                        value: new Date(run.end_time).toISOString()
                    });
                    const patch = new RunLogPatch({
                        ops
                    });
                    await this.writer.write(patch);
                } finally{
                    if (run.id === this.rootId) {
                        const patch = new RunLogPatch({
                            ops: [
                                {
                                    op: "replace",
                                    path: "/final_output",
                                    value: await _getStandardizedOutputs(run, this._schemaFormat)
                                }
                            ]
                        });
                        await this.writer.write(patch);
                        if (this.autoClose) await this.writer.close();
                    }
                }
            }
            async onLLMNewToken(run, token, kwargs) {
                const runName = this.keyMapByRunId[run.id];
                if (void 0 === runName) return;
                const isChatModel = void 0 !== run.inputs.messages;
                let streamedOutputValue;
                streamedOutputValue = isChatModel ? isChatGenerationChunk(kwargs?.chunk) ? kwargs?.chunk : new ai.GC({
                    id: `run-${run.id}`,
                    content: token
                }) : token;
                const patch = new RunLogPatch({
                    ops: [
                        {
                            op: "add",
                            path: `/logs/${runName}/streamed_output_str/-`,
                            value: token
                        },
                        {
                            op: "add",
                            path: `/logs/${runName}/streamed_output/-`,
                            value: streamedOutputValue
                        }
                    ]
                });
                await this.writer.write(patch);
            }
        }
        class GenerationChunk {
            constructor(fields){
                Object.defineProperty(this, "text", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "generationInfo", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.text = fields.text;
                this.generationInfo = fields.generationInfo;
            }
            concat(chunk) {
                return new GenerationChunk({
                    text: this.text + chunk.text,
                    generationInfo: {
                        ...this.generationInfo,
                        ...chunk.generationInfo
                    }
                });
            }
        }
        function assignName({ name, serialized }) {
            if (void 0 !== name) return name;
            if (serialized?.name !== void 0) return serialized.name;
            if (serialized?.id !== void 0 && Array.isArray(serialized?.id)) return serialized.id[serialized.id.length - 1];
            return "Unnamed";
        }
        const isStreamEventsHandler = (handler)=>"event_stream_tracer" === handler.name;
        class EventStreamCallbackHandler extends BaseTracer {
            constructor(fields){
                super({
                    _awaitHandler: true,
                    ...fields
                });
                Object.defineProperty(this, "autoClose", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "includeNames", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "includeTypes", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "includeTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeNames", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeTypes", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "runInfoMap", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: new Map()
                });
                Object.defineProperty(this, "tappedPromises", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: new Map()
                });
                Object.defineProperty(this, "transformStream", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "writer", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "receiveStream", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "event_stream_tracer"
                });
                Object.defineProperty(this, "lc_prefer_streaming", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                this.autoClose = fields?.autoClose ?? true;
                this.includeNames = fields?.includeNames;
                this.includeTypes = fields?.includeTypes;
                this.includeTags = fields?.includeTags;
                this.excludeNames = fields?.excludeNames;
                this.excludeTypes = fields?.excludeTypes;
                this.excludeTags = fields?.excludeTags;
                this.transformStream = new TransformStream();
                this.writer = this.transformStream.writable.getWriter();
                this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
            }
            [Symbol.asyncIterator]() {
                return this.receiveStream;
            }
            async persistRun(_run) {}
            _includeRun(run) {
                const runTags = run.tags ?? [];
                let include = void 0 === this.includeNames && void 0 === this.includeTags && void 0 === this.includeTypes;
                if (void 0 !== this.includeNames) include = include || this.includeNames.includes(run.name);
                if (void 0 !== this.includeTypes) include = include || this.includeTypes.includes(run.runType);
                if (void 0 !== this.includeTags) include = include || void 0 !== runTags.find((tag)=>this.includeTags?.includes(tag));
                if (void 0 !== this.excludeNames) include = include && !this.excludeNames.includes(run.name);
                if (void 0 !== this.excludeTypes) include = include && !this.excludeTypes.includes(run.runType);
                if (void 0 !== this.excludeTags) include = include && runTags.every((tag)=>!this.excludeTags?.includes(tag));
                return include;
            }
            async *tapOutputIterable(runId, outputStream) {
                const firstChunk = await outputStream.next();
                if (firstChunk.done) return;
                const runInfo = this.runInfoMap.get(runId);
                if (void 0 === runInfo) {
                    yield firstChunk.value;
                    return;
                }
                function _formatOutputChunk(eventType, data) {
                    if ("llm" === eventType && "string" == typeof data) return new GenerationChunk({
                        text: data
                    });
                    return data;
                }
                let tappedPromise = this.tappedPromises.get(runId);
                if (void 0 === tappedPromise) {
                    let tappedPromiseResolver;
                    tappedPromise = new Promise((resolve)=>{
                        tappedPromiseResolver = resolve;
                    });
                    this.tappedPromises.set(runId, tappedPromise);
                    try {
                        const event = {
                            event: `on_${runInfo.runType}_stream`,
                            run_id: runId,
                            name: runInfo.name,
                            tags: runInfo.tags,
                            metadata: runInfo.metadata,
                            data: {}
                        };
                        await this.send({
                            ...event,
                            data: {
                                chunk: _formatOutputChunk(runInfo.runType, firstChunk.value)
                            }
                        }, runInfo);
                        yield firstChunk.value;
                        for await (const chunk of outputStream){
                            if ("tool" !== runInfo.runType && "retriever" !== runInfo.runType) await this.send({
                                ...event,
                                data: {
                                    chunk: _formatOutputChunk(runInfo.runType, chunk)
                                }
                            }, runInfo);
                            yield chunk;
                        }
                    } finally{
                        tappedPromiseResolver();
                    }
                } else {
                    yield firstChunk.value;
                    for await (const chunk of outputStream)yield chunk;
                }
            }
            async send(payload, run) {
                if (this._includeRun(run)) await this.writer.write(payload);
            }
            async sendEndEvent(payload, run) {
                const tappedPromise = this.tappedPromises.get(payload.run_id);
                if (void 0 !== tappedPromise) tappedPromise.then(()=>{
                    this.send(payload, run);
                });
                else await this.send(payload, run);
            }
            async onLLMStart(run) {
                const runName = assignName(run);
                const runType = void 0 !== run.inputs.messages ? "chat_model" : "llm";
                const runInfo = {
                    tags: run.tags ?? [],
                    metadata: run.extra?.metadata ?? {},
                    name: runName,
                    runType,
                    inputs: run.inputs
                };
                this.runInfoMap.set(run.id, runInfo);
                const eventName = `on_${runType}_start`;
                await this.send({
                    event: eventName,
                    data: {
                        input: run.inputs
                    },
                    name: runName,
                    tags: run.tags ?? [],
                    run_id: run.id,
                    metadata: run.extra?.metadata ?? {}
                }, runInfo);
            }
            async onLLMNewToken(run, token, kwargs) {
                const runInfo = this.runInfoMap.get(run.id);
                let chunk;
                let eventName;
                if (void 0 === runInfo) throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);
                if (1 === this.runInfoMap.size) return;
                if ("chat_model" === runInfo.runType) {
                    eventName = "on_chat_model_stream";
                    chunk = kwargs?.chunk === void 0 ? new ai.GC({
                        content: token,
                        id: `run-${run.id}`
                    }) : kwargs.chunk.message;
                } else if ("llm" === runInfo.runType) {
                    eventName = "on_llm_stream";
                    chunk = kwargs?.chunk === void 0 ? new GenerationChunk({
                        text: token
                    }) : kwargs.chunk;
                } else throw new Error(`Unexpected run type ${runInfo.runType}`);
                await this.send({
                    event: eventName,
                    data: {
                        chunk
                    },
                    run_id: run.id,
                    name: runInfo.name,
                    tags: runInfo.tags,
                    metadata: runInfo.metadata
                }, runInfo);
            }
            async onLLMEnd(run) {
                const runInfo = this.runInfoMap.get(run.id);
                this.runInfoMap.delete(run.id);
                let eventName;
                if (void 0 === runInfo) throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);
                const generations = run.outputs?.generations;
                let output;
                if ("chat_model" === runInfo.runType) {
                    for (const generation of generations ?? []){
                        if (void 0 !== output) break;
                        output = generation[0]?.message;
                    }
                    eventName = "on_chat_model_end";
                } else if ("llm" === runInfo.runType) {
                    output = {
                        generations: generations?.map((generation)=>generation.map((chunk)=>({
                                    text: chunk.text,
                                    generationInfo: chunk.generationInfo
                                }))),
                        llmOutput: run.outputs?.llmOutput ?? {}
                    };
                    eventName = "on_llm_end";
                } else throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);
                await this.sendEndEvent({
                    event: eventName,
                    data: {
                        output,
                        input: runInfo.inputs
                    },
                    run_id: run.id,
                    name: runInfo.name,
                    tags: runInfo.tags,
                    metadata: runInfo.metadata
                }, runInfo);
            }
            async onChainStart(run) {
                const runName = assignName(run);
                const runType = run.run_type ?? "chain";
                const runInfo = {
                    tags: run.tags ?? [],
                    metadata: run.extra?.metadata ?? {},
                    name: runName,
                    runType: run.run_type
                };
                let eventData = {};
                if ("" === run.inputs.input && 1 === Object.keys(run.inputs).length) {
                    eventData = {};
                    runInfo.inputs = {};
                } else if (void 0 !== run.inputs.input) {
                    eventData.input = run.inputs.input;
                    runInfo.inputs = run.inputs.input;
                } else {
                    eventData.input = run.inputs;
                    runInfo.inputs = run.inputs;
                }
                this.runInfoMap.set(run.id, runInfo);
                await this.send({
                    event: `on_${runType}_start`,
                    data: eventData,
                    name: runName,
                    tags: run.tags ?? [],
                    run_id: run.id,
                    metadata: run.extra?.metadata ?? {}
                }, runInfo);
            }
            async onChainEnd(run) {
                const runInfo = this.runInfoMap.get(run.id);
                this.runInfoMap.delete(run.id);
                if (void 0 === runInfo) throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);
                const eventName = `on_${run.run_type}_end`;
                const inputs = run.inputs ?? runInfo.inputs ?? {};
                const outputs = run.outputs?.output ?? run.outputs;
                const data = {
                    output: outputs,
                    input: inputs
                };
                if (inputs.input && 1 === Object.keys(inputs).length) {
                    data.input = inputs.input;
                    runInfo.inputs = inputs.input;
                }
                await this.sendEndEvent({
                    event: eventName,
                    data,
                    run_id: run.id,
                    name: runInfo.name,
                    tags: runInfo.tags,
                    metadata: runInfo.metadata ?? {}
                }, runInfo);
            }
            async onToolStart(run) {
                const runName = assignName(run);
                const runInfo = {
                    tags: run.tags ?? [],
                    metadata: run.extra?.metadata ?? {},
                    name: runName,
                    runType: "tool",
                    inputs: run.inputs ?? {}
                };
                this.runInfoMap.set(run.id, runInfo);
                await this.send({
                    event: "on_tool_start",
                    data: {
                        input: run.inputs ?? {}
                    },
                    name: runName,
                    run_id: run.id,
                    tags: run.tags ?? [],
                    metadata: run.extra?.metadata ?? {}
                }, runInfo);
            }
            async onToolEnd(run) {
                const runInfo = this.runInfoMap.get(run.id);
                this.runInfoMap.delete(run.id);
                if (void 0 === runInfo) throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
                if (void 0 === runInfo.inputs) throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
                const output = run.outputs?.output === void 0 ? run.outputs : run.outputs.output;
                await this.sendEndEvent({
                    event: "on_tool_end",
                    data: {
                        output,
                        input: runInfo.inputs
                    },
                    run_id: run.id,
                    name: runInfo.name,
                    tags: runInfo.tags,
                    metadata: runInfo.metadata
                }, runInfo);
            }
            async onRetrieverStart(run) {
                const runName = assignName(run);
                const runType = "retriever";
                const runInfo = {
                    tags: run.tags ?? [],
                    metadata: run.extra?.metadata ?? {},
                    name: runName,
                    runType,
                    inputs: {
                        query: run.inputs.query
                    }
                };
                this.runInfoMap.set(run.id, runInfo);
                await this.send({
                    event: "on_retriever_start",
                    data: {
                        input: {
                            query: run.inputs.query
                        }
                    },
                    name: runName,
                    tags: run.tags ?? [],
                    run_id: run.id,
                    metadata: run.extra?.metadata ?? {}
                }, runInfo);
            }
            async onRetrieverEnd(run) {
                const runInfo = this.runInfoMap.get(run.id);
                this.runInfoMap.delete(run.id);
                if (void 0 === runInfo) throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);
                await this.sendEndEvent({
                    event: "on_retriever_end",
                    data: {
                        output: run.outputs?.documents ?? run.outputs,
                        input: runInfo.inputs
                    },
                    run_id: run.id,
                    name: runInfo.name,
                    tags: runInfo.tags,
                    metadata: runInfo.metadata
                }, runInfo);
            }
            async handleCustomEvent(eventName, data, runId) {
                const runInfo = this.runInfoMap.get(runId);
                if (void 0 === runInfo) throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);
                await this.send({
                    event: "on_custom_event",
                    run_id: runId,
                    name: eventName,
                    tags: runInfo.tags,
                    metadata: runInfo.metadata,
                    data
                }, runInfo);
            }
            async finish() {
                const pendingPromises = [
                    ...this.tappedPromises.values()
                ];
                Promise.all(pendingPromises).finally(()=>{
                    this.writer.close();
                });
            }
        }
        const async_caller_STATUS_NO_RETRY = [
            400,
            401,
            402,
            403,
            404,
            405,
            406,
            407,
            409
        ];
        const defaultFailedAttemptHandler = (error)=>{
            if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || "AbortError" === error.name) throw error;
            if (error?.code === "ECONNABORTED") throw error;
            const status = error?.response?.status ?? error?.status;
            if (status && async_caller_STATUS_NO_RETRY.includes(+status)) throw error;
            if (error?.error?.code === "insufficient_quota") {
                const err = new Error(error?.message);
                err.name = "InsufficientQuotaError";
                throw err;
            }
        };
        class async_caller_AsyncCaller {
            constructor(params){
                Object.defineProperty(this, "maxConcurrency", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "maxRetries", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "onFailedAttempt", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "queue", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.maxConcurrency = params.maxConcurrency ?? 1 / 0;
                this.maxRetries = params.maxRetries ?? 6;
                this.onFailedAttempt = params.onFailedAttempt ?? defaultFailedAttemptHandler;
                const PQueue = "default" in dist ? dist["default"] : dist;
                this.queue = new PQueue({
                    concurrency: this.maxConcurrency
                });
            }
            call(callable, ...args) {
                return this.queue.add(()=>p_retry(()=>callable(...args).catch((error)=>{
                            if (error instanceof Error) throw error;
                            throw new Error(error);
                        }), {
                        onFailedAttempt: this.onFailedAttempt,
                        retries: this.maxRetries,
                        randomize: true
                    }), {
                    throwOnTimeout: true
                });
            }
            callWithOptions(options, callable, ...args) {
                if (options.signal) return Promise.race([
                    this.call(callable, ...args),
                    new Promise((_, reject)=>{
                        options.signal?.addEventListener("abort", ()=>{
                            reject(new Error("AbortError"));
                        });
                    })
                ]);
                return this.call(callable, ...args);
            }
            fetch(...args) {
                return this.call(()=>fetch(...args).then((res)=>res.ok ? res : Promise.reject(res)));
            }
        }
        class RootListenersTracer extends BaseTracer {
            constructor({ config, onStart, onEnd, onError }){
                super({
                    _awaitHandler: true
                });
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: "RootListenersTracer"
                });
                Object.defineProperty(this, "rootId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "config", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "argOnStart", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "argOnEnd", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "argOnError", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.config = config;
                this.argOnStart = onStart;
                this.argOnEnd = onEnd;
                this.argOnError = onError;
            }
            persistRun(_) {
                return Promise.resolve();
            }
            async onRunCreate(run) {
                if (this.rootId) return;
                this.rootId = run.id;
                if (this.argOnStart) await this.argOnStart(run, this.config);
            }
            async onRunUpdate(run) {
                if (run.id !== this.rootId) return;
                if (run.error) {
                    if (this.argOnError) await this.argOnError(run, this.config);
                } else if (this.argOnEnd) await this.argOnEnd(run, this.config);
            }
        }
        function isRunnableInterface(thing) {
            return thing ? thing.lc_runnable : false;
        }
        class _RootEventFilter {
            constructor(fields){
                Object.defineProperty(this, "includeNames", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "includeTypes", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "includeTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeNames", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeTypes", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "excludeTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.includeNames = fields.includeNames;
                this.includeTypes = fields.includeTypes;
                this.includeTags = fields.includeTags;
                this.excludeNames = fields.excludeNames;
                this.excludeTypes = fields.excludeTypes;
                this.excludeTags = fields.excludeTags;
            }
            includeEvent(event, rootType) {
                let include = void 0 === this.includeNames && void 0 === this.includeTypes && void 0 === this.includeTags;
                const eventTags = event.tags ?? [];
                if (void 0 !== this.includeNames) include = include || this.includeNames.includes(event.name);
                if (void 0 !== this.includeTypes) include = include || this.includeTypes.includes(rootType);
                if (void 0 !== this.includeTags) include = include || eventTags.some((tag)=>this.includeTags?.includes(tag));
                if (void 0 !== this.excludeNames) include = include && !this.excludeNames.includes(event.name);
                if (void 0 !== this.excludeTypes) include = include && !this.excludeTypes.includes(rootType);
                if (void 0 !== this.excludeTags) include = include && eventTags.every((tag)=>!this.excludeTags?.includes(tag));
                return include;
            }
        }
        const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
        const Options_defaultOptions = {
            name: void 0,
            $refStrategy: "root",
            basePath: [
                "#"
            ],
            effectStrategy: "input",
            pipeStrategy: "all",
            dateStrategy: "format:date-time",
            mapStrategy: "entries",
            removeAdditionalStrategy: "passthrough",
            definitionPath: "definitions",
            target: "jsonSchema7",
            strictUnions: false,
            definitions: {},
            errorMessages: false,
            markdownDescription: false,
            patternStrategy: "escape",
            applyRegexFlags: false,
            emailStrategy: "format:email",
            base64Strategy: "contentEncoding:base64",
            nameStrategy: "ref"
        };
        const getDefaultOptions = (options)=>"string" == typeof options ? {
                ...Options_defaultOptions,
                name: options
            } : {
                ...Options_defaultOptions,
                ...options
            };
        const getRefs = (options)=>{
            const _options = getDefaultOptions(options);
            const currentPath = void 0 !== _options.name ? [
                ..._options.basePath,
                _options.definitionPath,
                _options.name
            ] : _options.basePath;
            return {
                ..._options,
                currentPath: currentPath,
                propertyPath: void 0,
                seen: new Map(Object.entries(_options.definitions).map(([name, def])=>[
                        def._def,
                        {
                            def: def._def,
                            path: [
                                ..._options.basePath,
                                _options.definitionPath,
                                name
                            ],
                            jsonSchema: void 0
                        }
                    ]))
            };
        };
        function addErrorMessage(res, key, errorMessage, refs) {
            if (!refs?.errorMessages) return;
            if (errorMessage) res.errorMessage = {
                ...res.errorMessage,
                [key]: errorMessage
            };
        }
        function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
            res[key] = value;
            addErrorMessage(res, key, errorMessage, refs);
        }
        function parseAnyDef() {
            return {};
        }
        function parseArrayDef(def, refs) {
            const res = {
                type: "array"
            };
            if (def.type?._def && def.type?._def?.typeName !== lib.pA.ZodAny) res.items = parseDef(def.type._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "items"
                ]
            });
            if (def.minLength) setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
            if (def.maxLength) setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
            if (def.exactLength) {
                setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
                setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
            }
            return res;
        }
        function parseBigintDef(def, refs) {
            const res = {
                type: "integer",
                format: "int64"
            };
            if (!def.checks) return res;
            for (const check of def.checks)switch(check.kind){
                case "min":
                    if ("jsonSchema7" === refs.target) check.inclusive ? setResponseValueAndErrors(res, "minimum", check.value, check.message, refs) : setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    else {
                        if (!check.inclusive) res.exclusiveMinimum = true;
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    break;
                case "max":
                    if ("jsonSchema7" === refs.target) check.inclusive ? setResponseValueAndErrors(res, "maximum", check.value, check.message, refs) : setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    else {
                        if (!check.inclusive) res.exclusiveMaximum = true;
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    break;
                case "multipleOf":
                    setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                    break;
            }
            return res;
        }
        function parseBooleanDef() {
            return {
                type: "boolean"
            };
        }
        function parseBrandedDef(_def, refs) {
            return parseDef(_def.type._def, refs);
        }
        const parseCatchDef = (def, refs)=>parseDef(def.innerType._def, refs);
        function parseDateDef(def, refs, overrideDateStrategy) {
            const strategy = overrideDateStrategy ?? refs.dateStrategy;
            if (Array.isArray(strategy)) return {
                anyOf: strategy.map((item, i)=>parseDateDef(def, refs, item))
            };
            switch(strategy){
                case "string":
                case "format:date-time":
                    return {
                        type: "string",
                        format: "date-time"
                    };
                case "format:date":
                    return {
                        type: "string",
                        format: "date"
                    };
                case "integer":
                    return integerDateParser(def, refs);
            }
        }
        const integerDateParser = (def, refs)=>{
            const res = {
                type: "integer",
                format: "unix-time"
            };
            if ("openApi3" === refs.target) return res;
            for (const check of def.checks)switch(check.kind){
                case "min":
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    break;
                case "max":
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    break;
            }
            return res;
        };
        function parseDefaultDef(_def, refs) {
            return {
                ...parseDef(_def.innerType._def, refs),
                default: _def.defaultValue()
            };
        }
        function parseEffectsDef(_def, refs) {
            return "input" === refs.effectStrategy ? parseDef(_def.schema._def, refs) : {};
        }
        function parseEnumDef(def) {
            return {
                type: "string",
                enum: Array.from(def.values)
            };
        }
        const isJsonSchema7AllOfType = (type)=>{
            if ("type" in type && "string" === type.type) return false;
            return "allOf" in type;
        };
        function parseIntersectionDef(def, refs) {
            const allOf = [
                parseDef(def.left._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "allOf",
                        "0"
                    ]
                }),
                parseDef(def.right._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "allOf",
                        "1"
                    ]
                })
            ].filter((x)=>!!x);
            let unevaluatedProperties = "jsonSchema2019-09" === refs.target ? {
                unevaluatedProperties: false
            } : void 0;
            const mergedAllOf = [];
            allOf.forEach((schema)=>{
                if (isJsonSchema7AllOfType(schema)) {
                    mergedAllOf.push(...schema.allOf);
                    if (void 0 === schema.unevaluatedProperties) unevaluatedProperties = void 0;
                } else {
                    let nestedSchema = schema;
                    if ("additionalProperties" in schema && false === schema.additionalProperties) {
                        const { additionalProperties, ...rest } = schema;
                        nestedSchema = rest;
                    } else unevaluatedProperties = void 0;
                    mergedAllOf.push(nestedSchema);
                }
            });
            return mergedAllOf.length ? {
                allOf: mergedAllOf,
                ...unevaluatedProperties
            } : void 0;
        }
        function parseLiteralDef(def, refs) {
            const parsedType = typeof def.value;
            if ("bigint" !== parsedType && "number" !== parsedType && "boolean" !== parsedType && "string" !== parsedType) return {
                type: Array.isArray(def.value) ? "array" : "object"
            };
            if ("openApi3" === refs.target) return {
                type: "bigint" === parsedType ? "integer" : parsedType,
                enum: [
                    def.value
                ]
            };
            return {
                type: "bigint" === parsedType ? "integer" : parsedType,
                const: def.value
            };
        }
        let emojiRegex;
        const zodPatterns = {
            cuid: /^[cC][^\s-]{8,}$/,
            cuid2: /^[0-9a-z]+$/,
            ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
            email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
            emoji: ()=>{
                if (void 0 === emojiRegex) emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
                return emojiRegex;
            },
            uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
            ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
            ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
            ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
            ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
            base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
            base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
            nanoid: /^[a-zA-Z0-9_-]{21}$/,
            jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
        };
        function parseStringDef(def, refs) {
            const res = {
                type: "string"
            };
            if (def.checks) for (const check of def.checks)switch(check.kind){
                case "min":
                    setResponseValueAndErrors(res, "minLength", "number" == typeof res.minLength ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
                    break;
                case "max":
                    setResponseValueAndErrors(res, "maxLength", "number" == typeof res.maxLength ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
                    break;
                case "email":
                    switch(refs.emailStrategy){
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    setResponseValueAndErrors(res, "minLength", "number" == typeof res.minLength ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
                    setResponseValueAndErrors(res, "maxLength", "number" == typeof res.maxLength ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
                    break;
                case "includes":
                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                    break;
                case "ip":
                    if ("v6" !== check.version) addFormat(res, "ipv4", check.message, refs);
                    if ("v4" !== check.version) addFormat(res, "ipv6", check.message, refs);
                    break;
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr":
                    if ("v6" !== check.version) addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                    if ("v4" !== check.version) addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                    break;
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid":
                    addPattern(res, zodPatterns.ulid, check.message, refs);
                    break;
                case "base64":
                    switch(refs.base64Strategy){
                        case "format:binary":
                            addFormat(res, "binary", check.message, refs);
                            break;
                        case "contentEncoding:base64":
                            setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.base64, check.message, refs);
                            break;
                    }
                    break;
                case "nanoid":
                    addPattern(res, zodPatterns.nanoid, check.message, refs);
                case "toLowerCase":
                case "toUpperCase":
                case "trim":
                    break;
                default:
                    ((_)=>{})(0);
            }
            return res;
        }
        function escapeLiteralCheckValue(literal, refs) {
            return "escape" === refs.patternStrategy ? escapeNonAlphaNumeric(literal) : literal;
        }
        const ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
        function escapeNonAlphaNumeric(source) {
            let result = "";
            for(let i = 0; i < source.length; i++){
                if (!ALPHA_NUMERIC.has(source[i])) result += "\\";
                result += source[i];
            }
            return result;
        }
        function addFormat(schema, value, message, refs) {
            if (schema.format || schema.anyOf?.some((x)=>x.format)) {
                if (!schema.anyOf) schema.anyOf = [];
                if (schema.format) {
                    schema.anyOf.push({
                        format: schema.format,
                        ...schema.errorMessage && refs.errorMessages && {
                            errorMessage: {
                                format: schema.errorMessage.format
                            }
                        }
                    });
                    delete schema.format;
                    if (schema.errorMessage) {
                        delete schema.errorMessage.format;
                        if (0 === Object.keys(schema.errorMessage).length) delete schema.errorMessage;
                    }
                }
                schema.anyOf.push({
                    format: value,
                    ...message && refs.errorMessages && {
                        errorMessage: {
                            format: message
                        }
                    }
                });
            } else setResponseValueAndErrors(schema, "format", value, message, refs);
        }
        function addPattern(schema, regex, message, refs) {
            if (schema.pattern || schema.allOf?.some((x)=>x.pattern)) {
                if (!schema.allOf) schema.allOf = [];
                if (schema.pattern) {
                    schema.allOf.push({
                        pattern: schema.pattern,
                        ...schema.errorMessage && refs.errorMessages && {
                            errorMessage: {
                                pattern: schema.errorMessage.pattern
                            }
                        }
                    });
                    delete schema.pattern;
                    if (schema.errorMessage) {
                        delete schema.errorMessage.pattern;
                        if (0 === Object.keys(schema.errorMessage).length) delete schema.errorMessage;
                    }
                }
                schema.allOf.push({
                    pattern: stringifyRegExpWithFlags(regex, refs),
                    ...message && refs.errorMessages && {
                        errorMessage: {
                            pattern: message
                        }
                    }
                });
            } else setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
        }
        function stringifyRegExpWithFlags(regex, refs) {
            if (!refs.applyRegexFlags || !regex.flags) return regex.source;
            const flags = {
                i: regex.flags.includes("i"),
                m: regex.flags.includes("m"),
                s: regex.flags.includes("s")
            };
            const source = flags.i ? regex.source.toLowerCase() : regex.source;
            let pattern = "";
            let isEscaped = false;
            let inCharGroup = false;
            let inCharRange = false;
            for(let i = 0; i < source.length; i++){
                if (isEscaped) {
                    pattern += source[i];
                    isEscaped = false;
                    continue;
                }
                if (flags.i) {
                    if (inCharGroup) {
                        if (source[i].match(/[a-z]/)) {
                            if (inCharRange) {
                                pattern += source[i];
                                pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                                inCharRange = false;
                            } else if ("-" === source[i + 1] && source[i + 2]?.match(/[a-z]/)) {
                                pattern += source[i];
                                inCharRange = true;
                            } else pattern += `${source[i]}${source[i].toUpperCase()}`;
                            continue;
                        }
                    } else if (source[i].match(/[a-z]/)) {
                        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                        continue;
                    }
                }
                if (flags.m) {
                    if ("^" === source[i]) {
                        pattern += `(^|(?<=[\r\n]))`;
                        continue;
                    }
                    if ("$" === source[i]) {
                        pattern += `($|(?=[\r\n]))`;
                        continue;
                    }
                }
                if (flags.s && "." === source[i]) {
                    pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
                    continue;
                }
                pattern += source[i];
                if ("\\" === source[i]) isEscaped = true;
                else if (inCharGroup && "]" === source[i]) inCharGroup = false;
                else if (!inCharGroup && "[" === source[i]) inCharGroup = true;
            }
            try {
                new RegExp(pattern);
            } catch  {
                console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
                return regex.source;
            }
            return pattern;
        }
        function parseRecordDef(def, refs) {
            if ("openAi" === refs.target) console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
            if ("openApi3" === refs.target && def.keyType?._def.typeName === lib.pA.ZodEnum) return {
                type: "object",
                required: def.keyType._def.values,
                properties: def.keyType._def.values.reduce((acc, key)=>({
                        ...acc,
                        [key]: parseDef(def.valueType._def, {
                            ...refs,
                            currentPath: [
                                ...refs.currentPath,
                                "properties",
                                key
                            ]
                        }) ?? {}
                    }), {}),
                additionalProperties: false
            };
            const schema = {
                type: "object",
                additionalProperties: parseDef(def.valueType._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "additionalProperties"
                    ]
                }) ?? {}
            };
            if ("openApi3" === refs.target) return schema;
            if (def.keyType?._def.typeName === lib.pA.ZodString && def.keyType._def.checks?.length) {
                const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
                return {
                    ...schema,
                    propertyNames: keyType
                };
            }
            if (def.keyType?._def.typeName === lib.pA.ZodEnum) return {
                ...schema,
                propertyNames: {
                    enum: def.keyType._def.values
                }
            };
            if (def.keyType?._def.typeName === lib.pA.ZodBranded && def.keyType._def.type._def.typeName === lib.pA.ZodString && def.keyType._def.type._def.checks?.length) {
                const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
                return {
                    ...schema,
                    propertyNames: keyType
                };
            }
            return schema;
        }
        function parseMapDef(def, refs) {
            if ("record" === refs.mapStrategy) return parseRecordDef(def, refs);
            const keys = parseDef(def.keyType._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "items",
                    "items",
                    "0"
                ]
            }) || {};
            const values = parseDef(def.valueType._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "items",
                    "items",
                    "1"
                ]
            }) || {};
            return {
                type: "array",
                maxItems: 125,
                items: {
                    type: "array",
                    items: [
                        keys,
                        values
                    ],
                    minItems: 2,
                    maxItems: 2
                }
            };
        }
        function parseNativeEnumDef(def) {
            const object = def.values;
            const actualKeys = Object.keys(def.values).filter((key)=>"number" != typeof object[object[key]]);
            const actualValues = actualKeys.map((key)=>object[key]);
            const parsedTypes = Array.from(new Set(actualValues.map((values)=>typeof values)));
            return {
                type: 1 === parsedTypes.length ? "string" === parsedTypes[0] ? "string" : "number" : [
                    "string",
                    "number"
                ],
                enum: actualValues
            };
        }
        function parseNeverDef() {
            return {
                not: {}
            };
        }
        function parseNullDef(refs) {
            return "openApi3" === refs.target ? {
                enum: [
                    "null"
                ],
                nullable: true
            } : {
                type: "null"
            };
        }
        const primitiveMappings = {
            ZodString: "string",
            ZodNumber: "number",
            ZodBigInt: "integer",
            ZodBoolean: "boolean",
            ZodNull: "null"
        };
        function parseUnionDef(def, refs) {
            if ("openApi3" === refs.target) return asAnyOf(def, refs);
            const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
            if (options.every((x)=>x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
                const types = options.reduce((types, x)=>{
                    const type = primitiveMappings[x._def.typeName];
                    return type && !types.includes(type) ? [
                        ...types,
                        type
                    ] : types;
                }, []);
                return {
                    type: types.length > 1 ? types : types[0]
                };
            }
            if (options.every((x)=>"ZodLiteral" === x._def.typeName && !x.description)) {
                const types = options.reduce((acc, x)=>{
                    const type = typeof x._def.value;
                    switch(type){
                        case "string":
                        case "number":
                        case "boolean":
                            return [
                                ...acc,
                                type
                            ];
                        case "bigint":
                            return [
                                ...acc,
                                "integer"
                            ];
                        case "object":
                            if (null === x._def.value) return [
                                ...acc,
                                "null"
                            ];
                        case "symbol":
                        case "undefined":
                        case "function":
                        default:
                            return acc;
                    }
                }, []);
                if (types.length === options.length) {
                    const uniqueTypes = types.filter((x, i, a)=>a.indexOf(x) === i);
                    return {
                        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                        enum: options.reduce((acc, x)=>acc.includes(x._def.value) ? acc : [
                                ...acc,
                                x._def.value
                            ], [])
                    };
                }
            } else if (options.every((x)=>"ZodEnum" === x._def.typeName)) return {
                type: "string",
                enum: options.reduce((acc, x)=>[
                        ...acc,
                        ...x._def.values.filter((x)=>!acc.includes(x))
                    ], [])
            };
            return asAnyOf(def, refs);
        }
        const asAnyOf = (def, refs)=>{
            const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i)=>parseDef(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "anyOf",
                        `${i}`
                    ]
                })).filter((x)=>!!x && (!refs.strictUnions || "object" == typeof x && Object.keys(x).length > 0));
            return anyOf.length ? {
                anyOf
            } : void 0;
        };
        function parseNullableDef(def, refs) {
            if ([
                "ZodString",
                "ZodNumber",
                "ZodBigInt",
                "ZodBoolean",
                "ZodNull"
            ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
                if ("openApi3" === refs.target) return {
                    type: primitiveMappings[def.innerType._def.typeName],
                    nullable: true
                };
                return {
                    type: [
                        primitiveMappings[def.innerType._def.typeName],
                        "null"
                    ]
                };
            }
            if ("openApi3" === refs.target) {
                const base = parseDef(def.innerType._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath
                    ]
                });
                if (base && "$ref" in base) return {
                    allOf: [
                        base
                    ],
                    nullable: true
                };
                return base && {
                    ...base,
                    nullable: true
                };
            }
            const base = parseDef(def.innerType._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "anyOf",
                    "0"
                ]
            });
            return base && {
                anyOf: [
                    base,
                    {
                        type: "null"
                    }
                ]
            };
        }
        function parseNumberDef(def, refs) {
            const res = {
                type: "number"
            };
            if (!def.checks) return res;
            for (const check of def.checks)switch(check.kind){
                case "int":
                    res.type = "integer";
                    addErrorMessage(res, "type", check.message, refs);
                    break;
                case "min":
                    if ("jsonSchema7" === refs.target) check.inclusive ? setResponseValueAndErrors(res, "minimum", check.value, check.message, refs) : setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    else {
                        if (!check.inclusive) res.exclusiveMinimum = true;
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    break;
                case "max":
                    if ("jsonSchema7" === refs.target) check.inclusive ? setResponseValueAndErrors(res, "maximum", check.value, check.message, refs) : setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    else {
                        if (!check.inclusive) res.exclusiveMaximum = true;
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    break;
                case "multipleOf":
                    setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                    break;
            }
            return res;
        }
        function decideAdditionalProperties(def, refs) {
            if ("strict" === refs.removeAdditionalStrategy) return "ZodNever" === def.catchall._def.typeName ? "strict" !== def.unknownKeys : parseDef(def.catchall._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "additionalProperties"
                ]
            }) ?? true;
            return "ZodNever" === def.catchall._def.typeName ? "passthrough" === def.unknownKeys : parseDef(def.catchall._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "additionalProperties"
                ]
            }) ?? true;
        }
        function parseObjectDef(def, refs) {
            const forceOptionalIntoNullable = "openAi" === refs.target;
            const result = {
                type: "object",
                ...Object.entries(def.shape()).reduce((acc, [propName, propDef])=>{
                    if (void 0 === propDef || void 0 === propDef._def) return acc;
                    let propOptional = propDef.isOptional();
                    if (propOptional && forceOptionalIntoNullable) {
                        if (propDef instanceof lib.ak) propDef = propDef._def.innerType;
                        if (!propDef.isNullable()) propDef = propDef.nullable();
                        propOptional = false;
                    }
                    const parsedDef = parseDef(propDef._def, {
                        ...refs,
                        currentPath: [
                            ...refs.currentPath,
                            "properties",
                            propName
                        ],
                        propertyPath: [
                            ...refs.currentPath,
                            "properties",
                            propName
                        ]
                    });
                    if (void 0 === parsedDef) return acc;
                    return {
                        properties: {
                            ...acc.properties,
                            [propName]: parsedDef
                        },
                        required: propOptional ? acc.required : [
                            ...acc.required,
                            propName
                        ]
                    };
                }, {
                    properties: {},
                    required: []
                }),
                additionalProperties: decideAdditionalProperties(def, refs)
            };
            if (!result.required.length) delete result.required;
            return result;
        }
        const parseOptionalDef = (def, refs)=>{
            if (refs.currentPath.toString() === refs.propertyPath?.toString()) return parseDef(def.innerType._def, refs);
            const innerSchema = parseDef(def.innerType._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "anyOf",
                    "1"
                ]
            });
            return innerSchema ? {
                anyOf: [
                    {
                        not: {}
                    },
                    innerSchema
                ]
            } : {};
        };
        const parsePipelineDef = (def, refs)=>{
            if ("input" === refs.pipeStrategy) return parseDef(def.in._def, refs);
            if ("output" === refs.pipeStrategy) return parseDef(def.out._def, refs);
            const a = parseDef(def.in._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "allOf",
                    "0"
                ]
            });
            const b = parseDef(def.out._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "allOf",
                    a ? "1" : "0"
                ]
            });
            return {
                allOf: [
                    a,
                    b
                ].filter((x)=>void 0 !== x)
            };
        };
        function parsePromiseDef(def, refs) {
            return parseDef(def.type._def, refs);
        }
        function parseSetDef(def, refs) {
            const items = parseDef(def.valueType._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "items"
                ]
            });
            const schema = {
                type: "array",
                uniqueItems: true,
                items
            };
            if (def.minSize) setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
            if (def.maxSize) setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
            return schema;
        }
        function parseTupleDef(def, refs) {
            if (def.rest) return {
                type: "array",
                minItems: def.items.length,
                items: def.items.map((x, i)=>parseDef(x._def, {
                        ...refs,
                        currentPath: [
                            ...refs.currentPath,
                            "items",
                            `${i}`
                        ]
                    })).reduce((acc, x)=>void 0 === x ? acc : [
                        ...acc,
                        x
                    ], []),
                additionalItems: parseDef(def.rest._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "additionalItems"
                    ]
                })
            };
            return {
                type: "array",
                minItems: def.items.length,
                maxItems: def.items.length,
                items: def.items.map((x, i)=>parseDef(x._def, {
                        ...refs,
                        currentPath: [
                            ...refs.currentPath,
                            "items",
                            `${i}`
                        ]
                    })).reduce((acc, x)=>void 0 === x ? acc : [
                        ...acc,
                        x
                    ], [])
            };
        }
        function parseUndefinedDef() {
            return {
                not: {}
            };
        }
        function parseUnknownDef() {
            return {};
        }
        const parseReadonlyDef = (def, refs)=>parseDef(def.innerType._def, refs);
        const selectParser = (def, typeName, refs)=>{
            switch(typeName){
                case lib.pA.ZodString:
                    return parseStringDef(def, refs);
                case lib.pA.ZodNumber:
                    return parseNumberDef(def, refs);
                case lib.pA.ZodObject:
                    return parseObjectDef(def, refs);
                case lib.pA.ZodBigInt:
                    return parseBigintDef(def, refs);
                case lib.pA.ZodBoolean:
                    return parseBooleanDef();
                case lib.pA.ZodDate:
                    return parseDateDef(def, refs);
                case lib.pA.ZodUndefined:
                    return parseUndefinedDef();
                case lib.pA.ZodNull:
                    return parseNullDef(refs);
                case lib.pA.ZodArray:
                    return parseArrayDef(def, refs);
                case lib.pA.ZodUnion:
                case lib.pA.ZodDiscriminatedUnion:
                    return parseUnionDef(def, refs);
                case lib.pA.ZodIntersection:
                    return parseIntersectionDef(def, refs);
                case lib.pA.ZodTuple:
                    return parseTupleDef(def, refs);
                case lib.pA.ZodRecord:
                    return parseRecordDef(def, refs);
                case lib.pA.ZodLiteral:
                    return parseLiteralDef(def, refs);
                case lib.pA.ZodEnum:
                    return parseEnumDef(def);
                case lib.pA.ZodNativeEnum:
                    return parseNativeEnumDef(def);
                case lib.pA.ZodNullable:
                    return parseNullableDef(def, refs);
                case lib.pA.ZodOptional:
                    return parseOptionalDef(def, refs);
                case lib.pA.ZodMap:
                    return parseMapDef(def, refs);
                case lib.pA.ZodSet:
                    return parseSetDef(def, refs);
                case lib.pA.ZodLazy:
                    return ()=>def.getter()._def;
                case lib.pA.ZodPromise:
                    return parsePromiseDef(def, refs);
                case lib.pA.ZodNaN:
                case lib.pA.ZodNever:
                    return parseNeverDef();
                case lib.pA.ZodEffects:
                    return parseEffectsDef(def, refs);
                case lib.pA.ZodAny:
                    return parseAnyDef();
                case lib.pA.ZodUnknown:
                    return parseUnknownDef();
                case lib.pA.ZodDefault:
                    return parseDefaultDef(def, refs);
                case lib.pA.ZodBranded:
                    return parseBrandedDef(def, refs);
                case lib.pA.ZodReadonly:
                    return parseReadonlyDef(def, refs);
                case lib.pA.ZodCatch:
                    return parseCatchDef(def, refs);
                case lib.pA.ZodPipeline:
                    return parsePipelineDef(def, refs);
                case lib.pA.ZodFunction:
                case lib.pA.ZodVoid:
                case lib.pA.ZodSymbol:
                    return;
                default:
                    return ((_)=>void 0)(0);
            }
        };
        function parseDef(def, refs, forceResolution = false) {
            const seenItem = refs.seen.get(def);
            if (refs.override) {
                const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
                if (overrideResult !== ignoreOverride) return overrideResult;
            }
            if (seenItem && !forceResolution) {
                const seenSchema = get$ref(seenItem, refs);
                if (void 0 !== seenSchema) return seenSchema;
            }
            const newItem = {
                def,
                path: refs.currentPath,
                jsonSchema: void 0
            };
            refs.seen.set(def, newItem);
            const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
            const jsonSchema = "function" == typeof jsonSchemaOrGetter ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
            if (jsonSchema) addMeta(def, refs, jsonSchema);
            if (refs.postProcess) {
                const postProcessResult = refs.postProcess(jsonSchema, def, refs);
                newItem.jsonSchema = jsonSchema;
                return postProcessResult;
            }
            newItem.jsonSchema = jsonSchema;
            return jsonSchema;
        }
        const get$ref = (item, refs)=>{
            switch(refs.$refStrategy){
                case "root":
                    return {
                        $ref: item.path.join("/")
                    };
                case "relative":
                    return {
                        $ref: getRelativePath(refs.currentPath, item.path)
                    };
                case "none":
                case "seen":
                    if (item.path.length < refs.currentPath.length && item.path.every((value, index)=>refs.currentPath[index] === value)) {
                        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                        return {};
                    }
                    return "seen" === refs.$refStrategy ? {} : void 0;
            }
        };
        const getRelativePath = (pathA, pathB)=>{
            let i = 0;
            for(; i < pathA.length && i < pathB.length && pathA[i] === pathB[i]; i++);
            return [
                (pathA.length - i).toString(),
                ...pathB.slice(i)
            ].join("/");
        };
        const addMeta = (def, refs, jsonSchema)=>{
            if (def.description) {
                jsonSchema.description = def.description;
                if (refs.markdownDescription) jsonSchema.markdownDescription = def.description;
            }
            return jsonSchema;
        };
        const zodToJsonSchema_zodToJsonSchema = (schema, options)=>{
            const refs = getRefs(options);
            const definitions = "object" == typeof options && options.definitions ? Object.entries(options.definitions).reduce((acc, [name, schema])=>({
                    ...acc,
                    [name]: parseDef(schema._def, {
                        ...refs,
                        currentPath: [
                            ...refs.basePath,
                            refs.definitionPath,
                            name
                        ]
                    }, true) ?? {}
                }), {}) : void 0;
            const name = "string" == typeof options ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
            const main = parseDef(schema._def, void 0 === name ? refs : {
                ...refs,
                currentPath: [
                    ...refs.basePath,
                    refs.definitionPath,
                    name
                ]
            }, false) ?? {};
            const title = "object" == typeof options && void 0 !== options.name && "title" === options.nameStrategy ? options.name : void 0;
            if (void 0 !== title) main.title = title;
            const combined = void 0 === name ? definitions ? {
                ...main,
                [refs.definitionPath]: definitions
            } : main : {
                $ref: [
                    ..."relative" === refs.$refStrategy ? [] : refs.basePath,
                    refs.definitionPath,
                    name
                ].join("/"),
                [refs.definitionPath]: {
                    ...definitions,
                    [name]: main
                }
            };
            if ("jsonSchema7" === refs.target) combined.$schema = "http://json-schema.org/draft-07/schema#";
            else if ("jsonSchema2019-09" === refs.target || "openAi" === refs.target) combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
            if ("openAi" === refs.target && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
            return combined;
        };
        const dist_esm_node_regex = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
        function esm_node_validate_validate(uuid) {
            return 'string' == typeof uuid && dist_esm_node_regex.test(uuid);
        }
        const dist_esm_node_validate = esm_node_validate_validate;
        function _escapeNodeLabel(nodeLabel) {
            return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
        }
        const MARKDOWN_SPECIAL_CHARS = [
            "*",
            "_",
            "`"
        ];
        function _generateMermaidGraphStyles(nodeColors) {
            let styles = "";
            for (const [className, color] of Object.entries(nodeColors))styles += `\tclassDef ${className} ${color};\n`;
            return styles;
        }
        function drawMermaid(nodes, edges, config) {
            const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = "linear", wrapLabelNWords = 9 } = config ?? {};
            let mermaidGraph = withStyles ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\ngraph TD;\n` : "graph TD;\n";
            if (withStyles) {
                const defaultClassLabel = "default";
                const formatDict = {
                    [defaultClassLabel]: "{0}({1})"
                };
                if (void 0 !== firstNode) formatDict[firstNode] = "{0}([{1}]):::first";
                if (void 0 !== lastNode) formatDict[lastNode] = "{0}([{1}]):::last";
                for (const [key, node] of Object.entries(nodes)){
                    const nodeName = node.name.split(":").pop() ?? "";
                    const label = MARKDOWN_SPECIAL_CHARS.some((char)=>nodeName.startsWith(char) && nodeName.endsWith(char)) ? `<p>${nodeName}</p>` : nodeName;
                    let finalLabel = label;
                    if (Object.keys(node.metadata ?? {}).length) finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {}).map(([k, v])=>`${k} = ${v}`).join("\n")}</em></small>`;
                    const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel]).replace("{0}", _escapeNodeLabel(key)).replace("{1}", finalLabel);
                    mermaidGraph += `\t${nodeLabel}\n`;
                }
            }
            const edgeGroups = {};
            for (const edge of edges){
                const srcParts = edge.source.split(":");
                const tgtParts = edge.target.split(":");
                const commonPrefix = srcParts.filter((src, i)=>src === tgtParts[i]).join(":");
                if (!edgeGroups[commonPrefix]) edgeGroups[commonPrefix] = [];
                edgeGroups[commonPrefix].push(edge);
            }
            const seenSubgraphs = new Set();
            function addSubgraph(edges, prefix) {
                const selfLoop = 1 === edges.length && edges[0].source === edges[0].target;
                if (prefix && !selfLoop) {
                    const subgraph = prefix.split(":").pop();
                    if (seenSubgraphs.has(subgraph)) throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
                    seenSubgraphs.add(subgraph);
                    mermaidGraph += `\tsubgraph ${subgraph}\n`;
                }
                for (const edge of edges){
                    const { source, target, data, conditional } = edge;
                    let edgeLabel = "";
                    if (void 0 !== data) {
                        let edgeData = data;
                        const words = edgeData.split(" ");
                        if (words.length > wrapLabelNWords) edgeData = Array.from({
                            length: Math.ceil(words.length / wrapLabelNWords)
                        }, (_, i)=>words.slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords).join(" ")).join("&nbsp;<br>&nbsp;");
                        edgeLabel = conditional ? ` -. &nbsp;${edgeData}&nbsp; .-> ` : ` -- &nbsp;${edgeData}&nbsp; --> `;
                    } else edgeLabel = conditional ? " -.-> " : " --> ";
                    mermaidGraph += `\t${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};\n`;
                }
                for(const nestedPrefix in edgeGroups)if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);
                if (prefix && !selfLoop) mermaidGraph += "\tend\n";
            }
            addSubgraph(edgeGroups[""] ?? [], "");
            for(const prefix in edgeGroups)if (!prefix.includes(":") && "" !== prefix) addSubgraph(edgeGroups[prefix], prefix);
            if (withStyles) mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});
            return mermaidGraph;
        }
        async function drawMermaidPng(mermaidSyntax, config) {
            let { backgroundColor = "white" } = config ?? {};
            const mermaidSyntaxEncoded = btoa(mermaidSyntax);
            if (void 0 !== backgroundColor) {
                const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
                if (!hexColorPattern.test(backgroundColor)) backgroundColor = `!${backgroundColor}`;
            }
            const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}`;
            const res = await fetch(imageUrl);
            if (!res.ok) throw new Error([
                "Failed to render the graph using the Mermaid.INK API.",
                `Status code: ${res.status}`,
                `Status text: ${res.statusText}`
            ].join("\n"));
            const content = await res.blob();
            return content;
        }
        function nodeDataStr(id, data) {
            if (void 0 !== id && !dist_esm_node_validate(id)) return id;
            if (!isRunnableInterface(data)) return data.name ?? "UnknownSchema";
            try {
                let dataStr = data.getName();
                dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
                return dataStr;
            } catch (error) {
                return data.getName();
            }
        }
        function nodeDataJson(node) {
            if (isRunnableInterface(node.data)) return {
                type: "runnable",
                data: {
                    id: node.data.lc_id,
                    name: node.data.getName()
                }
            };
            return {
                type: "schema",
                data: {
                    ...zodToJsonSchema_zodToJsonSchema(node.data.schema),
                    title: node.data.name
                }
            };
        }
        class Graph {
            constructor(params){
                Object.defineProperty(this, "nodes", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: {}
                });
                Object.defineProperty(this, "edges", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                this.nodes = params?.nodes ?? this.nodes;
                this.edges = params?.edges ?? this.edges;
            }
            toJSON() {
                const stableNodeIds = {};
                Object.values(this.nodes).forEach((node, i)=>{
                    stableNodeIds[node.id] = dist_esm_node_validate(node.id) ? i : node.id;
                });
                return {
                    nodes: Object.values(this.nodes).map((node)=>({
                            id: stableNodeIds[node.id],
                            ...nodeDataJson(node)
                        })),
                    edges: this.edges.map((edge)=>{
                        const item = {
                            source: stableNodeIds[edge.source],
                            target: stableNodeIds[edge.target]
                        };
                        if (void 0 !== edge.data) item.data = edge.data;
                        if (void 0 !== edge.conditional) item.conditional = edge.conditional;
                        return item;
                    })
                };
            }
            addNode(data, id, metadata) {
                if (void 0 !== id && void 0 !== this.nodes[id]) throw new Error(`Node with id ${id} already exists`);
                const nodeId = id ?? esm_node_v4();
                const node = {
                    id: nodeId,
                    data,
                    name: nodeDataStr(id, data),
                    metadata
                };
                this.nodes[nodeId] = node;
                return node;
            }
            removeNode(node) {
                delete this.nodes[node.id];
                this.edges = this.edges.filter((edge)=>edge.source !== node.id && edge.target !== node.id);
            }
            addEdge(source, target, data, conditional) {
                if (void 0 === this.nodes[source.id]) throw new Error(`Source node ${source.id} not in graph`);
                if (void 0 === this.nodes[target.id]) throw new Error(`Target node ${target.id} not in graph`);
                const edge = {
                    source: source.id,
                    target: target.id,
                    data,
                    conditional
                };
                this.edges.push(edge);
                return edge;
            }
            firstNode() {
                return _firstNode(this);
            }
            lastNode() {
                return _lastNode(this);
            }
            extend(graph, prefix = "") {
                let finalPrefix = prefix;
                const nodeIds = Object.values(graph.nodes).map((node)=>node.id);
                if (nodeIds.every(dist_esm_node_validate)) finalPrefix = "";
                const prefixed = (id)=>finalPrefix ? `${finalPrefix}:${id}` : id;
                Object.entries(graph.nodes).forEach(([key, value])=>{
                    this.nodes[prefixed(key)] = {
                        ...value,
                        id: prefixed(key)
                    };
                });
                const newEdges = graph.edges.map((edge)=>({
                        ...edge,
                        source: prefixed(edge.source),
                        target: prefixed(edge.target)
                    }));
                this.edges = [
                    ...this.edges,
                    ...newEdges
                ];
                const first = graph.firstNode();
                const last = graph.lastNode();
                return [
                    first ? {
                        id: prefixed(first.id),
                        data: first.data
                    } : void 0,
                    last ? {
                        id: prefixed(last.id),
                        data: last.data
                    } : void 0
                ];
            }
            trimFirstNode() {
                const firstNode = this.firstNode();
                if (firstNode && _firstNode(this, [
                    firstNode.id
                ])) this.removeNode(firstNode);
            }
            trimLastNode() {
                const lastNode = this.lastNode();
                if (lastNode && _lastNode(this, [
                    lastNode.id
                ])) this.removeNode(lastNode);
            }
            reid() {
                const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node)=>[
                        node.id,
                        node.name
                    ]));
                const nodeLabelCounts = new Map();
                Object.values(nodeLabels).forEach((label)=>{
                    nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);
                });
                const getNodeId = (nodeId)=>{
                    const label = nodeLabels[nodeId];
                    if (dist_esm_node_validate(nodeId) && 1 === nodeLabelCounts.get(label)) return label;
                    return nodeId;
                };
                return new Graph({
                    nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node])=>[
                            getNodeId(id),
                            {
                                ...node,
                                id: getNodeId(id)
                            }
                        ])),
                    edges: this.edges.map((edge)=>({
                            ...edge,
                            source: getNodeId(edge.source),
                            target: getNodeId(edge.target)
                        }))
                });
            }
            drawMermaid(params) {
                const { withStyles, curveStyle, nodeColors = {
                    default: "fill:#f2f0ff,line-height:1.2",
                    first: "fill-opacity:0",
                    last: "fill:#bfb6fc"
                }, wrapLabelNWords } = params ?? {};
                const graph = this.reid();
                const firstNode = graph.firstNode();
                const lastNode = graph.lastNode();
                return drawMermaid(graph.nodes, graph.edges, {
                    firstNode: firstNode?.id,
                    lastNode: lastNode?.id,
                    withStyles,
                    curveStyle,
                    nodeColors,
                    wrapLabelNWords
                });
            }
            async drawMermaidPng(params) {
                const mermaidSyntax = this.drawMermaid(params);
                return drawMermaidPng(mermaidSyntax, {
                    backgroundColor: params?.backgroundColor
                });
            }
        }
        function _firstNode(graph, exclude = []) {
            const targets = new Set(graph.edges.filter((edge)=>!exclude.includes(edge.source)).map((edge)=>edge.target));
            const found = [];
            for (const node of Object.values(graph.nodes))if (!exclude.includes(node.id) && !targets.has(node.id)) found.push(node);
            return 1 === found.length ? found[0] : void 0;
        }
        function _lastNode(graph, exclude = []) {
            const sources = new Set(graph.edges.filter((edge)=>!exclude.includes(edge.target)).map((edge)=>edge.source));
            const found = [];
            for (const node of Object.values(graph.nodes))if (!exclude.includes(node.id) && !sources.has(node.id)) found.push(node);
            return 1 === found.length ? found[0] : void 0;
        }
        function convertToHttpEventStream(stream) {
            const encoder = new TextEncoder();
            const finalStream = new ReadableStream({
                async start (controller) {
                    for await (const chunk of stream)controller.enqueue(encoder.encode(`event: data\ndata: ${JSON.stringify(chunk)}\n\n`));
                    controller.enqueue(encoder.encode("event: end\n\n"));
                    controller.close();
                }
            });
            return IterableReadableStream.fromReadableStream(finalStream);
        }
        function isIterableIterator(thing) {
            return "object" == typeof thing && null !== thing && "function" == typeof thing[Symbol.iterator] && "function" == typeof thing.next;
        }
        const isIterator = (x)=>null != x && "object" == typeof x && "next" in x && "function" == typeof x.next;
        function isAsyncIterable(thing) {
            return "object" == typeof thing && null !== thing && "function" == typeof thing[Symbol.asyncIterator];
        }
        function* consumeIteratorInContext(context, iter) {
            while(true){
                const { value, done } = async_local_storage_AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(context), iter.next.bind(iter), true);
                if (done) break;
                yield value;
            }
        }
        async function* consumeAsyncIterableInContext(context, iter) {
            const iterator = iter[Symbol.asyncIterator]();
            while(true){
                const { value, done } = await async_local_storage_AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(context), iterator.next.bind(iter), true);
                if (done) break;
                yield value;
            }
        }
        var tools_utils = __webpack_require__("../../../../node_modules/@langchain/core/dist/tools/utils.js");
        function base_coerceToDict(value, defaultKey) {
            return !value || Array.isArray(value) || value instanceof Date || "object" != typeof value ? {
                [defaultKey]: value
            } : value;
        }
        class Runnable extends serializable.i {
            constructor(){
                super(...arguments);
                Object.defineProperty(this, "lc_runnable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
            }
            getName(suffix) {
                const name = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
                return suffix ? `${name}${suffix}` : name;
            }
            bind(kwargs) {
                return new RunnableBinding({
                    bound: this,
                    kwargs,
                    config: {}
                });
            }
            map() {
                return new RunnableEach({
                    bound: this
                });
            }
            withRetry(fields) {
                return new RunnableRetry({
                    bound: this,
                    kwargs: {},
                    config: {},
                    maxAttemptNumber: fields?.stopAfterAttempt,
                    ...fields
                });
            }
            withConfig(config) {
                return new RunnableBinding({
                    bound: this,
                    config,
                    kwargs: {}
                });
            }
            withFallbacks(fields) {
                const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
                return new RunnableWithFallbacks({
                    runnable: this,
                    fallbacks
                });
            }
            _getOptionsList(options, length = 0) {
                if (Array.isArray(options) && options.length !== length) throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);
                if (Array.isArray(options)) return options.map(ensureConfig);
                if (length > 1 && !Array.isArray(options) && options.runId) {
                    console.warn("Provided runId will be used only for the first element of the batch.");
                    const subsequent = Object.fromEntries(Object.entries(options).filter(([key])=>"runId" !== key));
                    return Array.from({
                        length
                    }, (_, i)=>ensureConfig(0 === i ? options : subsequent));
                }
                return Array.from({
                    length
                }, ()=>ensureConfig(options));
            }
            async batch(inputs, options, batchOptions) {
                const configList = this._getOptionsList(options ?? {}, inputs.length);
                const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;
                const caller = new async_caller_AsyncCaller({
                    maxConcurrency,
                    onFailedAttempt: (e)=>{
                        throw e;
                    }
                });
                const batchCalls = inputs.map((input, i)=>caller.call(async ()=>{
                        try {
                            const result = await this.invoke(input, configList[i]);
                            return result;
                        } catch (e) {
                            if (batchOptions?.returnExceptions) return e;
                            throw e;
                        }
                    }));
                return Promise.all(batchCalls);
            }
            async *_streamIterator(input, options) {
                yield this.invoke(input, options);
            }
            async stream(input, options) {
                const config = ensureConfig(options);
                const wrappedGenerator = new AsyncGeneratorWithSetup({
                    generator: this._streamIterator(input, config),
                    config
                });
                await wrappedGenerator.setup;
                return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
            }
            _separateRunnableConfigFromCallOptions(options) {
                let runnableConfig;
                runnableConfig = void 0 === options ? ensureConfig(options) : ensureConfig({
                    callbacks: options.callbacks,
                    tags: options.tags,
                    metadata: options.metadata,
                    runName: options.runName,
                    configurable: options.configurable,
                    recursionLimit: options.recursionLimit,
                    maxConcurrency: options.maxConcurrency,
                    runId: options.runId,
                    timeout: options.timeout,
                    signal: options.signal
                });
                const callOptions = {
                    ...options
                };
                delete callOptions.callbacks;
                delete callOptions.tags;
                delete callOptions.metadata;
                delete callOptions.runName;
                delete callOptions.configurable;
                delete callOptions.recursionLimit;
                delete callOptions.maxConcurrency;
                delete callOptions.runId;
                delete callOptions.timeout;
                delete callOptions.signal;
                return [
                    runnableConfig,
                    callOptions
                ];
            }
            async _callWithConfig(func, input, options) {
                const config = ensureConfig(options);
                const callbackManager_ = await getCallbackManagerForConfig(config);
                const runManager = await callbackManager_?.handleChainStart(this.toJSON(), base_coerceToDict(input, "input"), config.runId, config?.runType, void 0, void 0, config?.runName ?? this.getName());
                delete config.runId;
                let output;
                try {
                    const promise = func.call(this, input, config, runManager);
                    output = await raceWithSignal(promise, options?.signal);
                } catch (e) {
                    await runManager?.handleChainError(e);
                    throw e;
                }
                await runManager?.handleChainEnd(base_coerceToDict(output, "output"));
                return output;
            }
            async _batchWithConfig(func, inputs, options, batchOptions) {
                const optionsList = this._getOptionsList(options ?? {}, inputs.length);
                const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));
                const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i)=>{
                    const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), base_coerceToDict(inputs[i], "input"), optionsList[i].runId, optionsList[i].runType, void 0, void 0, optionsList[i].runName ?? this.getName());
                    delete optionsList[i].runId;
                    return handleStartRes;
                }));
                let outputs;
                try {
                    const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);
                    outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);
                } catch (e) {
                    await Promise.all(runManagers.map((runManager)=>runManager?.handleChainError(e)));
                    throw e;
                }
                await Promise.all(runManagers.map((runManager)=>runManager?.handleChainEnd(base_coerceToDict(outputs, "output"))));
                return outputs;
            }
            async *_transformStreamWithConfig(inputGenerator, transformer, options) {
                let finalInput;
                let finalInputSupported = true;
                let finalOutput;
                let finalOutputSupported = true;
                const config = ensureConfig(options);
                const callbackManager_ = await getCallbackManagerForConfig(config);
                async function* wrapInputForTracing() {
                    for await (const chunk of inputGenerator){
                        if (finalInputSupported) {
                            if (void 0 === finalInput) finalInput = chunk;
                            else try {
                                finalInput = concat(finalInput, chunk);
                            } catch  {
                                finalInput = void 0;
                                finalInputSupported = false;
                            }
                        }
                        yield chunk;
                    }
                }
                let runManager;
                try {
                    const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async ()=>callbackManager_?.handleChainStart(this.toJSON(), {
                            input: ""
                        }, config.runId, config.runType, void 0, void 0, config.runName ?? this.getName()), options?.signal, config);
                    delete config.runId;
                    runManager = pipe.setup;
                    const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);
                    let iterator = pipe.output;
                    if (void 0 !== streamEventsHandler && void 0 !== runManager) iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);
                    const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);
                    if (void 0 !== streamLogHandler && void 0 !== runManager) iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);
                    for await (const chunk of iterator){
                        yield chunk;
                        if (finalOutputSupported) {
                            if (void 0 === finalOutput) finalOutput = chunk;
                            else try {
                                finalOutput = concat(finalOutput, chunk);
                            } catch  {
                                finalOutput = void 0;
                                finalOutputSupported = false;
                            }
                        }
                    }
                } catch (e) {
                    await runManager?.handleChainError(e, void 0, void 0, void 0, {
                        inputs: base_coerceToDict(finalInput, "input")
                    });
                    throw e;
                }
                await runManager?.handleChainEnd(finalOutput ?? {}, void 0, void 0, void 0, {
                    inputs: base_coerceToDict(finalInput, "input")
                });
            }
            getGraph(_) {
                const graph = new Graph();
                const inputNode = graph.addNode({
                    name: `${this.getName()}Input`,
                    schema: lib.z.any()
                });
                const runnableNode = graph.addNode(this);
                const outputNode = graph.addNode({
                    name: `${this.getName()}Output`,
                    schema: lib.z.any()
                });
                graph.addEdge(inputNode, runnableNode);
                graph.addEdge(runnableNode, outputNode);
                return graph;
            }
            pipe(coerceable) {
                return new RunnableSequence({
                    first: this,
                    last: _coerceToRunnable(coerceable)
                });
            }
            pick(keys) {
                return this.pipe(new RunnablePick(keys));
            }
            assign(mapping) {
                return this.pipe(new RunnableAssign(new RunnableMap({
                    steps: mapping
                })));
            }
            async *transform(generator, options) {
                let finalChunk;
                for await (const chunk of generator)finalChunk = void 0 === finalChunk ? chunk : concat(finalChunk, chunk);
                yield* this._streamIterator(finalChunk, ensureConfig(options));
            }
            async *streamLog(input, options, streamOptions) {
                const logStreamCallbackHandler = new LogStreamCallbackHandler({
                    ...streamOptions,
                    autoClose: false,
                    _schemaFormat: "original"
                });
                const config = ensureConfig(options);
                yield* this._streamLog(input, logStreamCallbackHandler, config);
            }
            async *_streamLog(input, logStreamCallbackHandler, config) {
                const { callbacks } = config;
                if (void 0 === callbacks) config.callbacks = [
                    logStreamCallbackHandler
                ];
                else if (Array.isArray(callbacks)) config.callbacks = callbacks.concat([
                    logStreamCallbackHandler
                ]);
                else {
                    const copiedCallbacks = callbacks.copy();
                    copiedCallbacks.addHandler(logStreamCallbackHandler, true);
                    config.callbacks = copiedCallbacks;
                }
                const runnableStreamPromise = this.stream(input, config);
                async function consumeRunnableStream() {
                    try {
                        const runnableStream = await runnableStreamPromise;
                        for await (const chunk of runnableStream){
                            const patch = new RunLogPatch({
                                ops: [
                                    {
                                        op: "add",
                                        path: "/streamed_output/-",
                                        value: chunk
                                    }
                                ]
                            });
                            await logStreamCallbackHandler.writer.write(patch);
                        }
                    } finally{
                        await logStreamCallbackHandler.writer.close();
                    }
                }
                const runnableStreamConsumePromise = consumeRunnableStream();
                try {
                    for await (const log of logStreamCallbackHandler)yield log;
                } finally{
                    await runnableStreamConsumePromise;
                }
            }
            streamEvents(input, options, streamOptions) {
                let stream;
                if ("v1" === options.version) stream = this._streamEventsV1(input, options, streamOptions);
                else if ("v2" === options.version) stream = this._streamEventsV2(input, options, streamOptions);
                else throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');
                if ("text/event-stream" === options.encoding) return convertToHttpEventStream(stream);
                return IterableReadableStream.fromAsyncGenerator(stream);
            }
            async *_streamEventsV2(input, options, streamOptions) {
                const eventStreamer = new EventStreamCallbackHandler({
                    ...streamOptions,
                    autoClose: false
                });
                const config = ensureConfig(options);
                const runId = config.runId ?? esm_node_v4();
                config.runId = runId;
                const callbacks = config.callbacks;
                if (void 0 === callbacks) config.callbacks = [
                    eventStreamer
                ];
                else if (Array.isArray(callbacks)) config.callbacks = callbacks.concat(eventStreamer);
                else {
                    const copiedCallbacks = callbacks.copy();
                    copiedCallbacks.addHandler(eventStreamer, true);
                    config.callbacks = copiedCallbacks;
                }
                const abortController = new AbortController();
                const outerThis = this;
                async function consumeRunnableStream() {
                    try {
                        let signal;
                        if (options?.signal) {
                            if ("any" in AbortSignal) signal = AbortSignal.any([
                                abortController.signal,
                                options.signal
                            ]);
                            else {
                                signal = options.signal;
                                options.signal.addEventListener("abort", ()=>{
                                    abortController.abort();
                                }, {
                                    once: true
                                });
                            }
                        } else signal = abortController.signal;
                        const runnableStream = await outerThis.stream(input, {
                            ...config,
                            signal
                        });
                        const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);
                        for await (const _ of tappedStream)if (abortController.signal.aborted) break;
                    } finally{
                        await eventStreamer.finish();
                    }
                }
                const runnableStreamConsumePromise = consumeRunnableStream();
                let firstEventSent = false;
                let firstEventRunId;
                try {
                    for await (const event of eventStreamer){
                        if (!firstEventSent) {
                            event.data.input = input;
                            firstEventSent = true;
                            firstEventRunId = event.run_id;
                            yield event;
                            continue;
                        }
                        if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
                            if (event.data?.input) delete event.data.input;
                        }
                        yield event;
                    }
                } finally{
                    abortController.abort();
                    await runnableStreamConsumePromise;
                }
            }
            async *_streamEventsV1(input, options, streamOptions) {
                let runLog;
                let hasEncounteredStartEvent = false;
                const config = ensureConfig(options);
                const rootTags = config.tags ?? [];
                const rootMetadata = config.metadata ?? {};
                const rootName = config.runName ?? this.getName();
                const logStreamCallbackHandler = new LogStreamCallbackHandler({
                    ...streamOptions,
                    autoClose: false,
                    _schemaFormat: "streaming_events"
                });
                const rootEventFilter = new _RootEventFilter({
                    ...streamOptions
                });
                const logStream = this._streamLog(input, logStreamCallbackHandler, config);
                for await (const log of logStream){
                    runLog = runLog ? runLog.concat(log) : RunLog.fromRunLogPatch(log);
                    if (void 0 === runLog.state) throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
                    if (!hasEncounteredStartEvent) {
                        hasEncounteredStartEvent = true;
                        const state = {
                            ...runLog.state
                        };
                        const event = {
                            run_id: state.id,
                            event: `on_${state.type}_start`,
                            name: rootName,
                            tags: rootTags,
                            metadata: rootMetadata,
                            data: {
                                input
                            }
                        };
                        if (rootEventFilter.includeEvent(event, state.type)) yield event;
                    }
                    const paths = log.ops.filter((op)=>op.path.startsWith("/logs/")).map((op)=>op.path.split("/")[2]);
                    const dedupedPaths = [
                        ...new Set(paths)
                    ];
                    for (const path of dedupedPaths){
                        let eventType;
                        let data = {};
                        const logEntry = runLog.state.logs[path];
                        eventType = void 0 === logEntry.end_time ? logEntry.streamed_output.length > 0 ? "stream" : "start" : "end";
                        if ("start" === eventType) {
                            if (void 0 !== logEntry.inputs) data.input = logEntry.inputs;
                        } else if ("end" === eventType) {
                            if (void 0 !== logEntry.inputs) data.input = logEntry.inputs;
                            data.output = logEntry.final_output;
                        } else if ("stream" === eventType) {
                            const chunkCount = logEntry.streamed_output.length;
                            if (1 !== chunkCount) throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
                            data = {
                                chunk: logEntry.streamed_output[0]
                            };
                            logEntry.streamed_output = [];
                        }
                        yield {
                            event: `on_${logEntry.type}_${eventType}`,
                            name: logEntry.name,
                            run_id: logEntry.id,
                            tags: logEntry.tags,
                            metadata: logEntry.metadata,
                            data
                        };
                    }
                    const { state } = runLog;
                    if (state.streamed_output.length > 0) {
                        const chunkCount = state.streamed_output.length;
                        if (1 !== chunkCount) throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state.name}"`);
                        const data = {
                            chunk: state.streamed_output[0]
                        };
                        state.streamed_output = [];
                        const event = {
                            event: `on_${state.type}_stream`,
                            run_id: state.id,
                            tags: rootTags,
                            metadata: rootMetadata,
                            name: rootName,
                            data
                        };
                        if (rootEventFilter.includeEvent(event, state.type)) yield event;
                    }
                }
                const state = runLog?.state;
                if (void 0 !== state) {
                    const event = {
                        event: `on_${state.type}_end`,
                        name: rootName,
                        run_id: state.id,
                        tags: rootTags,
                        metadata: rootMetadata,
                        data: {
                            output: state.final_output
                        }
                    };
                    if (rootEventFilter.includeEvent(event, state.type)) yield event;
                }
            }
            static isRunnable(thing) {
                return isRunnableInterface(thing);
            }
            withListeners({ onStart, onEnd, onError }) {
                return new RunnableBinding({
                    bound: this,
                    config: {},
                    configFactories: [
                        (config)=>({
                                callbacks: [
                                    new RootListenersTracer({
                                        config,
                                        onStart,
                                        onEnd,
                                        onError
                                    })
                                ]
                            })
                    ]
                });
            }
            asTool(fields) {
                return convertRunnableToTool(this, fields);
            }
        }
        class RunnableBinding extends Runnable {
            static lc_name() {
                return "RunnableBinding";
            }
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "bound", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "config", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "kwargs", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "configFactories", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.bound = fields.bound;
                this.kwargs = fields.kwargs;
                this.config = fields.config;
                this.configFactories = fields.configFactories;
            }
            getName(suffix) {
                return this.bound.getName(suffix);
            }
            async _mergeConfig(...options) {
                const config = mergeConfigs(this.config, ...options);
                return mergeConfigs(config, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory)=>await configFactory(config))) : []);
            }
            bind(kwargs) {
                return new this.constructor({
                    bound: this.bound,
                    kwargs: {
                        ...this.kwargs,
                        ...kwargs
                    },
                    config: this.config
                });
            }
            withConfig(config) {
                return new this.constructor({
                    bound: this.bound,
                    kwargs: this.kwargs,
                    config: {
                        ...this.config,
                        ...config
                    }
                });
            }
            withRetry(fields) {
                return new this.constructor({
                    bound: this.bound.withRetry(fields),
                    kwargs: this.kwargs,
                    config: this.config
                });
            }
            async invoke(input, options) {
                return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
            }
            async batch(inputs, options, batchOptions) {
                const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async (individualOption)=>this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);
                return this.bound.batch(inputs, mergedOptions, batchOptions);
            }
            async *_streamIterator(input, options) {
                yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
            }
            async stream(input, options) {
                return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
            }
            async *transform(generator, options) {
                yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));
            }
            streamEvents(input, options, streamOptions) {
                const outerThis = this;
                const generator = async function*() {
                    yield* outerThis.bound.streamEvents(input, {
                        ...await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs),
                        version: options.version
                    }, streamOptions);
                };
                return IterableReadableStream.fromAsyncGenerator(generator());
            }
            static isRunnableBinding(thing) {
                return thing.bound && Runnable.isRunnable(thing.bound);
            }
            withListeners({ onStart, onEnd, onError }) {
                return new RunnableBinding({
                    bound: this.bound,
                    kwargs: this.kwargs,
                    config: this.config,
                    configFactories: [
                        (config)=>({
                                callbacks: [
                                    new RootListenersTracer({
                                        config,
                                        onStart,
                                        onEnd,
                                        onError
                                    })
                                ]
                            })
                    ]
                });
            }
        }
        class RunnableEach extends Runnable {
            static lc_name() {
                return "RunnableEach";
            }
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "bound", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.bound = fields.bound;
            }
            bind(kwargs) {
                return new RunnableEach({
                    bound: this.bound.bind(kwargs)
                });
            }
            async invoke(inputs, config) {
                return this._callWithConfig(this._invoke.bind(this), inputs, config);
            }
            async _invoke(inputs, config, runManager) {
                return this.bound.batch(inputs, patchConfig(config, {
                    callbacks: runManager?.getChild()
                }));
            }
            withListeners({ onStart, onEnd, onError }) {
                return new RunnableEach({
                    bound: this.bound.withListeners({
                        onStart,
                        onEnd,
                        onError
                    })
                });
            }
        }
        class RunnableRetry extends RunnableBinding {
            static lc_name() {
                return "RunnableRetry";
            }
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "maxAttemptNumber", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: 3
                });
                Object.defineProperty(this, "onFailedAttempt", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: ()=>{}
                });
                this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;
                this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;
            }
            _patchConfigForRetry(attempt, config, runManager) {
                const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
                return patchConfig(config, {
                    callbacks: runManager?.getChild(tag)
                });
            }
            async _invoke(input, config, runManager) {
                return p_retry((attemptNumber)=>super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {
                    onFailedAttempt: (error)=>this.onFailedAttempt(error, input),
                    retries: Math.max(this.maxAttemptNumber - 1, 0),
                    randomize: true
                });
            }
            async invoke(input, config) {
                return this._callWithConfig(this._invoke.bind(this), input, config);
            }
            async _batch(inputs, configs, runManagers, batchOptions) {
                const resultsMap = {};
                try {
                    await p_retry(async (attemptNumber)=>{
                        const remainingIndexes = inputs.map((_, i)=>i).filter((i)=>void 0 === resultsMap[i.toString()] || resultsMap[i.toString()] instanceof Error);
                        const remainingInputs = remainingIndexes.map((i)=>inputs[i]);
                        const patchedConfigs = remainingIndexes.map((i)=>this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));
                        const results = await super.batch(remainingInputs, patchedConfigs, {
                            ...batchOptions,
                            returnExceptions: true
                        });
                        let firstException;
                        for(let i = 0; i < results.length; i += 1){
                            const result = results[i];
                            const resultMapIndex = remainingIndexes[i];
                            if (result instanceof Error) {
                                if (void 0 === firstException) {
                                    firstException = result;
                                    firstException.input = remainingInputs[i];
                                }
                            }
                            resultsMap[resultMapIndex.toString()] = result;
                        }
                        if (firstException) throw firstException;
                        return results;
                    }, {
                        onFailedAttempt: (error)=>this.onFailedAttempt(error, error.input),
                        retries: Math.max(this.maxAttemptNumber - 1, 0),
                        randomize: true
                    });
                } catch (e) {
                    if (batchOptions?.returnExceptions !== true) throw e;
                }
                return Object.keys(resultsMap).sort((a, b)=>parseInt(a, 10) - parseInt(b, 10)).map((key)=>resultsMap[parseInt(key, 10)]);
            }
            async batch(inputs, options, batchOptions) {
                return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);
            }
        }
        class RunnableSequence extends Runnable {
            static lc_name() {
                return "RunnableSequence";
            }
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "first", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "middle", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: []
                });
                Object.defineProperty(this, "last", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "omitSequenceTags", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                this.first = fields.first;
                this.middle = fields.middle ?? this.middle;
                this.last = fields.last;
                this.name = fields.name;
                this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;
            }
            get steps() {
                return [
                    this.first,
                    ...this.middle,
                    this.last
                ];
            }
            async invoke(input, options) {
                const config = ensureConfig(options);
                const callbackManager_ = await getCallbackManagerForConfig(config);
                const runManager = await callbackManager_?.handleChainStart(this.toJSON(), base_coerceToDict(input, "input"), config.runId, void 0, void 0, void 0, config?.runName);
                delete config.runId;
                let nextStepInput = input;
                let finalOutput;
                try {
                    const initialSteps = [
                        this.first,
                        ...this.middle
                    ];
                    for(let i = 0; i < initialSteps.length; i += 1){
                        const step = initialSteps[i];
                        const promise = step.invoke(nextStepInput, patchConfig(config, {
                            callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`)
                        }));
                        nextStepInput = await raceWithSignal(promise, options?.signal);
                    }
                    if (options?.signal?.aborted) throw new Error("Aborted");
                    finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {
                        callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`)
                    }));
                } catch (e) {
                    await runManager?.handleChainError(e);
                    throw e;
                }
                await runManager?.handleChainEnd(base_coerceToDict(finalOutput, "output"));
                return finalOutput;
            }
            async batch(inputs, options, batchOptions) {
                const configList = this._getOptionsList(options ?? {}, inputs.length);
                const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));
                const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i)=>{
                    const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), base_coerceToDict(inputs[i], "input"), configList[i].runId, void 0, void 0, void 0, configList[i].runName);
                    delete configList[i].runId;
                    return handleStartRes;
                }));
                let nextStepInputs = inputs;
                try {
                    for(let i = 0; i < this.steps.length; i += 1){
                        const step = this.steps[i];
                        const promise = step.batch(nextStepInputs, runManagers.map((runManager, j)=>{
                            const childRunManager = runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`);
                            return patchConfig(configList[j], {
                                callbacks: childRunManager
                            });
                        }), batchOptions);
                        nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);
                    }
                } catch (e) {
                    await Promise.all(runManagers.map((runManager)=>runManager?.handleChainError(e)));
                    throw e;
                }
                await Promise.all(runManagers.map((runManager)=>runManager?.handleChainEnd(base_coerceToDict(nextStepInputs, "output"))));
                return nextStepInputs;
            }
            async *_streamIterator(input, options) {
                const callbackManager_ = await getCallbackManagerForConfig(options);
                const { runId, ...otherOptions } = options ?? {};
                const runManager = await callbackManager_?.handleChainStart(this.toJSON(), base_coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherOptions?.runName);
                const steps = [
                    this.first,
                    ...this.middle,
                    this.last
                ];
                let concatSupported = true;
                let finalOutput;
                async function* inputGenerator() {
                    yield input;
                }
                try {
                    let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {
                        callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : "seq:step:1")
                    }));
                    for(let i = 1; i < steps.length; i += 1){
                        const step = steps[i];
                        finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {
                            callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`)
                        }));
                    }
                    for await (const chunk of finalGenerator){
                        options?.signal?.throwIfAborted();
                        yield chunk;
                        if (concatSupported) {
                            if (void 0 === finalOutput) finalOutput = chunk;
                            else try {
                                finalOutput = concat(finalOutput, chunk);
                            } catch (e) {
                                finalOutput = void 0;
                                concatSupported = false;
                            }
                        }
                    }
                } catch (e) {
                    await runManager?.handleChainError(e);
                    throw e;
                }
                await runManager?.handleChainEnd(base_coerceToDict(finalOutput, "output"));
            }
            getGraph(config) {
                const graph = new Graph();
                let currentLastNode = null;
                this.steps.forEach((step, index)=>{
                    const stepGraph = step.getGraph(config);
                    if (0 !== index) stepGraph.trimFirstNode();
                    if (index !== this.steps.length - 1) stepGraph.trimLastNode();
                    graph.extend(stepGraph);
                    const stepFirstNode = stepGraph.firstNode();
                    if (!stepFirstNode) throw new Error(`Runnable ${step} has no first node`);
                    if (currentLastNode) graph.addEdge(currentLastNode, stepFirstNode);
                    currentLastNode = stepGraph.lastNode();
                });
                return graph;
            }
            pipe(coerceable) {
                if (RunnableSequence.isRunnableSequence(coerceable)) return new RunnableSequence({
                    first: this.first,
                    middle: this.middle.concat([
                        this.last,
                        coerceable.first,
                        ...coerceable.middle
                    ]),
                    last: coerceable.last,
                    name: this.name ?? coerceable.name
                });
                return new RunnableSequence({
                    first: this.first,
                    middle: [
                        ...this.middle,
                        this.last
                    ],
                    last: _coerceToRunnable(coerceable),
                    name: this.name
                });
            }
            static isRunnableSequence(thing) {
                return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
            }
            static from([first, ...runnables], nameOrFields) {
                let extra = {};
                if ("string" == typeof nameOrFields) extra.name = nameOrFields;
                else if (void 0 !== nameOrFields) extra = nameOrFields;
                return new RunnableSequence({
                    ...extra,
                    first: _coerceToRunnable(first),
                    middle: runnables.slice(0, -1).map(_coerceToRunnable),
                    last: _coerceToRunnable(runnables[runnables.length - 1])
                });
            }
        }
        class RunnableMap extends Runnable {
            static lc_name() {
                return "RunnableMap";
            }
            getStepsKeys() {
                return Object.keys(this.steps);
            }
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "steps", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.steps = {};
                for (const [key, value] of Object.entries(fields.steps))this.steps[key] = _coerceToRunnable(value);
            }
            static from(steps) {
                return new RunnableMap({
                    steps
                });
            }
            async invoke(input, options) {
                const config = ensureConfig(options);
                const callbackManager_ = await getCallbackManagerForConfig(config);
                const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {
                    input
                }, config.runId, void 0, void 0, void 0, config?.runName);
                delete config.runId;
                const output = {};
                try {
                    const promises = Object.entries(this.steps).map(async ([key, runnable])=>{
                        output[key] = await runnable.invoke(input, patchConfig(config, {
                            callbacks: runManager?.getChild(`map:key:${key}`)
                        }));
                    });
                    await raceWithSignal(Promise.all(promises), options?.signal);
                } catch (e) {
                    await runManager?.handleChainError(e);
                    throw e;
                }
                await runManager?.handleChainEnd(output);
                return output;
            }
            async *_transform(generator, runManager, options) {
                const steps = {
                    ...this.steps
                };
                const inputCopies = atee(generator, Object.keys(steps).length);
                const tasks = new Map(Object.entries(steps).map(([key, runnable], i)=>{
                    const gen = runnable.transform(inputCopies[i], patchConfig(options, {
                        callbacks: runManager?.getChild(`map:key:${key}`)
                    }));
                    return [
                        key,
                        gen.next().then((result)=>({
                                key,
                                gen,
                                result
                            }))
                    ];
                }));
                while(tasks.size){
                    const promise = Promise.race(tasks.values());
                    const { key, result, gen } = await raceWithSignal(promise, options?.signal);
                    tasks.delete(key);
                    if (!result.done) {
                        yield {
                            [key]: result.value
                        };
                        tasks.set(key, gen.next().then((result)=>({
                                key,
                                gen,
                                result
                            })));
                    }
                }
            }
            transform(generator, options) {
                return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
            }
            async stream(input, options) {
                async function* generator() {
                    yield input;
                }
                const config = ensureConfig(options);
                const wrappedGenerator = new AsyncGeneratorWithSetup({
                    generator: this.transform(generator(), config),
                    config
                });
                await wrappedGenerator.setup;
                return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
            }
        }
        class RunnableTraceable extends Runnable {
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: false
                });
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "func", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                if (!isTraceableFunction(fields.func)) throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
                this.func = fields.func;
            }
            async invoke(input, options) {
                const [config] = this._getOptionsList(options ?? {}, 1);
                const callbacks = await getCallbackManagerForConfig(config);
                const promise = this.func(patchConfig(config, {
                    callbacks
                }), input);
                return raceWithSignal(promise, config?.signal);
            }
            async *_streamIterator(input, options) {
                const [config] = this._getOptionsList(options ?? {}, 1);
                const result = await this.invoke(input, options);
                if (isAsyncIterable(result)) {
                    for await (const item of result){
                        config?.signal?.throwIfAborted();
                        yield item;
                    }
                    return;
                }
                if (isIterator(result)) {
                    while(true){
                        config?.signal?.throwIfAborted();
                        const state = result.next();
                        if (state.done) break;
                        yield state.value;
                    }
                    return;
                }
                yield result;
            }
            static from(func) {
                return new RunnableTraceable({
                    func
                });
            }
        }
        function assertNonTraceableFunction(func) {
            if (isTraceableFunction(func)) throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
        }
        class RunnableLambda extends Runnable {
            static lc_name() {
                return "RunnableLambda";
            }
            constructor(fields){
                if (isTraceableFunction(fields.func)) return RunnableTraceable.from(fields.func);
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "func", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                assertNonTraceableFunction(fields.func);
                this.func = fields.func;
            }
            static from(func) {
                return new RunnableLambda({
                    func
                });
            }
            async _invoke(input, config, runManager) {
                return new Promise((resolve, reject)=>{
                    const childConfig = patchConfig(config, {
                        callbacks: runManager?.getChild(),
                        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
                    });
                    async_local_storage_AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async ()=>{
                        try {
                            let output = await this.func(input, {
                                ...childConfig
                            });
                            if (output && Runnable.isRunnable(output)) {
                                if (config?.recursionLimit === 0) throw new Error("Recursion limit reached.");
                                output = await output.invoke(input, {
                                    ...childConfig,
                                    recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
                                });
                            } else if (isAsyncIterable(output)) {
                                let finalOutput;
                                for await (const chunk of consumeAsyncIterableInContext(childConfig, output)){
                                    config?.signal?.throwIfAborted();
                                    if (void 0 === finalOutput) finalOutput = chunk;
                                    else try {
                                        finalOutput = concat(finalOutput, chunk);
                                    } catch (e) {
                                        finalOutput = chunk;
                                    }
                                }
                                output = finalOutput;
                            } else if (isIterableIterator(output)) {
                                let finalOutput;
                                for (const chunk of consumeIteratorInContext(childConfig, output)){
                                    config?.signal?.throwIfAborted();
                                    if (void 0 === finalOutput) finalOutput = chunk;
                                    else try {
                                        finalOutput = concat(finalOutput, chunk);
                                    } catch (e) {
                                        finalOutput = chunk;
                                    }
                                }
                                output = finalOutput;
                            }
                            resolve(output);
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            }
            async invoke(input, options) {
                return this._callWithConfig(this._invoke.bind(this), input, options);
            }
            async *_transform(generator, runManager, config) {
                let finalChunk;
                for await (const chunk of generator)if (void 0 === finalChunk) finalChunk = chunk;
                else try {
                    finalChunk = concat(finalChunk, chunk);
                } catch (e) {
                    finalChunk = chunk;
                }
                const childConfig = patchConfig(config, {
                    callbacks: runManager?.getChild(),
                    recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
                });
                const output = await new Promise((resolve, reject)=>{
                    async_local_storage_AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async ()=>{
                        try {
                            const res = await this.func(finalChunk, {
                                ...childConfig,
                                config: childConfig
                            });
                            resolve(res);
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                if (output && Runnable.isRunnable(output)) {
                    if (config?.recursionLimit === 0) throw new Error("Recursion limit reached.");
                    const stream = await output.stream(finalChunk, childConfig);
                    for await (const chunk of stream)yield chunk;
                } else if (isAsyncIterable(output)) for await (const chunk of consumeAsyncIterableInContext(childConfig, output)){
                    config?.signal?.throwIfAborted();
                    yield chunk;
                }
                else if (isIterableIterator(output)) for (const chunk of consumeIteratorInContext(childConfig, output)){
                    config?.signal?.throwIfAborted();
                    yield chunk;
                }
                else yield output;
            }
            transform(generator, options) {
                return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
            }
            async stream(input, options) {
                async function* generator() {
                    yield input;
                }
                const config = ensureConfig(options);
                const wrappedGenerator = new AsyncGeneratorWithSetup({
                    generator: this.transform(generator(), config),
                    config
                });
                await wrappedGenerator.setup;
                return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
            }
        }
        class RunnableWithFallbacks extends Runnable {
            static lc_name() {
                return "RunnableWithFallbacks";
            }
            constructor(fields){
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "runnable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "fallbacks", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.runnable = fields.runnable;
                this.fallbacks = fields.fallbacks;
            }
            *runnables() {
                yield this.runnable;
                for (const fallback of this.fallbacks)yield fallback;
            }
            async invoke(input, options) {
                const config = ensureConfig(options);
                const callbackManager_ = await getCallbackManagerForConfig(config);
                const { runId, ...otherConfigFields } = config;
                const runManager = await callbackManager_?.handleChainStart(this.toJSON(), base_coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields?.runName);
                const childConfig = patchConfig(otherConfigFields, {
                    callbacks: runManager?.getChild()
                });
                const res = await async_local_storage_AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async ()=>{
                    let firstError;
                    for (const runnable of this.runnables()){
                        config?.signal?.throwIfAborted();
                        try {
                            const output = await runnable.invoke(input, childConfig);
                            await runManager?.handleChainEnd(base_coerceToDict(output, "output"));
                            return output;
                        } catch (e) {
                            if (void 0 === firstError) firstError = e;
                        }
                    }
                    if (void 0 === firstError) throw new Error("No error stored at end of fallback.");
                    await runManager?.handleChainError(firstError);
                    throw firstError;
                });
                return res;
            }
            async *_streamIterator(input, options) {
                const config = ensureConfig(options);
                const callbackManager_ = await getCallbackManagerForConfig(config);
                const { runId, ...otherConfigFields } = config;
                const runManager = await callbackManager_?.handleChainStart(this.toJSON(), base_coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields?.runName);
                let firstError;
                let stream;
                for (const runnable of this.runnables()){
                    config?.signal?.throwIfAborted();
                    const childConfig = patchConfig(otherConfigFields, {
                        callbacks: runManager?.getChild()
                    });
                    try {
                        const originalStream = await runnable.stream(input, childConfig);
                        stream = consumeAsyncIterableInContext(childConfig, originalStream);
                        break;
                    } catch (e) {
                        if (void 0 === firstError) firstError = e;
                    }
                }
                if (void 0 === stream) {
                    const error = firstError ?? new Error("No error stored at end of fallback.");
                    await runManager?.handleChainError(error);
                    throw error;
                }
                let output;
                try {
                    for await (const chunk of stream){
                        yield chunk;
                        try {
                            output = void 0 === output ? output : concat(output, chunk);
                        } catch (e) {
                            output = void 0;
                        }
                    }
                } catch (e) {
                    await runManager?.handleChainError(e);
                    throw e;
                }
                await runManager?.handleChainEnd(base_coerceToDict(output, "output"));
            }
            async batch(inputs, options, batchOptions) {
                if (batchOptions?.returnExceptions) throw new Error("Not implemented.");
                const configList = this._getOptionsList(options ?? {}, inputs.length);
                const callbackManagers = await Promise.all(configList.map((config)=>getCallbackManagerForConfig(config)));
                const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i)=>{
                    const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), base_coerceToDict(inputs[i], "input"), configList[i].runId, void 0, void 0, void 0, configList[i].runName);
                    delete configList[i].runId;
                    return handleStartRes;
                }));
                let firstError;
                for (const runnable of this.runnables()){
                    configList[0].signal?.throwIfAborted();
                    try {
                        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j)=>patchConfig(configList[j], {
                                callbacks: runManager?.getChild()
                            })), batchOptions);
                        await Promise.all(runManagers.map((runManager, i)=>runManager?.handleChainEnd(base_coerceToDict(outputs[i], "output"))));
                        return outputs;
                    } catch (e) {
                        if (void 0 === firstError) firstError = e;
                    }
                }
                if (!firstError) throw new Error("No error stored at end of fallbacks.");
                await Promise.all(runManagers.map((runManager)=>runManager?.handleChainError(firstError)));
                throw firstError;
            }
        }
        function _coerceToRunnable(coerceable) {
            if ("function" == typeof coerceable) return new RunnableLambda({
                func: coerceable
            });
            if (Runnable.isRunnable(coerceable)) return coerceable;
            if (Array.isArray(coerceable) || "object" != typeof coerceable) throw new Error(`Expected a Runnable, function or object.\nInstead got an unsupported type.`);
            {
                const runnables = {};
                for (const [key, value] of Object.entries(coerceable))runnables[key] = _coerceToRunnable(value);
                return new RunnableMap({
                    steps: runnables
                });
            }
        }
        class RunnableAssign extends Runnable {
            static lc_name() {
                return "RunnableAssign";
            }
            constructor(fields){
                if (fields instanceof RunnableMap) fields = {
                    mapper: fields
                };
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "mapper", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.mapper = fields.mapper;
            }
            async invoke(input, options) {
                const mapperResult = await this.mapper.invoke(input, options);
                return {
                    ...input,
                    ...mapperResult
                };
            }
            async *_transform(generator, runManager, options) {
                const mapperKeys = this.mapper.getStepsKeys();
                const [forPassthrough, forMapper] = atee(generator);
                const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, {
                    callbacks: runManager?.getChild()
                }));
                const firstMapperChunkPromise = mapperOutput.next();
                for await (const chunk of forPassthrough){
                    if ("object" != typeof chunk || Array.isArray(chunk)) throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
                    const filtered = Object.fromEntries(Object.entries(chunk).filter(([key])=>!mapperKeys.includes(key)));
                    if (Object.keys(filtered).length > 0) yield filtered;
                }
                yield (await firstMapperChunkPromise).value;
                for await (const chunk of mapperOutput)yield chunk;
            }
            transform(generator, options) {
                return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
            }
            async stream(input, options) {
                async function* generator() {
                    yield input;
                }
                const config = ensureConfig(options);
                const wrappedGenerator = new AsyncGeneratorWithSetup({
                    generator: this.transform(generator(), config),
                    config
                });
                await wrappedGenerator.setup;
                return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
            }
        }
        class RunnablePick extends Runnable {
            static lc_name() {
                return "RunnablePick";
            }
            constructor(fields){
                if ("string" == typeof fields || Array.isArray(fields)) fields = {
                    keys: fields
                };
                super(fields);
                Object.defineProperty(this, "lc_namespace", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: [
                        "langchain_core",
                        "runnables"
                    ]
                });
                Object.defineProperty(this, "lc_serializable", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: true
                });
                Object.defineProperty(this, "keys", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.keys = fields.keys;
            }
            async _pick(input) {
                if ("string" == typeof this.keys) return input[this.keys];
                {
                    const picked = this.keys.map((key)=>[
                            key,
                            input[key]
                        ]).filter((v)=>void 0 !== v[1]);
                    return 0 === picked.length ? void 0 : Object.fromEntries(picked);
                }
            }
            async invoke(input, options) {
                return this._callWithConfig(this._pick.bind(this), input, options);
            }
            async *_transform(generator) {
                for await (const chunk of generator){
                    const picked = await this._pick(chunk);
                    if (void 0 !== picked) yield picked;
                }
            }
            transform(generator, options) {
                return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
            }
            async stream(input, options) {
                async function* generator() {
                    yield input;
                }
                const config = ensureConfig(options);
                const wrappedGenerator = new AsyncGeneratorWithSetup({
                    generator: this.transform(generator(), config),
                    config
                });
                await wrappedGenerator.setup;
                return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
            }
        }
        class RunnableToolLike extends RunnableBinding {
            constructor(fields){
                const sequence = RunnableSequence.from([
                    RunnableLambda.from(async (input)=>{
                        let toolInput;
                        if ((0, tools_utils.u)(input)) try {
                            toolInput = await this.schema.parseAsync(input.args);
                        } catch (e) {
                            throw new tools_utils.Y("Received tool input did not match expected schema", JSON.stringify(input.args));
                        }
                        else toolInput = input;
                        return toolInput;
                    }).withConfig({
                        runName: `${fields.name}:parse_input`
                    }),
                    fields.bound
                ]).withConfig({
                    runName: fields.name
                });
                super({
                    bound: sequence,
                    config: fields.config ?? {}
                });
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "description", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "schema", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.name = fields.name;
                this.description = fields.description;
                this.schema = fields.schema;
            }
            static lc_name() {
                return "RunnableToolLike";
            }
        }
        function convertRunnableToTool(runnable, fields) {
            const name = fields.name ?? runnable.getName();
            const description = fields.description ?? fields.schema?.description;
            if (fields.schema.constructor === lib.z.ZodString) return new RunnableToolLike({
                name,
                description,
                schema: lib.z.object({
                    input: lib.z.string()
                }).transform((input)=>input.input),
                bound: runnable
            });
            return new RunnableToolLike({
                name,
                description,
                schema: fields.schema,
                bound: runnable
            });
        }
    },
    "../../../../node_modules/@langchain/core/dist/tools/utils.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Y: ()=>ToolInputParsingException,
            u: ()=>_isToolCall
        });
        function _isToolCall(toolCall) {
            return !!(toolCall && "object" == typeof toolCall && "type" in toolCall && "tool_call" === toolCall.type);
        }
        class ToolInputParsingException extends Error {
            constructor(message, output){
                super(message);
                Object.defineProperty(this, "output", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.output = output;
            }
        }
    },
    "../../../../node_modules/node-fetch/lib/index.mjs": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            Response: ()=>Response,
            FetchError: ()=>FetchError,
            Headers: ()=>Headers,
            default: ()=>lib,
            AbortError: ()=>AbortError,
            Request: ()=>Request
        });
        var public_api = __webpack_require__("../../../../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js");
        const Readable = __WEBPACK_EXTERNAL_MODULE_stream__["default"].Readable;
        const BUFFER = Symbol('buffer');
        const TYPE = Symbol('type');
        class Blob1 {
            constructor(){
                this[TYPE] = '';
                const blobParts = arguments[0];
                const options = arguments[1];
                const buffers = [];
                if (blobParts) {
                    const a = blobParts;
                    const length = Number(a.length);
                    for(let i = 0; i < length; i++){
                        const element = a[i];
                        let buffer;
                        buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof Blob1 ? element[BUFFER] : Buffer.from('string' == typeof element ? element : String(element));
                        buffer.length;
                        buffers.push(buffer);
                    }
                }
                this[BUFFER] = Buffer.concat(buffers);
                let type = options && void 0 !== options.type && String(options.type).toLowerCase();
                if (type && !/[^\u0020-\u007E]/.test(type)) this[TYPE] = type;
            }
            get size() {
                return this[BUFFER].length;
            }
            get type() {
                return this[TYPE];
            }
            text() {
                return Promise.resolve(this[BUFFER].toString());
            }
            arrayBuffer() {
                const buf = this[BUFFER];
                const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                return Promise.resolve(ab);
            }
            stream() {
                const readable = new Readable();
                readable._read = function() {};
                readable.push(this[BUFFER]);
                readable.push(null);
                return readable;
            }
            toString() {
                return '[object Blob]';
            }
            slice() {
                const size = this.size;
                const start = arguments[0];
                const end = arguments[1];
                let relativeStart, relativeEnd;
                relativeStart = void 0 === start ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
                relativeEnd = void 0 === end ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
                const span = Math.max(relativeEnd - relativeStart, 0);
                const buffer = this[BUFFER];
                const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
                const blob = new Blob1([], {
                    type: arguments[2]
                });
                blob[BUFFER] = slicedBuffer;
                return blob;
            }
        }
        Object.defineProperties(Blob1.prototype, {
            size: {
                enumerable: true
            },
            type: {
                enumerable: true
            },
            slice: {
                enumerable: true
            }
        });
        Object.defineProperty(Blob1.prototype, Symbol.toStringTag, {
            value: 'Blob',
            writable: false,
            enumerable: false,
            configurable: true
        });
        function FetchError(message, type, systemError) {
            Error.call(this, message);
            this.message = message;
            this.type = type;
            if (systemError) this.code = this.errno = systemError.code;
            Error.captureStackTrace(this, this.constructor);
        }
        FetchError.prototype = Object.create(Error.prototype);
        FetchError.prototype.constructor = FetchError;
        FetchError.prototype.name = 'FetchError';
        let convert;
        try {
            convert = require('encoding').convert;
        } catch (e) {}
        const INTERNALS = Symbol('Body internals');
        const PassThrough = __WEBPACK_EXTERNAL_MODULE_stream__["default"].PassThrough;
        function Body(body) {
            var _this = this;
            var _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref$size = _ref.size;
            let size = void 0 === _ref$size ? 0 : _ref$size;
            var _ref$timeout = _ref.timeout;
            let timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
            if (null == body) body = null;
            else if (isURLSearchParams(body)) body = Buffer.from(body.toString());
            else if (isBlob(body)) ;
            else if (Buffer.isBuffer(body)) ;
            else if ('[object ArrayBuffer]' === Object.prototype.toString.call(body)) body = Buffer.from(body);
            else if (ArrayBuffer.isView(body)) body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
            else body instanceof __WEBPACK_EXTERNAL_MODULE_stream__["default"] || (body = Buffer.from(String(body)));
            this[INTERNALS] = {
                body,
                disturbed: false,
                error: null
            };
            this.size = size;
            this.timeout = timeout;
            if (body instanceof __WEBPACK_EXTERNAL_MODULE_stream__["default"]) body.on('error', function(err) {
                const error = 'AbortError' === err.name ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
                _this[INTERNALS].error = error;
            });
        }
        Body.prototype = {
            get body () {
                return this[INTERNALS].body;
            },
            get bodyUsed () {
                return this[INTERNALS].disturbed;
            },
            arrayBuffer () {
                return consumeBody.call(this).then(function(buf) {
                    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                });
            },
            blob () {
                let ct = this.headers && this.headers.get('content-type') || '';
                return consumeBody.call(this).then(function(buf) {
                    return Object.assign(new Blob1([], {
                        type: ct.toLowerCase()
                    }), {
                        [BUFFER]: buf
                    });
                });
            },
            json () {
                var _this2 = this;
                return consumeBody.call(this).then(function(buffer) {
                    try {
                        return JSON.parse(buffer.toString());
                    } catch (err) {
                        return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
                    }
                });
            },
            text () {
                return consumeBody.call(this).then(function(buffer) {
                    return buffer.toString();
                });
            },
            buffer () {
                return consumeBody.call(this);
            },
            textConverted () {
                var _this3 = this;
                return consumeBody.call(this).then(function(buffer) {
                    return convertBody(buffer, _this3.headers);
                });
            }
        };
        Object.defineProperties(Body.prototype, {
            body: {
                enumerable: true
            },
            bodyUsed: {
                enumerable: true
            },
            arrayBuffer: {
                enumerable: true
            },
            blob: {
                enumerable: true
            },
            json: {
                enumerable: true
            },
            text: {
                enumerable: true
            }
        });
        Body.mixIn = function(proto) {
            for (const name of Object.getOwnPropertyNames(Body.prototype))if (!(name in proto)) {
                const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
                Object.defineProperty(proto, name, desc);
            }
        };
        function consumeBody() {
            var _this4 = this;
            if (this[INTERNALS].disturbed) return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
            this[INTERNALS].disturbed = true;
            if (this[INTERNALS].error) return Body.Promise.reject(this[INTERNALS].error);
            let body = this.body;
            if (null === body) return Body.Promise.resolve(Buffer.alloc(0));
            if (isBlob(body)) body = body.stream();
            if (Buffer.isBuffer(body)) return Body.Promise.resolve(body);
            if (!(body instanceof __WEBPACK_EXTERNAL_MODULE_stream__["default"])) return Body.Promise.resolve(Buffer.alloc(0));
            let accum = [];
            let accumBytes = 0;
            let abort = false;
            return new Body.Promise(function(resolve, reject) {
                let resTimeout;
                if (_this4.timeout) resTimeout = setTimeout(function() {
                    abort = true;
                    reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
                }, _this4.timeout);
                body.on('error', function(err) {
                    if ('AbortError' === err.name) {
                        abort = true;
                        reject(err);
                    } else reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
                });
                body.on('data', function(chunk) {
                    if (abort || null === chunk) return;
                    if (_this4.size && accumBytes + chunk.length > _this4.size) {
                        abort = true;
                        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                        return;
                    }
                    accumBytes += chunk.length;
                    accum.push(chunk);
                });
                body.on('end', function() {
                    if (abort) return;
                    clearTimeout(resTimeout);
                    try {
                        resolve(Buffer.concat(accum, accumBytes));
                    } catch (err) {
                        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
                    }
                });
            });
        }
        function convertBody(buffer, headers) {
            if ('function' != typeof convert) throw new Error('The package `encoding` must be installed to use the textConverted() function');
            const ct = headers.get('content-type');
            let charset = 'utf-8';
            let res, str;
            if (ct) res = /charset=([^;]*)/i.exec(ct);
            str = buffer.slice(0, 1024).toString();
            if (!res && str) res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
            if (!res && str) {
                res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
                if (!res) {
                    res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
                    if (res) res.pop();
                }
                if (res) res = /charset=(.*)/i.exec(res.pop());
            }
            if (!res && str) res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
            if (res) {
                charset = res.pop();
                if ('gb2312' === charset || 'gbk' === charset) charset = 'gb18030';
            }
            return convert(buffer, 'UTF-8', charset).toString();
        }
        function isURLSearchParams(obj) {
            if ('object' != typeof obj || 'function' != typeof obj.append || 'function' != typeof obj.delete || 'function' != typeof obj.get || 'function' != typeof obj.getAll || 'function' != typeof obj.has || 'function' != typeof obj.set) return false;
            return 'URLSearchParams' === obj.constructor.name || '[object URLSearchParams]' === Object.prototype.toString.call(obj) || 'function' == typeof obj.sort;
        }
        function isBlob(obj) {
            return 'object' == typeof obj && 'function' == typeof obj.arrayBuffer && 'string' == typeof obj.type && 'function' == typeof obj.stream && 'function' == typeof obj.constructor && 'string' == typeof obj.constructor.name && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
        }
        function clone(instance) {
            let p1, p2;
            let body = instance.body;
            if (instance.bodyUsed) throw new Error('cannot clone body after it is used');
            if (body instanceof __WEBPACK_EXTERNAL_MODULE_stream__["default"] && 'function' != typeof body.getBoundary) {
                p1 = new PassThrough();
                p2 = new PassThrough();
                body.pipe(p1);
                body.pipe(p2);
                instance[INTERNALS].body = p1;
                body = p2;
            }
            return body;
        }
        function extractContentType(body) {
            if (null === body) return null;
            if ('string' == typeof body) return 'text/plain;charset=UTF-8';
            if (isURLSearchParams(body)) return 'application/x-www-form-urlencoded;charset=UTF-8';
            if (isBlob(body)) return body.type || null;
            if (Buffer.isBuffer(body)) return null;
            else if ('[object ArrayBuffer]' === Object.prototype.toString.call(body)) return null;
            else if (ArrayBuffer.isView(body)) return null;
            else if ('function' == typeof body.getBoundary) return `multipart/form-data;boundary=${body.getBoundary()}`;
            else if (body instanceof __WEBPACK_EXTERNAL_MODULE_stream__["default"]) return null;
            else return 'text/plain;charset=UTF-8';
        }
        function getTotalBytes(instance) {
            const body = instance.body;
            if (null === body) return 0;
            if (isBlob(body)) return body.size;
            if (Buffer.isBuffer(body)) return body.length;
            if (!body || 'function' != typeof body.getLengthSync) return null;
            if (body._lengthRetrievers && 0 == body._lengthRetrievers.length || body.hasKnownLength && body.hasKnownLength()) return body.getLengthSync();
            return null;
        }
        function writeToStream(dest, instance) {
            const body = instance.body;
            if (null === body) dest.end();
            else if (isBlob(body)) body.stream().pipe(dest);
            else if (Buffer.isBuffer(body)) {
                dest.write(body);
                dest.end();
            } else body.pipe(dest);
        }
        Body.Promise = global.Promise;
        const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
        const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
        function validateName(name) {
            name = `${name}`;
            if (invalidTokenRegex.test(name) || '' === name) throw new TypeError(`${name} is not a legal HTTP header name`);
        }
        function validateValue(value) {
            value = `${value}`;
            if (invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);
        }
        function find(map, name) {
            name = name.toLowerCase();
            for(const key in map)if (key.toLowerCase() === name) return key;
        }
        const MAP = Symbol('map');
        class Headers {
            constructor(){
                let init = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
                this[MAP] = Object.create(null);
                if (init instanceof Headers) {
                    const rawHeaders = init.raw();
                    const headerNames = Object.keys(rawHeaders);
                    for (const headerName of headerNames)for (const value of rawHeaders[headerName])this.append(headerName, value);
                    return;
                }
                if (null == init) ;
                else if ('object' == typeof init) {
                    const method = init[Symbol.iterator];
                    if (null != method) {
                        if ('function' != typeof method) throw new TypeError('Header pairs must be iterable');
                        const pairs = [];
                        for (const pair of init){
                            if ('object' != typeof pair || 'function' != typeof pair[Symbol.iterator]) throw new TypeError('Each header pair must be iterable');
                            pairs.push(Array.from(pair));
                        }
                        for (const pair of pairs){
                            if (2 !== pair.length) throw new TypeError('Each header pair must be a name/value tuple');
                            this.append(pair[0], pair[1]);
                        }
                    } else for (const key of Object.keys(init)){
                        const value = init[key];
                        this.append(key, value);
                    }
                } else throw new TypeError('Provided initializer must be an object');
            }
            get(name) {
                name = `${name}`;
                validateName(name);
                const key = find(this[MAP], name);
                if (void 0 === key) return null;
                return this[MAP][key].join(', ');
            }
            forEach(callback) {
                let thisArg = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
                let pairs = getHeaders(this);
                let i = 0;
                while(i < pairs.length){
                    var _pairs$i = pairs[i];
                    const name = _pairs$i[0], value = _pairs$i[1];
                    callback.call(thisArg, value, name, this);
                    pairs = getHeaders(this);
                    i++;
                }
            }
            set(name, value) {
                name = `${name}`;
                value = `${value}`;
                validateName(name);
                validateValue(value);
                const key = find(this[MAP], name);
                this[MAP][void 0 !== key ? key : name] = [
                    value
                ];
            }
            append(name, value) {
                name = `${name}`;
                value = `${value}`;
                validateName(name);
                validateValue(value);
                const key = find(this[MAP], name);
                if (void 0 !== key) this[MAP][key].push(value);
                else this[MAP][name] = [
                    value
                ];
            }
            has(name) {
                name = `${name}`;
                validateName(name);
                return void 0 !== find(this[MAP], name);
            }
            delete(name) {
                name = `${name}`;
                validateName(name);
                const key = find(this[MAP], name);
                if (void 0 !== key) delete this[MAP][key];
            }
            raw() {
                return this[MAP];
            }
            keys() {
                return createHeadersIterator(this, 'key');
            }
            values() {
                return createHeadersIterator(this, 'value');
            }
            [Symbol.iterator]() {
                return createHeadersIterator(this, 'key+value');
            }
        }
        Headers.prototype.entries = Headers.prototype[Symbol.iterator];
        Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
            value: 'Headers',
            writable: false,
            enumerable: false,
            configurable: true
        });
        Object.defineProperties(Headers.prototype, {
            get: {
                enumerable: true
            },
            forEach: {
                enumerable: true
            },
            set: {
                enumerable: true
            },
            append: {
                enumerable: true
            },
            has: {
                enumerable: true
            },
            delete: {
                enumerable: true
            },
            keys: {
                enumerable: true
            },
            values: {
                enumerable: true
            },
            entries: {
                enumerable: true
            }
        });
        function getHeaders(headers) {
            let kind = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'key+value';
            const keys = Object.keys(headers[MAP]).sort();
            return keys.map('key' === kind ? function(k) {
                return k.toLowerCase();
            } : 'value' === kind ? function(k) {
                return headers[MAP][k].join(', ');
            } : function(k) {
                return [
                    k.toLowerCase(),
                    headers[MAP][k].join(', ')
                ];
            });
        }
        const INTERNAL = Symbol('internal');
        function createHeadersIterator(target, kind) {
            const iterator = Object.create(HeadersIteratorPrototype);
            iterator[INTERNAL] = {
                target,
                kind,
                index: 0
            };
            return iterator;
        }
        const HeadersIteratorPrototype = Object.setPrototypeOf({
            next () {
                if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) throw new TypeError('Value of `this` is not a HeadersIterator');
                var _INTERNAL = this[INTERNAL];
                const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
                const values = getHeaders(target, kind);
                const len = values.length;
                if (index >= len) return {
                    value: void 0,
                    done: true
                };
                this[INTERNAL].index = index + 1;
                return {
                    value: values[index],
                    done: false
                };
            }
        }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
        Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
            value: 'HeadersIterator',
            writable: false,
            enumerable: false,
            configurable: true
        });
        function exportNodeCompatibleHeaders(headers) {
            const obj = Object.assign({
                __proto__: null
            }, headers[MAP]);
            const hostHeaderKey = find(headers[MAP], 'Host');
            if (void 0 !== hostHeaderKey) obj[hostHeaderKey] = obj[hostHeaderKey][0];
            return obj;
        }
        function createHeadersLenient(obj) {
            const headers = new Headers();
            for (const name of Object.keys(obj))if (!invalidTokenRegex.test(name)) {
                if (Array.isArray(obj[name])) {
                    for (const val of obj[name])if (!invalidHeaderCharRegex.test(val)) {
                        if (void 0 === headers[MAP][name]) headers[MAP][name] = [
                            val
                        ];
                        else headers[MAP][name].push(val);
                    }
                } else if (!invalidHeaderCharRegex.test(obj[name])) headers[MAP][name] = [
                    obj[name]
                ];
            }
            return headers;
        }
        const INTERNALS$1 = Symbol('Response internals');
        const STATUS_CODES = __WEBPACK_EXTERNAL_MODULE_http__["default"].STATUS_CODES;
        class Response {
            constructor(){
                let body = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                let opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                Body.call(this, body, opts);
                const status = opts.status || 200;
                const headers = new Headers(opts.headers);
                if (null != body && !headers.has('Content-Type')) {
                    const contentType = extractContentType(body);
                    if (contentType) headers.append('Content-Type', contentType);
                }
                this[INTERNALS$1] = {
                    url: opts.url,
                    status,
                    statusText: opts.statusText || STATUS_CODES[status],
                    headers,
                    counter: opts.counter
                };
            }
            get url() {
                return this[INTERNALS$1].url || '';
            }
            get status() {
                return this[INTERNALS$1].status;
            }
            get ok() {
                return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
            }
            get redirected() {
                return this[INTERNALS$1].counter > 0;
            }
            get statusText() {
                return this[INTERNALS$1].statusText;
            }
            get headers() {
                return this[INTERNALS$1].headers;
            }
            clone() {
                return new Response(clone(this), {
                    url: this.url,
                    status: this.status,
                    statusText: this.statusText,
                    headers: this.headers,
                    ok: this.ok,
                    redirected: this.redirected
                });
            }
        }
        Body.mixIn(Response.prototype);
        Object.defineProperties(Response.prototype, {
            url: {
                enumerable: true
            },
            status: {
                enumerable: true
            },
            ok: {
                enumerable: true
            },
            redirected: {
                enumerable: true
            },
            statusText: {
                enumerable: true
            },
            headers: {
                enumerable: true
            },
            clone: {
                enumerable: true
            }
        });
        Object.defineProperty(Response.prototype, Symbol.toStringTag, {
            value: 'Response',
            writable: false,
            enumerable: false,
            configurable: true
        });
        const INTERNALS$2 = Symbol('Request internals');
        const URL1 = __WEBPACK_EXTERNAL_MODULE_url__["default"].URL || public_api.URL;
        const parse_url = __WEBPACK_EXTERNAL_MODULE_url__["default"].parse;
        const format_url = __WEBPACK_EXTERNAL_MODULE_url__["default"].format;
        function parseURL(urlStr) {
            if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) urlStr = new URL1(urlStr).toString();
            return parse_url(urlStr);
        }
        const streamDestructionSupported = 'destroy' in __WEBPACK_EXTERNAL_MODULE_stream__["default"].Readable.prototype;
        function isRequest(input) {
            return 'object' == typeof input && 'object' == typeof input[INTERNALS$2];
        }
        function isAbortSignal(signal) {
            const proto = signal && 'object' == typeof signal && Object.getPrototypeOf(signal);
            return !!(proto && 'AbortSignal' === proto.constructor.name);
        }
        class Request {
            constructor(input){
                let init = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                let parsedURL;
                if (isRequest(input)) parsedURL = parseURL(input.url);
                else {
                    parsedURL = input && input.href ? parseURL(input.href) : parseURL(`${input}`);
                    input = {};
                }
                let method = init.method || input.method || 'GET';
                method = method.toUpperCase();
                if ((null != init.body || isRequest(input) && null !== input.body) && ('GET' === method || 'HEAD' === method)) throw new TypeError('Request with GET/HEAD method cannot have body');
                let inputBody = null != init.body ? init.body : isRequest(input) && null !== input.body ? clone(input) : null;
                Body.call(this, inputBody, {
                    timeout: init.timeout || input.timeout || 0,
                    size: init.size || input.size || 0
                });
                const headers = new Headers(init.headers || input.headers || {});
                if (null != inputBody && !headers.has('Content-Type')) {
                    const contentType = extractContentType(inputBody);
                    if (contentType) headers.append('Content-Type', contentType);
                }
                let signal = isRequest(input) ? input.signal : null;
                if ('signal' in init) signal = init.signal;
                if (null != signal && !isAbortSignal(signal)) throw new TypeError('Expected signal to be an instanceof AbortSignal');
                this[INTERNALS$2] = {
                    method,
                    redirect: init.redirect || input.redirect || 'follow',
                    headers,
                    parsedURL,
                    signal
                };
                this.follow = void 0 !== init.follow ? init.follow : void 0 !== input.follow ? input.follow : 20;
                this.compress = void 0 !== init.compress ? init.compress : void 0 !== input.compress ? input.compress : true;
                this.counter = init.counter || input.counter || 0;
                this.agent = init.agent || input.agent;
            }
            get method() {
                return this[INTERNALS$2].method;
            }
            get url() {
                return format_url(this[INTERNALS$2].parsedURL);
            }
            get headers() {
                return this[INTERNALS$2].headers;
            }
            get redirect() {
                return this[INTERNALS$2].redirect;
            }
            get signal() {
                return this[INTERNALS$2].signal;
            }
            clone() {
                return new Request(this);
            }
        }
        Body.mixIn(Request.prototype);
        Object.defineProperty(Request.prototype, Symbol.toStringTag, {
            value: 'Request',
            writable: false,
            enumerable: false,
            configurable: true
        });
        Object.defineProperties(Request.prototype, {
            method: {
                enumerable: true
            },
            url: {
                enumerable: true
            },
            headers: {
                enumerable: true
            },
            redirect: {
                enumerable: true
            },
            clone: {
                enumerable: true
            },
            signal: {
                enumerable: true
            }
        });
        function getNodeRequestOptions(request) {
            const parsedURL = request[INTERNALS$2].parsedURL;
            const headers = new Headers(request[INTERNALS$2].headers);
            if (!headers.has('Accept')) headers.set('Accept', '*/*');
            if (!parsedURL.protocol || !parsedURL.hostname) throw new TypeError('Only absolute URLs are supported');
            if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError('Only HTTP(S) protocols are supported');
            if (request.signal && request.body instanceof __WEBPACK_EXTERNAL_MODULE_stream__["default"].Readable && !streamDestructionSupported) throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
            let contentLengthValue = null;
            if (null == request.body && /^(POST|PUT)$/i.test(request.method)) contentLengthValue = '0';
            if (null != request.body) {
                const totalBytes = getTotalBytes(request);
                if ('number' == typeof totalBytes) contentLengthValue = String(totalBytes);
            }
            if (contentLengthValue) headers.set('Content-Length', contentLengthValue);
            if (!headers.has('User-Agent')) headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
            if (request.compress && !headers.has('Accept-Encoding')) headers.set('Accept-Encoding', 'gzip,deflate');
            let agent = request.agent;
            if ('function' == typeof agent) agent = agent(parsedURL);
            return Object.assign({}, parsedURL, {
                method: request.method,
                headers: exportNodeCompatibleHeaders(headers),
                agent
            });
        }
        function AbortError(message) {
            Error.call(this, message);
            this.type = 'aborted';
            this.message = message;
            Error.captureStackTrace(this, this.constructor);
        }
        AbortError.prototype = Object.create(Error.prototype);
        AbortError.prototype.constructor = AbortError;
        AbortError.prototype.name = 'AbortError';
        const URL$1 = __WEBPACK_EXTERNAL_MODULE_url__["default"].URL || public_api.URL;
        const PassThrough$1 = __WEBPACK_EXTERNAL_MODULE_stream__["default"].PassThrough;
        const lib_isDomainOrSubdomain = function(destination, original) {
            const orig = new URL$1(original).hostname;
            const dest = new URL$1(destination).hostname;
            return orig === dest || '.' === orig[orig.length - dest.length - 1] && orig.endsWith(dest);
        };
        const lib_isSameProtocol = function(destination, original) {
            const orig = new URL$1(original).protocol;
            const dest = new URL$1(destination).protocol;
            return orig === dest;
        };
        function fetch1(url, opts) {
            if (!fetch1.Promise) throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
            Body.Promise = fetch1.Promise;
            return new fetch1.Promise(function(resolve, reject) {
                const request = new Request(url, opts);
                const options = getNodeRequestOptions(request);
                const send = ('https:' === options.protocol ? __WEBPACK_EXTERNAL_MODULE_https__["default"] : __WEBPACK_EXTERNAL_MODULE_http__["default"]).request;
                const signal = request.signal;
                let response = null;
                const abort = function() {
                    let error = new AbortError('The user aborted a request.');
                    reject(error);
                    if (request.body && request.body instanceof __WEBPACK_EXTERNAL_MODULE_stream__["default"].Readable) destroyStream(request.body, error);
                    if (!response || !response.body) return;
                    response.body.emit('error', error);
                };
                if (signal && signal.aborted) {
                    abort();
                    return;
                }
                const abortAndFinalize = function() {
                    abort();
                    finalize();
                };
                const req = send(options);
                let reqTimeout;
                if (signal) signal.addEventListener('abort', abortAndFinalize);
                function finalize() {
                    req.abort();
                    if (signal) signal.removeEventListener('abort', abortAndFinalize);
                    clearTimeout(reqTimeout);
                }
                if (request.timeout) req.once('socket', function(socket) {
                    reqTimeout = setTimeout(function() {
                        reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                        finalize();
                    }, request.timeout);
                });
                req.on('error', function(err) {
                    reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
                    if (response && response.body) destroyStream(response.body, err);
                    finalize();
                });
                fixResponseChunkedTransferBadEnding(req, function(err) {
                    if (signal && signal.aborted) return;
                    if (response && response.body) destroyStream(response.body, err);
                });
                if (parseInt(process.version.substring(1)) < 14) req.on('socket', function(s) {
                    s.addListener('close', function(hadError) {
                        const hasDataListener = s.listenerCount('data') > 0;
                        if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                            const err = new Error('Premature close');
                            err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                            response.body.emit('error', err);
                        }
                    });
                });
                req.on('response', function(res) {
                    clearTimeout(reqTimeout);
                    const headers = createHeadersLenient(res.headers);
                    if (fetch1.isRedirect(res.statusCode)) {
                        const location = headers.get('Location');
                        let locationURL = null;
                        try {
                            locationURL = null === location ? null : new URL$1(location, request.url).toString();
                        } catch (err) {
                            if ('manual' !== request.redirect) {
                                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                                finalize();
                                return;
                            }
                        }
                        switch(request.redirect){
                            case 'error':
                                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                                finalize();
                                return;
                            case 'manual':
                                if (null !== locationURL) try {
                                    headers.set('Location', locationURL);
                                } catch (err) {
                                    reject(err);
                                }
                                break;
                            case 'follow':
                                if (null === locationURL) break;
                                if (request.counter >= request.follow) {
                                    reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                                    finalize();
                                    return;
                                }
                                const requestOpts = {
                                    headers: new Headers(request.headers),
                                    follow: request.follow,
                                    counter: request.counter + 1,
                                    agent: request.agent,
                                    compress: request.compress,
                                    method: request.method,
                                    body: request.body,
                                    signal: request.signal,
                                    timeout: request.timeout,
                                    size: request.size
                                };
                                if (!lib_isDomainOrSubdomain(request.url, locationURL) || !lib_isSameProtocol(request.url, locationURL)) for (const name of [
                                    'authorization',
                                    'www-authenticate',
                                    'cookie',
                                    'cookie2'
                                ])requestOpts.headers.delete(name);
                                if (303 !== res.statusCode && request.body && null === getTotalBytes(request)) {
                                    reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                                    finalize();
                                    return;
                                }
                                if (303 === res.statusCode || (301 === res.statusCode || 302 === res.statusCode) && 'POST' === request.method) {
                                    requestOpts.method = 'GET';
                                    requestOpts.body = void 0;
                                    requestOpts.headers.delete('content-length');
                                }
                                resolve(fetch1(new Request(locationURL, requestOpts)));
                                finalize();
                                return;
                        }
                    }
                    res.once('end', function() {
                        if (signal) signal.removeEventListener('abort', abortAndFinalize);
                    });
                    let body = res.pipe(new PassThrough$1());
                    const response_options = {
                        url: request.url,
                        status: res.statusCode,
                        statusText: res.statusMessage,
                        headers: headers,
                        size: request.size,
                        timeout: request.timeout,
                        counter: request.counter
                    };
                    const codings = headers.get('Content-Encoding');
                    if (!request.compress || 'HEAD' === request.method || null === codings || 204 === res.statusCode || 304 === res.statusCode) {
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    const zlibOptions = {
                        flush: __WEBPACK_EXTERNAL_MODULE_zlib__["default"].Z_SYNC_FLUSH,
                        finishFlush: __WEBPACK_EXTERNAL_MODULE_zlib__["default"].Z_SYNC_FLUSH
                    };
                    if ('gzip' == codings || 'x-gzip' == codings) {
                        body = body.pipe(__WEBPACK_EXTERNAL_MODULE_zlib__["default"].createGunzip(zlibOptions));
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    if ('deflate' == codings || 'x-deflate' == codings) {
                        const raw = res.pipe(new PassThrough$1());
                        raw.once('data', function(chunk) {
                            body = (0x0F & chunk[0]) === 0x08 ? body.pipe(__WEBPACK_EXTERNAL_MODULE_zlib__["default"].createInflate()) : body.pipe(__WEBPACK_EXTERNAL_MODULE_zlib__["default"].createInflateRaw());
                            response = new Response(body, response_options);
                            resolve(response);
                        });
                        raw.on('end', function() {
                            if (!response) {
                                response = new Response(body, response_options);
                                resolve(response);
                            }
                        });
                        return;
                    }
                    if ('br' == codings && 'function' == typeof __WEBPACK_EXTERNAL_MODULE_zlib__["default"].createBrotliDecompress) {
                        body = body.pipe(__WEBPACK_EXTERNAL_MODULE_zlib__["default"].createBrotliDecompress());
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    response = new Response(body, response_options);
                    resolve(response);
                });
                writeToStream(req, request);
            });
        }
        function fixResponseChunkedTransferBadEnding(request, errorCallback) {
            let socket;
            request.on('socket', function(s) {
                socket = s;
            });
            request.on('response', function(response) {
                const headers = response.headers;
                if ('chunked' === headers['transfer-encoding'] && !headers['content-length']) response.once('close', function(hadError) {
                    const hasDataListener = socket && socket.listenerCount('data') > 0;
                    if (hasDataListener && !hadError) {
                        const err = new Error('Premature close');
                        err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        errorCallback(err);
                    }
                });
            });
        }
        function destroyStream(stream, err) {
            if (stream.destroy) stream.destroy(err);
            else {
                stream.emit('error', err);
                stream.end();
            }
        }
        fetch1.isRedirect = function(code) {
            return 301 === code || 302 === code || 303 === code || 307 === code || 308 === code;
        };
        fetch1.Promise = global.Promise;
        const lib = fetch1;
    },
    "../../../../node_modules/zod/lib/index.mjs": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            ak: ()=>ZodOptional,
            pA: ()=>ZodFirstPartyTypeKind,
            z: ()=>z
        });
        var util;
        (function(util) {
            util.assertEqual = (val)=>val;
            function assertIs(_arg) {}
            util.assertIs = assertIs;
            function assertNever(_x) {
                throw new Error();
            }
            util.assertNever = assertNever;
            util.arrayToEnum = (items)=>{
                const obj = {};
                for (const item of items)obj[item] = item;
                return obj;
            };
            util.getValidEnumValues = (obj)=>{
                const validKeys = util.objectKeys(obj).filter((k)=>"number" != typeof obj[obj[k]]);
                const filtered = {};
                for (const k of validKeys)filtered[k] = obj[k];
                return util.objectValues(filtered);
            };
            util.objectValues = (obj)=>util.objectKeys(obj).map(function(e) {
                    return obj[e];
                });
            util.objectKeys = "function" == typeof Object.keys ? (obj)=>Object.keys(obj) : (object)=>{
                const keys = [];
                for(const key in object)if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
                return keys;
            };
            util.find = (arr, checker)=>{
                for (const item of arr)if (checker(item)) return item;
            };
            util.isInteger = "function" == typeof Number.isInteger ? (val)=>Number.isInteger(val) : (val)=>"number" == typeof val && isFinite(val) && Math.floor(val) === val;
            function joinValues(array, separator = " | ") {
                return array.map((val)=>"string" == typeof val ? `'${val}'` : val).join(separator);
            }
            util.joinValues = joinValues;
            util.jsonStringifyReplacer = (_, value)=>{
                if ("bigint" == typeof value) return value.toString();
                return value;
            };
        })(util || (util = {}));
        var objectUtil;
        (function(objectUtil) {
            objectUtil.mergeShapes = (first, second)=>({
                    ...first,
                    ...second
                });
        })(objectUtil || (objectUtil = {}));
        const ZodParsedType = util.arrayToEnum([
            "string",
            "nan",
            "number",
            "integer",
            "float",
            "boolean",
            "date",
            "bigint",
            "symbol",
            "function",
            "undefined",
            "null",
            "array",
            "object",
            "unknown",
            "promise",
            "void",
            "never",
            "map",
            "set"
        ]);
        const getParsedType = (data)=>{
            const t = typeof data;
            switch(t){
                case "undefined":
                    return ZodParsedType.undefined;
                case "string":
                    return ZodParsedType.string;
                case "number":
                    return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
                case "boolean":
                    return ZodParsedType.boolean;
                case "function":
                    return ZodParsedType.function;
                case "bigint":
                    return ZodParsedType.bigint;
                case "symbol":
                    return ZodParsedType.symbol;
                case "object":
                    if (Array.isArray(data)) return ZodParsedType.array;
                    if (null === data) return ZodParsedType.null;
                    if (data.then && "function" == typeof data.then && data.catch && "function" == typeof data.catch) return ZodParsedType.promise;
                    if ("undefined" != typeof Map && data instanceof Map) return ZodParsedType.map;
                    if ("undefined" != typeof Set && data instanceof Set) return ZodParsedType.set;
                    if ("undefined" != typeof Date && data instanceof Date) return ZodParsedType.date;
                    return ZodParsedType.object;
                default:
                    return ZodParsedType.unknown;
            }
        };
        const ZodIssueCode = util.arrayToEnum([
            "invalid_type",
            "invalid_literal",
            "custom",
            "invalid_union",
            "invalid_union_discriminator",
            "invalid_enum_value",
            "unrecognized_keys",
            "invalid_arguments",
            "invalid_return_type",
            "invalid_date",
            "invalid_string",
            "too_small",
            "too_big",
            "invalid_intersection_types",
            "not_multiple_of",
            "not_finite"
        ]);
        const quotelessJson = (obj)=>{
            const json = JSON.stringify(obj, null, 2);
            return json.replace(/"([^"]+)":/g, "$1:");
        };
        class ZodError extends Error {
            get errors() {
                return this.issues;
            }
            constructor(issues){
                super();
                this.issues = [];
                this.addIssue = (sub)=>{
                    this.issues = [
                        ...this.issues,
                        sub
                    ];
                };
                this.addIssues = (subs = [])=>{
                    this.issues = [
                        ...this.issues,
                        ...subs
                    ];
                };
                const actualProto = new.target.prototype;
                if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
                else this.__proto__ = actualProto;
                this.name = "ZodError";
                this.issues = issues;
            }
            format(_mapper) {
                const mapper = _mapper || function(issue) {
                    return issue.message;
                };
                const fieldErrors = {
                    _errors: []
                };
                const processError = (error)=>{
                    for (const issue of error.issues)if ("invalid_union" === issue.code) issue.unionErrors.map(processError);
                    else if ("invalid_return_type" === issue.code) processError(issue.returnTypeError);
                    else if ("invalid_arguments" === issue.code) processError(issue.argumentsError);
                    else if (0 === issue.path.length) fieldErrors._errors.push(mapper(issue));
                    else {
                        let curr = fieldErrors;
                        let i = 0;
                        while(i < issue.path.length){
                            const el = issue.path[i];
                            const terminal = i === issue.path.length - 1;
                            if (terminal) {
                                curr[el] = curr[el] || {
                                    _errors: []
                                };
                                curr[el]._errors.push(mapper(issue));
                            } else curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr = curr[el];
                            i++;
                        }
                    }
                };
                processError(this);
                return fieldErrors;
            }
            static assert(value) {
                if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
            }
            toString() {
                return this.message;
            }
            get message() {
                return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
            }
            get isEmpty() {
                return 0 === this.issues.length;
            }
            flatten(mapper = (issue)=>issue.message) {
                const fieldErrors = {};
                const formErrors = [];
                for (const sub of this.issues)if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(mapper(sub));
                } else formErrors.push(mapper(sub));
                return {
                    formErrors,
                    fieldErrors
                };
            }
            get formErrors() {
                return this.flatten();
            }
        }
        ZodError.create = (issues)=>{
            const error = new ZodError(issues);
            return error;
        };
        const errorMap = (issue, _ctx)=>{
            let message;
            switch(issue.code){
                case ZodIssueCode.invalid_type:
                    message = issue.received === ZodParsedType.undefined ? "Required" : `Expected ${issue.expected}, received ${issue.received}`;
                    break;
                case ZodIssueCode.invalid_literal:
                    message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
                    break;
                case ZodIssueCode.unrecognized_keys:
                    message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
                    break;
                case ZodIssueCode.invalid_union:
                    message = "Invalid input";
                    break;
                case ZodIssueCode.invalid_union_discriminator:
                    message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
                    break;
                case ZodIssueCode.invalid_enum_value:
                    message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
                    break;
                case ZodIssueCode.invalid_arguments:
                    message = "Invalid function arguments";
                    break;
                case ZodIssueCode.invalid_return_type:
                    message = "Invalid function return type";
                    break;
                case ZodIssueCode.invalid_date:
                    message = "Invalid date";
                    break;
                case ZodIssueCode.invalid_string:
                    if ("object" == typeof issue.validation) {
                        if ("includes" in issue.validation) {
                            message = `Invalid input: must include "${issue.validation.includes}"`;
                            if ("number" == typeof issue.validation.position) message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                        } else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                        else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                        else util.assertNever(issue.validation);
                    } else message = "regex" !== issue.validation ? `Invalid ${issue.validation}` : "Invalid";
                    break;
                case ZodIssueCode.too_small:
                    message = "array" === issue.type ? `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "more than"} ${issue.minimum} element(s)` : "string" === issue.type ? `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "over"} ${issue.minimum} character(s)` : "number" === issue.type ? `Number must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${issue.minimum}` : "date" === issue.type ? `Date must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue.minimum))}` : "Invalid input";
                    break;
                case ZodIssueCode.too_big:
                    message = "array" === issue.type ? `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "less than"} ${issue.maximum} element(s)` : "string" === issue.type ? `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "under"} ${issue.maximum} character(s)` : "number" === issue.type ? `Number must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : "bigint" === issue.type ? `BigInt must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : "date" === issue.type ? `Date must be ${issue.exact ? "exactly" : issue.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue.maximum))}` : "Invalid input";
                    break;
                case ZodIssueCode.custom:
                    message = "Invalid input";
                    break;
                case ZodIssueCode.invalid_intersection_types:
                    message = "Intersection results could not be merged";
                    break;
                case ZodIssueCode.not_multiple_of:
                    message = `Number must be a multiple of ${issue.multipleOf}`;
                    break;
                case ZodIssueCode.not_finite:
                    message = "Number must be finite";
                    break;
                default:
                    message = _ctx.defaultError;
                    util.assertNever(issue);
            }
            return {
                message
            };
        };
        let overrideErrorMap = errorMap;
        function setErrorMap(map) {
            overrideErrorMap = map;
        }
        function getErrorMap() {
            return overrideErrorMap;
        }
        const makeIssue = (params)=>{
            const { data, path, errorMaps, issueData } = params;
            const fullPath = [
                ...path,
                ...issueData.path || []
            ];
            const fullIssue = {
                ...issueData,
                path: fullPath
            };
            if (void 0 !== issueData.message) return {
                ...issueData,
                path: fullPath,
                message: issueData.message
            };
            let errorMessage = "";
            const maps = errorMaps.filter((m)=>!!m).slice().reverse();
            for (const map of maps)errorMessage = map(fullIssue, {
                data,
                defaultError: errorMessage
            }).message;
            return {
                ...issueData,
                path: fullPath,
                message: errorMessage
            };
        };
        const EMPTY_PATH = [];
        function addIssueToContext(ctx, issueData) {
            const overrideMap = getErrorMap();
            const issue = makeIssue({
                issueData: issueData,
                data: ctx.data,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideMap,
                    overrideMap === errorMap ? void 0 : errorMap
                ].filter((x)=>!!x)
            });
            ctx.common.issues.push(issue);
        }
        class ParseStatus {
            constructor(){
                this.value = "valid";
            }
            dirty() {
                if ("valid" === this.value) this.value = "dirty";
            }
            abort() {
                if ("aborted" !== this.value) this.value = "aborted";
            }
            static mergeArray(status, results) {
                const arrayValue = [];
                for (const s of results){
                    if ("aborted" === s.status) return INVALID;
                    if ("dirty" === s.status) status.dirty();
                    arrayValue.push(s.value);
                }
                return {
                    status: status.value,
                    value: arrayValue
                };
            }
            static async mergeObjectAsync(status, pairs) {
                const syncPairs = [];
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value
                    });
                }
                return ParseStatus.mergeObjectSync(status, syncPairs);
            }
            static mergeObjectSync(status, pairs) {
                const finalObject = {};
                for (const pair of pairs){
                    const { key, value } = pair;
                    if ("aborted" === key.status) return INVALID;
                    if ("aborted" === value.status) return INVALID;
                    if ("dirty" === key.status) status.dirty();
                    if ("dirty" === value.status) status.dirty();
                    if ("__proto__" !== key.value && (void 0 !== value.value || pair.alwaysSet)) finalObject[key.value] = value.value;
                }
                return {
                    status: status.value,
                    value: finalObject
                };
            }
        }
        const INVALID = Object.freeze({
            status: "aborted"
        });
        const DIRTY = (value)=>({
                status: "dirty",
                value
            });
        const OK = (value)=>({
                status: "valid",
                value
            });
        const isAborted = (x)=>"aborted" === x.status;
        const isDirty = (x)=>"dirty" === x.status;
        const isValid = (x)=>"valid" === x.status;
        const isAsync = (x)=>"undefined" != typeof Promise && x instanceof Promise;
        function __classPrivateFieldGet(receiver, state, kind, f) {
            if ("a" === kind && !f) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof state ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === kind ? f : "a" === kind ? f.call(receiver) : f ? f.value : state.get(receiver);
        }
        function __classPrivateFieldSet(receiver, state, value, kind, f) {
            if ("m" === kind) throw new TypeError("Private method is not writable");
            if ("a" === kind && !f) throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof state ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === kind ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        }
        "function" == typeof SuppressedError && SuppressedError;
        var errorUtil;
        (function(errorUtil) {
            errorUtil.errToObj = (message)=>"string" == typeof message ? {
                    message
                } : message || {};
            errorUtil.toString = (message)=>"string" == typeof message ? message : null == message ? void 0 : message.message;
        })(errorUtil || (errorUtil = {}));
        var _ZodEnum_cache, _ZodNativeEnum_cache;
        class ParseInputLazyPath {
            constructor(parent, value, path, key){
                this._cachedPath = [];
                this.parent = parent;
                this.data = value;
                this._path = path;
                this._key = key;
            }
            get path() {
                if (!this._cachedPath.length) {
                    if (this._key instanceof Array) this._cachedPath.push(...this._path, ...this._key);
                    else this._cachedPath.push(...this._path, this._key);
                }
                return this._cachedPath;
            }
        }
        const handleResult = (ctx, result)=>{
            if (isValid(result)) return {
                success: true,
                data: result.value
            };
            if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
            return {
                success: false,
                get error () {
                    if (this._error) return this._error;
                    const error = new ZodError(ctx.common.issues);
                    this._error = error;
                    return this._error;
                }
            };
        };
        function processCreateParams(params) {
            if (!params) return {};
            const { errorMap, invalid_type_error, required_error, description } = params;
            if (errorMap && (invalid_type_error || required_error)) throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
            if (errorMap) return {
                errorMap: errorMap,
                description
            };
            const customMap = (iss, ctx)=>{
                var _a, _b;
                const { message } = params;
                if ("invalid_enum_value" === iss.code) return {
                    message: null != message ? message : ctx.defaultError
                };
                if (void 0 === ctx.data) return {
                    message: null !== (_a = null != message ? message : required_error) && void 0 !== _a ? _a : ctx.defaultError
                };
                if ("invalid_type" !== iss.code) return {
                    message: ctx.defaultError
                };
                return {
                    message: null !== (_b = null != message ? message : invalid_type_error) && void 0 !== _b ? _b : ctx.defaultError
                };
            };
            return {
                errorMap: customMap,
                description
            };
        }
        class ZodType {
            get description() {
                return this._def.description;
            }
            _getType(input) {
                return getParsedType(input.data);
            }
            _getOrReturnCtx(input, ctx) {
                return ctx || {
                    common: input.parent.common,
                    data: input.data,
                    parsedType: getParsedType(input.data),
                    schemaErrorMap: this._def.errorMap,
                    path: input.path,
                    parent: input.parent
                };
            }
            _processInputParams(input) {
                return {
                    status: new ParseStatus(),
                    ctx: {
                        common: input.parent.common,
                        data: input.data,
                        parsedType: getParsedType(input.data),
                        schemaErrorMap: this._def.errorMap,
                        path: input.path,
                        parent: input.parent
                    }
                };
            }
            _parseSync(input) {
                const result = this._parse(input);
                if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
                return result;
            }
            _parseAsync(input) {
                const result = this._parse(input);
                return Promise.resolve(result);
            }
            parse(data, params) {
                const result = this.safeParse(data, params);
                if (result.success) return result.data;
                throw result.error;
            }
            safeParse(data, params) {
                var _a;
                const ctx = {
                    common: {
                        issues: [],
                        async: null !== (_a = null == params ? void 0 : params.async) && void 0 !== _a ? _a : false,
                        contextualErrorMap: null == params ? void 0 : params.errorMap
                    },
                    path: (null == params ? void 0 : params.path) || [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                const result = this._parseSync({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
                return handleResult(ctx, result);
            }
            "~validate"(data) {
                var _a, _b;
                const ctx = {
                    common: {
                        issues: [],
                        async: !!this["~standard"].async
                    },
                    path: [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                if (!this["~standard"].async) try {
                    const result = this._parseSync({
                        data,
                        path: [],
                        parent: ctx
                    });
                    return isValid(result) ? {
                        value: result.value
                    } : {
                        issues: ctx.common.issues
                    };
                } catch (err) {
                    if (null === (_b = null === (_a = null == err ? void 0 : err.message) || void 0 === _a ? void 0 : _a.toLowerCase()) || void 0 === _b ? void 0 : _b.includes("encountered")) this["~standard"].async = true;
                    ctx.common = {
                        issues: [],
                        async: true
                    };
                }
                return this._parseAsync({
                    data,
                    path: [],
                    parent: ctx
                }).then((result)=>isValid(result) ? {
                        value: result.value
                    } : {
                        issues: ctx.common.issues
                    });
            }
            async parseAsync(data, params) {
                const result = await this.safeParseAsync(data, params);
                if (result.success) return result.data;
                throw result.error;
            }
            async safeParseAsync(data, params) {
                const ctx = {
                    common: {
                        issues: [],
                        contextualErrorMap: null == params ? void 0 : params.errorMap,
                        async: true
                    },
                    path: (null == params ? void 0 : params.path) || [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                const maybeAsyncResult = this._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
                const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
                return handleResult(ctx, result);
            }
            refine(check, message) {
                const getIssueProperties = (val)=>{
                    if ("string" == typeof message || void 0 === message) return {
                        message
                    };
                    if ("function" == typeof message) return message(val);
                    return message;
                };
                return this._refinement((val, ctx)=>{
                    const result = check(val);
                    const setError = ()=>ctx.addIssue({
                            code: ZodIssueCode.custom,
                            ...getIssueProperties(val)
                        });
                    if ("undefined" != typeof Promise && result instanceof Promise) return result.then((data)=>{
                        if (data) return true;
                        setError();
                        return false;
                    });
                    if (result) return true;
                    setError();
                    return false;
                });
            }
            refinement(check, refinementData) {
                return this._refinement((val, ctx)=>{
                    if (check(val)) return true;
                    ctx.addIssue("function" == typeof refinementData ? refinementData(val, ctx) : refinementData);
                    return false;
                });
            }
            _refinement(refinement) {
                return new ZodEffects({
                    schema: this,
                    typeName: ZodFirstPartyTypeKind.ZodEffects,
                    effect: {
                        type: "refinement",
                        refinement
                    }
                });
            }
            superRefine(refinement) {
                return this._refinement(refinement);
            }
            constructor(def){
                this.spa = this.safeParseAsync;
                this._def = def;
                this.parse = this.parse.bind(this);
                this.safeParse = this.safeParse.bind(this);
                this.parseAsync = this.parseAsync.bind(this);
                this.safeParseAsync = this.safeParseAsync.bind(this);
                this.spa = this.spa.bind(this);
                this.refine = this.refine.bind(this);
                this.refinement = this.refinement.bind(this);
                this.superRefine = this.superRefine.bind(this);
                this.optional = this.optional.bind(this);
                this.nullable = this.nullable.bind(this);
                this.nullish = this.nullish.bind(this);
                this.array = this.array.bind(this);
                this.promise = this.promise.bind(this);
                this.or = this.or.bind(this);
                this.and = this.and.bind(this);
                this.transform = this.transform.bind(this);
                this.brand = this.brand.bind(this);
                this.default = this.default.bind(this);
                this.catch = this.catch.bind(this);
                this.describe = this.describe.bind(this);
                this.pipe = this.pipe.bind(this);
                this.readonly = this.readonly.bind(this);
                this.isNullable = this.isNullable.bind(this);
                this.isOptional = this.isOptional.bind(this);
                this["~standard"] = {
                    version: 1,
                    vendor: "zod",
                    validate: (data)=>this["~validate"](data)
                };
            }
            optional() {
                return ZodOptional.create(this, this._def);
            }
            nullable() {
                return ZodNullable.create(this, this._def);
            }
            nullish() {
                return this.nullable().optional();
            }
            array() {
                return ZodArray.create(this);
            }
            promise() {
                return ZodPromise.create(this, this._def);
            }
            or(option) {
                return ZodUnion.create([
                    this,
                    option
                ], this._def);
            }
            and(incoming) {
                return ZodIntersection.create(this, incoming, this._def);
            }
            transform(transform) {
                return new ZodEffects({
                    ...processCreateParams(this._def),
                    schema: this,
                    typeName: ZodFirstPartyTypeKind.ZodEffects,
                    effect: {
                        type: "transform",
                        transform
                    }
                });
            }
            default(def) {
                const defaultValueFunc = "function" == typeof def ? def : ()=>def;
                return new ZodDefault({
                    ...processCreateParams(this._def),
                    innerType: this,
                    defaultValue: defaultValueFunc,
                    typeName: ZodFirstPartyTypeKind.ZodDefault
                });
            }
            brand() {
                return new ZodBranded({
                    typeName: ZodFirstPartyTypeKind.ZodBranded,
                    type: this,
                    ...processCreateParams(this._def)
                });
            }
            catch(def) {
                const catchValueFunc = "function" == typeof def ? def : ()=>def;
                return new ZodCatch({
                    ...processCreateParams(this._def),
                    innerType: this,
                    catchValue: catchValueFunc,
                    typeName: ZodFirstPartyTypeKind.ZodCatch
                });
            }
            describe(description) {
                const This = this.constructor;
                return new This({
                    ...this._def,
                    description
                });
            }
            pipe(target) {
                return ZodPipeline.create(this, target);
            }
            readonly() {
                return ZodReadonly.create(this);
            }
            isOptional() {
                return this.safeParse(void 0).success;
            }
            isNullable() {
                return this.safeParse(null).success;
            }
        }
        const cuidRegex = /^c[^\s-]{8,}$/i;
        const cuid2Regex = /^[0-9a-z]+$/;
        const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
        const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
        const nanoidRegex = /^[a-z0-9_-]{21}$/i;
        const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
        const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
        const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
        const _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
        let emojiRegex;
        const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
        const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
        const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
        const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
        const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
        const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
        const dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
        const dateRegex = new RegExp(`^${dateRegexSource}$`);
        function timeRegexSource(args) {
            let regex = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
            if (args.precision) regex = `${regex}\\.\\d{${args.precision}}`;
            else if (null == args.precision) regex = `${regex}(\\.\\d+)?`;
            return regex;
        }
        function timeRegex(args) {
            return new RegExp(`^${timeRegexSource(args)}$`);
        }
        function datetimeRegex(args) {
            let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
            const opts = [];
            opts.push(args.local ? "Z?" : "Z");
            if (args.offset) opts.push("([+-]\\d{2}:?\\d{2})");
            regex = `${regex}(${opts.join("|")})`;
            return new RegExp(`^${regex}$`);
        }
        function isValidIP(ip, version) {
            if (("v4" === version || !version) && ipv4Regex.test(ip)) return true;
            if (("v6" === version || !version) && ipv6Regex.test(ip)) return true;
            return false;
        }
        function isValidJWT(jwt, alg) {
            if (!jwtRegex.test(jwt)) return false;
            try {
                const [header] = jwt.split(".");
                const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
                const decoded = JSON.parse(atob(base64));
                if ("object" != typeof decoded || null === decoded) return false;
                if (!decoded.typ || !decoded.alg) return false;
                if (alg && decoded.alg !== alg) return false;
                return true;
            } catch (_a) {
                return false;
            }
        }
        function isValidCidr(ip, version) {
            if (("v4" === version || !version) && ipv4CidrRegex.test(ip)) return true;
            if (("v6" === version || !version) && ipv6CidrRegex.test(ip)) return true;
            return false;
        }
        class ZodString extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = String(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.string) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.string,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                const status = new ParseStatus();
                let ctx;
                for (const check of this._def.checks)if ("min" === check.kind) {
                    if (input.data.length < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    if (input.data.length > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("length" === check.kind) {
                    const tooBig = input.data.length > check.value;
                    const tooSmall = input.data.length < check.value;
                    if (tooBig || tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        if (tooBig) addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                        else if (tooSmall) addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("email" === check.kind) {
                    if (!emailRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "email",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("emoji" === check.kind) {
                    if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
                    if (!emojiRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "emoji",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("uuid" === check.kind) {
                    if (!uuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "uuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("nanoid" === check.kind) {
                    if (!nanoidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "nanoid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cuid" === check.kind) {
                    if (!cuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cuid2" === check.kind) {
                    if (!cuid2Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid2",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("ulid" === check.kind) {
                    if (!ulidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ulid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("url" === check.kind) try {
                    new URL(input.data);
                } catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
                else if ("regex" === check.kind) {
                    check.regex.lastIndex = 0;
                    const testResult = check.regex.test(input.data);
                    if (!testResult) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "regex",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("trim" === check.kind) input.data = input.data.trim();
                else if ("includes" === check.kind) {
                    if (!input.data.includes(check.value, check.position)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                includes: check.value,
                                position: check.position
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("toLowerCase" === check.kind) input.data = input.data.toLowerCase();
                else if ("toUpperCase" === check.kind) input.data = input.data.toUpperCase();
                else if ("startsWith" === check.kind) {
                    if (!input.data.startsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                startsWith: check.value
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("endsWith" === check.kind) {
                    if (!input.data.endsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                endsWith: check.value
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("datetime" === check.kind) {
                    const regex = datetimeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "datetime",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("date" === check.kind) {
                    const regex = dateRegex;
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "date",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("time" === check.kind) {
                    const regex = timeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "time",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("duration" === check.kind) {
                    if (!durationRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "duration",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("ip" === check.kind) {
                    if (!isValidIP(input.data, check.version)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ip",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("jwt" === check.kind) {
                    if (!isValidJWT(input.data, check.alg)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "jwt",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cidr" === check.kind) {
                    if (!isValidCidr(input.data, check.version)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cidr",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("base64" === check.kind) {
                    if (!base64Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "base64",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("base64url" === check.kind) {
                    if (!base64urlRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "base64url",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            _regex(regex, validation, message) {
                return this.refinement((data)=>regex.test(data), {
                    validation,
                    code: ZodIssueCode.invalid_string,
                    ...errorUtil.errToObj(message)
                });
            }
            _addCheck(check) {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            email(message) {
                return this._addCheck({
                    kind: "email",
                    ...errorUtil.errToObj(message)
                });
            }
            url(message) {
                return this._addCheck({
                    kind: "url",
                    ...errorUtil.errToObj(message)
                });
            }
            emoji(message) {
                return this._addCheck({
                    kind: "emoji",
                    ...errorUtil.errToObj(message)
                });
            }
            uuid(message) {
                return this._addCheck({
                    kind: "uuid",
                    ...errorUtil.errToObj(message)
                });
            }
            nanoid(message) {
                return this._addCheck({
                    kind: "nanoid",
                    ...errorUtil.errToObj(message)
                });
            }
            cuid(message) {
                return this._addCheck({
                    kind: "cuid",
                    ...errorUtil.errToObj(message)
                });
            }
            cuid2(message) {
                return this._addCheck({
                    kind: "cuid2",
                    ...errorUtil.errToObj(message)
                });
            }
            ulid(message) {
                return this._addCheck({
                    kind: "ulid",
                    ...errorUtil.errToObj(message)
                });
            }
            base64(message) {
                return this._addCheck({
                    kind: "base64",
                    ...errorUtil.errToObj(message)
                });
            }
            base64url(message) {
                return this._addCheck({
                    kind: "base64url",
                    ...errorUtil.errToObj(message)
                });
            }
            jwt(options) {
                return this._addCheck({
                    kind: "jwt",
                    ...errorUtil.errToObj(options)
                });
            }
            ip(options) {
                return this._addCheck({
                    kind: "ip",
                    ...errorUtil.errToObj(options)
                });
            }
            cidr(options) {
                return this._addCheck({
                    kind: "cidr",
                    ...errorUtil.errToObj(options)
                });
            }
            datetime(options) {
                var _a, _b;
                if ("string" == typeof options) return this._addCheck({
                    kind: "datetime",
                    precision: null,
                    offset: false,
                    local: false,
                    message: options
                });
                return this._addCheck({
                    kind: "datetime",
                    precision: void 0 === (null == options ? void 0 : options.precision) ? null : null == options ? void 0 : options.precision,
                    offset: null !== (_a = null == options ? void 0 : options.offset) && void 0 !== _a ? _a : false,
                    local: null !== (_b = null == options ? void 0 : options.local) && void 0 !== _b ? _b : false,
                    ...errorUtil.errToObj(null == options ? void 0 : options.message)
                });
            }
            date(message) {
                return this._addCheck({
                    kind: "date",
                    message
                });
            }
            time(options) {
                if ("string" == typeof options) return this._addCheck({
                    kind: "time",
                    precision: null,
                    message: options
                });
                return this._addCheck({
                    kind: "time",
                    precision: void 0 === (null == options ? void 0 : options.precision) ? null : null == options ? void 0 : options.precision,
                    ...errorUtil.errToObj(null == options ? void 0 : options.message)
                });
            }
            duration(message) {
                return this._addCheck({
                    kind: "duration",
                    ...errorUtil.errToObj(message)
                });
            }
            regex(regex, message) {
                return this._addCheck({
                    kind: "regex",
                    regex: regex,
                    ...errorUtil.errToObj(message)
                });
            }
            includes(value, options) {
                return this._addCheck({
                    kind: "includes",
                    value: value,
                    position: null == options ? void 0 : options.position,
                    ...errorUtil.errToObj(null == options ? void 0 : options.message)
                });
            }
            startsWith(value, message) {
                return this._addCheck({
                    kind: "startsWith",
                    value: value,
                    ...errorUtil.errToObj(message)
                });
            }
            endsWith(value, message) {
                return this._addCheck({
                    kind: "endsWith",
                    value: value,
                    ...errorUtil.errToObj(message)
                });
            }
            min(minLength, message) {
                return this._addCheck({
                    kind: "min",
                    value: minLength,
                    ...errorUtil.errToObj(message)
                });
            }
            max(maxLength, message) {
                return this._addCheck({
                    kind: "max",
                    value: maxLength,
                    ...errorUtil.errToObj(message)
                });
            }
            length(len, message) {
                return this._addCheck({
                    kind: "length",
                    value: len,
                    ...errorUtil.errToObj(message)
                });
            }
            nonempty(message) {
                return this.min(1, errorUtil.errToObj(message));
            }
            trim() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "trim"
                        }
                    ]
                });
            }
            toLowerCase() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "toLowerCase"
                        }
                    ]
                });
            }
            toUpperCase() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "toUpperCase"
                        }
                    ]
                });
            }
            get isDatetime() {
                return !!this._def.checks.find((ch)=>"datetime" === ch.kind);
            }
            get isDate() {
                return !!this._def.checks.find((ch)=>"date" === ch.kind);
            }
            get isTime() {
                return !!this._def.checks.find((ch)=>"time" === ch.kind);
            }
            get isDuration() {
                return !!this._def.checks.find((ch)=>"duration" === ch.kind);
            }
            get isEmail() {
                return !!this._def.checks.find((ch)=>"email" === ch.kind);
            }
            get isURL() {
                return !!this._def.checks.find((ch)=>"url" === ch.kind);
            }
            get isEmoji() {
                return !!this._def.checks.find((ch)=>"emoji" === ch.kind);
            }
            get isUUID() {
                return !!this._def.checks.find((ch)=>"uuid" === ch.kind);
            }
            get isNANOID() {
                return !!this._def.checks.find((ch)=>"nanoid" === ch.kind);
            }
            get isCUID() {
                return !!this._def.checks.find((ch)=>"cuid" === ch.kind);
            }
            get isCUID2() {
                return !!this._def.checks.find((ch)=>"cuid2" === ch.kind);
            }
            get isULID() {
                return !!this._def.checks.find((ch)=>"ulid" === ch.kind);
            }
            get isIP() {
                return !!this._def.checks.find((ch)=>"ip" === ch.kind);
            }
            get isCIDR() {
                return !!this._def.checks.find((ch)=>"cidr" === ch.kind);
            }
            get isBase64() {
                return !!this._def.checks.find((ch)=>"base64" === ch.kind);
            }
            get isBase64url() {
                return !!this._def.checks.find((ch)=>"base64url" === ch.kind);
            }
            get minLength() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxLength() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
        }
        ZodString.create = (params)=>{
            var _a;
            return new ZodString({
                checks: [],
                typeName: ZodFirstPartyTypeKind.ZodString,
                coerce: null !== (_a = null == params ? void 0 : params.coerce) && void 0 !== _a ? _a : false,
                ...processCreateParams(params)
            });
        };
        function floatSafeRemainder(val, step) {
            const valDecCount = (val.toString().split(".")[1] || "").length;
            const stepDecCount = (step.toString().split(".")[1] || "").length;
            const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
            const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
            const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
            return valInt % stepInt / Math.pow(10, decCount);
        }
        class ZodNumber extends ZodType {
            constructor(){
                super(...arguments);
                this.min = this.gte;
                this.max = this.lte;
                this.step = this.multipleOf;
            }
            _parse(input) {
                if (this._def.coerce) input.data = Number(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.number) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.number,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                let ctx;
                const status = new ParseStatus();
                for (const check of this._def.checks)if ("int" === check.kind) {
                    if (!util.isInteger(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_type,
                            expected: "integer",
                            received: "float",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("min" === check.kind) {
                    const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("multipleOf" === check.kind) {
                    if (0 !== floatSafeRemainder(input.data, check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("finite" === check.kind) {
                    if (!Number.isFinite(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_finite,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            gte(value, message) {
                return this.setLimit("min", value, true, errorUtil.toString(message));
            }
            gt(value, message) {
                return this.setLimit("min", value, false, errorUtil.toString(message));
            }
            lte(value, message) {
                return this.setLimit("max", value, true, errorUtil.toString(message));
            }
            lt(value, message) {
                return this.setLimit("max", value, false, errorUtil.toString(message));
            }
            setLimit(kind, value, inclusive, message) {
                return new ZodNumber({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind,
                            value,
                            inclusive,
                            message: errorUtil.toString(message)
                        }
                    ]
                });
            }
            _addCheck(check) {
                return new ZodNumber({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            int(message) {
                return this._addCheck({
                    kind: "int",
                    message: errorUtil.toString(message)
                });
            }
            positive(message) {
                return this._addCheck({
                    kind: "min",
                    value: 0,
                    inclusive: false,
                    message: errorUtil.toString(message)
                });
            }
            negative(message) {
                return this._addCheck({
                    kind: "max",
                    value: 0,
                    inclusive: false,
                    message: errorUtil.toString(message)
                });
            }
            nonpositive(message) {
                return this._addCheck({
                    kind: "max",
                    value: 0,
                    inclusive: true,
                    message: errorUtil.toString(message)
                });
            }
            nonnegative(message) {
                return this._addCheck({
                    kind: "min",
                    value: 0,
                    inclusive: true,
                    message: errorUtil.toString(message)
                });
            }
            multipleOf(value, message) {
                return this._addCheck({
                    kind: "multipleOf",
                    value: value,
                    message: errorUtil.toString(message)
                });
            }
            finite(message) {
                return this._addCheck({
                    kind: "finite",
                    message: errorUtil.toString(message)
                });
            }
            safe(message) {
                return this._addCheck({
                    kind: "min",
                    inclusive: true,
                    value: Number.MIN_SAFE_INTEGER,
                    message: errorUtil.toString(message)
                })._addCheck({
                    kind: "max",
                    inclusive: true,
                    value: Number.MAX_SAFE_INTEGER,
                    message: errorUtil.toString(message)
                });
            }
            get minValue() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxValue() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
            get isInt() {
                return !!this._def.checks.find((ch)=>"int" === ch.kind || "multipleOf" === ch.kind && util.isInteger(ch.value));
            }
            get isFinite() {
                let max = null, min = null;
                for (const ch of this._def.checks){
                    if ("finite" === ch.kind || "int" === ch.kind || "multipleOf" === ch.kind) return true;
                    if ("min" === ch.kind) {
                        if (null === min || ch.value > min) min = ch.value;
                    } else if ("max" === ch.kind) {
                        if (null === max || ch.value < max) max = ch.value;
                    }
                }
                return Number.isFinite(min) && Number.isFinite(max);
            }
        }
        ZodNumber.create = (params)=>new ZodNumber({
                checks: [],
                typeName: ZodFirstPartyTypeKind.ZodNumber,
                coerce: (null == params ? void 0 : params.coerce) || false,
                ...processCreateParams(params)
            });
        class ZodBigInt extends ZodType {
            constructor(){
                super(...arguments);
                this.min = this.gte;
                this.max = this.lte;
            }
            _parse(input) {
                if (this._def.coerce) try {
                    input.data = BigInt(input.data);
                } catch (_a) {
                    return this._getInvalidInput(input);
                }
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.bigint) return this._getInvalidInput(input);
                let ctx;
                const status = new ParseStatus();
                for (const check of this._def.checks)if ("min" === check.kind) {
                    const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            type: "bigint",
                            minimum: check.value,
                            inclusive: check.inclusive,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            type: "bigint",
                            maximum: check.value,
                            inclusive: check.inclusive,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("multipleOf" === check.kind) {
                    if (input.data % check.value !== BigInt(0)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            _getInvalidInput(input) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.bigint,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            gte(value, message) {
                return this.setLimit("min", value, true, errorUtil.toString(message));
            }
            gt(value, message) {
                return this.setLimit("min", value, false, errorUtil.toString(message));
            }
            lte(value, message) {
                return this.setLimit("max", value, true, errorUtil.toString(message));
            }
            lt(value, message) {
                return this.setLimit("max", value, false, errorUtil.toString(message));
            }
            setLimit(kind, value, inclusive, message) {
                return new ZodBigInt({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind,
                            value,
                            inclusive,
                            message: errorUtil.toString(message)
                        }
                    ]
                });
            }
            _addCheck(check) {
                return new ZodBigInt({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            positive(message) {
                return this._addCheck({
                    kind: "min",
                    value: BigInt(0),
                    inclusive: false,
                    message: errorUtil.toString(message)
                });
            }
            negative(message) {
                return this._addCheck({
                    kind: "max",
                    value: BigInt(0),
                    inclusive: false,
                    message: errorUtil.toString(message)
                });
            }
            nonpositive(message) {
                return this._addCheck({
                    kind: "max",
                    value: BigInt(0),
                    inclusive: true,
                    message: errorUtil.toString(message)
                });
            }
            nonnegative(message) {
                return this._addCheck({
                    kind: "min",
                    value: BigInt(0),
                    inclusive: true,
                    message: errorUtil.toString(message)
                });
            }
            multipleOf(value, message) {
                return this._addCheck({
                    kind: "multipleOf",
                    value,
                    message: errorUtil.toString(message)
                });
            }
            get minValue() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxValue() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
        }
        ZodBigInt.create = (params)=>{
            var _a;
            return new ZodBigInt({
                checks: [],
                typeName: ZodFirstPartyTypeKind.ZodBigInt,
                coerce: null !== (_a = null == params ? void 0 : params.coerce) && void 0 !== _a ? _a : false,
                ...processCreateParams(params)
            });
        };
        class ZodBoolean extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = Boolean(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.boolean) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.boolean,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                return OK(input.data);
            }
        }
        ZodBoolean.create = (params)=>new ZodBoolean({
                typeName: ZodFirstPartyTypeKind.ZodBoolean,
                coerce: (null == params ? void 0 : params.coerce) || false,
                ...processCreateParams(params)
            });
        class ZodDate extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = new Date(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.date) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.date,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                if (isNaN(input.data.getTime())) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_date
                    });
                    return INVALID;
                }
                const status = new ParseStatus();
                let ctx;
                for (const check of this._def.checks)if ("min" === check.kind) {
                    if (input.data.getTime() < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            minimum: check.value,
                            type: "date"
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    if (input.data.getTime() > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            maximum: check.value,
                            type: "date"
                        });
                        status.dirty();
                    }
                } else util.assertNever(check);
                return {
                    status: status.value,
                    value: new Date(input.data.getTime())
                };
            }
            _addCheck(check) {
                return new ZodDate({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            min(minDate, message) {
                return this._addCheck({
                    kind: "min",
                    value: minDate.getTime(),
                    message: errorUtil.toString(message)
                });
            }
            max(maxDate, message) {
                return this._addCheck({
                    kind: "max",
                    value: maxDate.getTime(),
                    message: errorUtil.toString(message)
                });
            }
            get minDate() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return null != min ? new Date(min) : null;
            }
            get maxDate() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return null != max ? new Date(max) : null;
            }
        }
        ZodDate.create = (params)=>new ZodDate({
                checks: [],
                coerce: (null == params ? void 0 : params.coerce) || false,
                typeName: ZodFirstPartyTypeKind.ZodDate,
                ...processCreateParams(params)
            });
        class ZodSymbol extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.symbol) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.symbol,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                return OK(input.data);
            }
        }
        ZodSymbol.create = (params)=>new ZodSymbol({
                typeName: ZodFirstPartyTypeKind.ZodSymbol,
                ...processCreateParams(params)
            });
        class ZodUndefined extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.undefined) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.undefined,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                return OK(input.data);
            }
        }
        ZodUndefined.create = (params)=>new ZodUndefined({
                typeName: ZodFirstPartyTypeKind.ZodUndefined,
                ...processCreateParams(params)
            });
        class ZodNull extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.null) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.null,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                return OK(input.data);
            }
        }
        ZodNull.create = (params)=>new ZodNull({
                typeName: ZodFirstPartyTypeKind.ZodNull,
                ...processCreateParams(params)
            });
        class ZodAny extends ZodType {
            constructor(){
                super(...arguments);
                this._any = true;
            }
            _parse(input) {
                return OK(input.data);
            }
        }
        ZodAny.create = (params)=>new ZodAny({
                typeName: ZodFirstPartyTypeKind.ZodAny,
                ...processCreateParams(params)
            });
        class ZodUnknown extends ZodType {
            constructor(){
                super(...arguments);
                this._unknown = true;
            }
            _parse(input) {
                return OK(input.data);
            }
        }
        ZodUnknown.create = (params)=>new ZodUnknown({
                typeName: ZodFirstPartyTypeKind.ZodUnknown,
                ...processCreateParams(params)
            });
        class ZodNever extends ZodType {
            _parse(input) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.never,
                    received: ctx.parsedType
                });
                return INVALID;
            }
        }
        ZodNever.create = (params)=>new ZodNever({
                typeName: ZodFirstPartyTypeKind.ZodNever,
                ...processCreateParams(params)
            });
        class ZodVoid extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.undefined) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.void,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                return OK(input.data);
            }
        }
        ZodVoid.create = (params)=>new ZodVoid({
                typeName: ZodFirstPartyTypeKind.ZodVoid,
                ...processCreateParams(params)
            });
        class ZodArray extends ZodType {
            _parse(input) {
                const { ctx, status } = this._processInputParams(input);
                const def = this._def;
                if (ctx.parsedType !== ZodParsedType.array) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.array,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                if (null !== def.exactLength) {
                    const tooBig = ctx.data.length > def.exactLength.value;
                    const tooSmall = ctx.data.length < def.exactLength.value;
                    if (tooBig || tooSmall) {
                        addIssueToContext(ctx, {
                            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                            minimum: tooSmall ? def.exactLength.value : void 0,
                            maximum: tooBig ? def.exactLength.value : void 0,
                            type: "array",
                            inclusive: true,
                            exact: true,
                            message: def.exactLength.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.minLength) {
                    if (ctx.data.length < def.minLength.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: def.minLength.value,
                            type: "array",
                            inclusive: true,
                            exact: false,
                            message: def.minLength.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.maxLength) {
                    if (ctx.data.length > def.maxLength.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: def.maxLength.value,
                            type: "array",
                            inclusive: true,
                            exact: false,
                            message: def.maxLength.message
                        });
                        status.dirty();
                    }
                }
                if (ctx.common.async) return Promise.all([
                    ...ctx.data
                ].map((item, i)=>def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result)=>ParseStatus.mergeArray(status, result));
                const result = [
                    ...ctx.data
                ].map((item, i)=>def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
                return ParseStatus.mergeArray(status, result);
            }
            get element() {
                return this._def.type;
            }
            min(minLength, message) {
                return new ZodArray({
                    ...this._def,
                    minLength: {
                        value: minLength,
                        message: errorUtil.toString(message)
                    }
                });
            }
            max(maxLength, message) {
                return new ZodArray({
                    ...this._def,
                    maxLength: {
                        value: maxLength,
                        message: errorUtil.toString(message)
                    }
                });
            }
            length(len, message) {
                return new ZodArray({
                    ...this._def,
                    exactLength: {
                        value: len,
                        message: errorUtil.toString(message)
                    }
                });
            }
            nonempty(message) {
                return this.min(1, message);
            }
        }
        ZodArray.create = (schema, params)=>new ZodArray({
                type: schema,
                minLength: null,
                maxLength: null,
                exactLength: null,
                typeName: ZodFirstPartyTypeKind.ZodArray,
                ...processCreateParams(params)
            });
        function deepPartialify(schema) {
            if (schema instanceof ZodObject) {
                const newShape = {};
                for(const key in schema.shape){
                    const fieldSchema = schema.shape[key];
                    newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
                }
                return new ZodObject({
                    ...schema._def,
                    shape: ()=>newShape
                });
            }
            if (schema instanceof ZodArray) return new ZodArray({
                ...schema._def,
                type: deepPartialify(schema.element)
            });
            if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
            if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
            if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
            else return schema;
        }
        class ZodObject extends ZodType {
            constructor(){
                super(...arguments);
                this._cached = null;
                this.nonstrict = this.passthrough;
                this.augment = this.extend;
            }
            _getCached() {
                if (null !== this._cached) return this._cached;
                const shape = this._def.shape();
                const keys = util.objectKeys(shape);
                return this._cached = {
                    shape,
                    keys
                };
            }
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.object) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                const { status, ctx } = this._processInputParams(input);
                const { shape, keys: shapeKeys } = this._getCached();
                const extraKeys = [];
                if (!(this._def.catchall instanceof ZodNever && "strip" === this._def.unknownKeys)) {
                    for(const key in ctx.data)if (!shapeKeys.includes(key)) extraKeys.push(key);
                }
                const pairs = [];
                for (const key of shapeKeys){
                    const keyValidator = shape[key];
                    const value = ctx.data[key];
                    pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                        alwaysSet: key in ctx.data
                    });
                }
                if (this._def.catchall instanceof ZodNever) {
                    const unknownKeys = this._def.unknownKeys;
                    if ("passthrough" === unknownKeys) for (const key of extraKeys)pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: {
                            status: "valid",
                            value: ctx.data[key]
                        }
                    });
                    else if ("strict" === unknownKeys) {
                        if (extraKeys.length > 0) {
                            addIssueToContext(ctx, {
                                code: ZodIssueCode.unrecognized_keys,
                                keys: extraKeys
                            });
                            status.dirty();
                        }
                    } else if ("strip" === unknownKeys) ;
                    else throw new Error("Internal ZodObject error: invalid unknownKeys value.");
                } else {
                    const catchall = this._def.catchall;
                    for (const key of extraKeys){
                        const value = ctx.data[key];
                        pairs.push({
                            key: {
                                status: "valid",
                                value: key
                            },
                            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                            alwaysSet: key in ctx.data
                        });
                    }
                }
                if (ctx.common.async) return Promise.resolve().then(async ()=>{
                    const syncPairs = [];
                    for (const pair of pairs){
                        const key = await pair.key;
                        const value = await pair.value;
                        syncPairs.push({
                            key,
                            value,
                            alwaysSet: pair.alwaysSet
                        });
                    }
                    return syncPairs;
                }).then((syncPairs)=>ParseStatus.mergeObjectSync(status, syncPairs));
                return ParseStatus.mergeObjectSync(status, pairs);
            }
            get shape() {
                return this._def.shape();
            }
            strict(message) {
                errorUtil.errToObj;
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "strict",
                    ...void 0 !== message ? {
                        errorMap: (issue, ctx)=>{
                            var _a, _b, _c, _d;
                            const defaultError = null !== (_c = null === (_b = (_a = this._def).errorMap) || void 0 === _b ? void 0 : _b.call(_a, issue, ctx).message) && void 0 !== _c ? _c : ctx.defaultError;
                            if ("unrecognized_keys" === issue.code) return {
                                message: null !== (_d = errorUtil.errToObj(message).message) && void 0 !== _d ? _d : defaultError
                            };
                            return {
                                message: defaultError
                            };
                        }
                    } : {}
                });
            }
            strip() {
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "strip"
                });
            }
            passthrough() {
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "passthrough"
                });
            }
            extend(augmentation) {
                return new ZodObject({
                    ...this._def,
                    shape: ()=>({
                            ...this._def.shape(),
                            ...augmentation
                        })
                });
            }
            merge(merging) {
                const merged = new ZodObject({
                    unknownKeys: merging._def.unknownKeys,
                    catchall: merging._def.catchall,
                    shape: ()=>({
                            ...this._def.shape(),
                            ...merging._def.shape()
                        }),
                    typeName: ZodFirstPartyTypeKind.ZodObject
                });
                return merged;
            }
            setKey(key, schema) {
                return this.augment({
                    [key]: schema
                });
            }
            catchall(index) {
                return new ZodObject({
                    ...this._def,
                    catchall: index
                });
            }
            pick(mask) {
                const shape = {};
                util.objectKeys(mask).forEach((key)=>{
                    if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
                });
                return new ZodObject({
                    ...this._def,
                    shape: ()=>shape
                });
            }
            omit(mask) {
                const shape = {};
                util.objectKeys(this.shape).forEach((key)=>{
                    if (!mask[key]) shape[key] = this.shape[key];
                });
                return new ZodObject({
                    ...this._def,
                    shape: ()=>shape
                });
            }
            deepPartial() {
                return deepPartialify(this);
            }
            partial(mask) {
                const newShape = {};
                util.objectKeys(this.shape).forEach((key)=>{
                    const fieldSchema = this.shape[key];
                    if (mask && !mask[key]) newShape[key] = fieldSchema;
                    else newShape[key] = fieldSchema.optional();
                });
                return new ZodObject({
                    ...this._def,
                    shape: ()=>newShape
                });
            }
            required(mask) {
                const newShape = {};
                util.objectKeys(this.shape).forEach((key)=>{
                    if (mask && !mask[key]) newShape[key] = this.shape[key];
                    else {
                        const fieldSchema = this.shape[key];
                        let newField = fieldSchema;
                        while(newField instanceof ZodOptional)newField = newField._def.innerType;
                        newShape[key] = newField;
                    }
                });
                return new ZodObject({
                    ...this._def,
                    shape: ()=>newShape
                });
            }
            keyof() {
                return createZodEnum(util.objectKeys(this.shape));
            }
        }
        ZodObject.create = (shape, params)=>new ZodObject({
                shape: ()=>shape,
                unknownKeys: "strip",
                catchall: ZodNever.create(),
                typeName: ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        ZodObject.strictCreate = (shape, params)=>new ZodObject({
                shape: ()=>shape,
                unknownKeys: "strict",
                catchall: ZodNever.create(),
                typeName: ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        ZodObject.lazycreate = (shape, params)=>new ZodObject({
                shape,
                unknownKeys: "strip",
                catchall: ZodNever.create(),
                typeName: ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        class ZodUnion extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const options = this._def.options;
                function handleResults(results) {
                    for (const result of results)if ("valid" === result.result.status) return result.result;
                    for (const result of results)if ("dirty" === result.result.status) {
                        ctx.common.issues.push(...result.ctx.common.issues);
                        return result.result;
                    }
                    const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union,
                        unionErrors
                    });
                    return INVALID;
                }
                if (ctx.common.async) return Promise.all(options.map(async (option)=>{
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await option._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx
                        }),
                        ctx: childCtx
                    };
                })).then(handleResults);
                {
                    let dirty;
                    const issues = [];
                    for (const option of options){
                        const childCtx = {
                            ...ctx,
                            common: {
                                ...ctx.common,
                                issues: []
                            },
                            parent: null
                        };
                        const result = option._parseSync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx
                        });
                        if ("valid" === result.status) return result;
                        if ("dirty" === result.status && !dirty) dirty = {
                            result,
                            ctx: childCtx
                        };
                        if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
                    }
                    if (dirty) {
                        ctx.common.issues.push(...dirty.ctx.common.issues);
                        return dirty.result;
                    }
                    const unionErrors = issues.map((issues)=>new ZodError(issues));
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union,
                        unionErrors
                    });
                    return INVALID;
                }
            }
            get options() {
                return this._def.options;
            }
        }
        ZodUnion.create = (types, params)=>new ZodUnion({
                options: types,
                typeName: ZodFirstPartyTypeKind.ZodUnion,
                ...processCreateParams(params)
            });
        const getDiscriminator = (type)=>{
            if (type instanceof ZodLazy) return getDiscriminator(type.schema);
            if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
            if (type instanceof ZodLiteral) return [
                type.value
            ];
            if (type instanceof ZodEnum) return type.options;
            if (type instanceof ZodNativeEnum) return util.objectValues(type.enum);
            else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
            else if (type instanceof ZodUndefined) return [
                void 0
            ];
            else if (type instanceof ZodNull) return [
                null
            ];
            else if (type instanceof ZodOptional) return [
                void 0,
                ...getDiscriminator(type.unwrap())
            ];
            else if (type instanceof ZodNullable) return [
                null,
                ...getDiscriminator(type.unwrap())
            ];
            else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
            else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
            else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
            else return [];
        };
        class ZodDiscriminatedUnion extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.object) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                const discriminator = this.discriminator;
                const discriminatorValue = ctx.data[discriminator];
                const option = this.optionsMap.get(discriminatorValue);
                if (!option) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union_discriminator,
                        options: Array.from(this.optionsMap.keys()),
                        path: [
                            discriminator
                        ]
                    });
                    return INVALID;
                }
                if (ctx.common.async) return option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                return option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            get discriminator() {
                return this._def.discriminator;
            }
            get options() {
                return this._def.options;
            }
            get optionsMap() {
                return this._def.optionsMap;
            }
            static create(discriminator, options, params) {
                const optionsMap = new Map();
                for (const type of options){
                    const discriminatorValues = getDiscriminator(type.shape[discriminator]);
                    if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
                    for (const value of discriminatorValues){
                        if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                        optionsMap.set(value, type);
                    }
                }
                return new ZodDiscriminatedUnion({
                    typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
                    discriminator,
                    options,
                    optionsMap,
                    ...processCreateParams(params)
                });
            }
        }
        function mergeValues(a, b) {
            const aType = getParsedType(a);
            const bType = getParsedType(b);
            if (a === b) return {
                valid: true,
                data: a
            };
            if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
                const bKeys = util.objectKeys(b);
                const sharedKeys = util.objectKeys(a).filter((key)=>-1 !== bKeys.indexOf(key));
                const newObj = {
                    ...a,
                    ...b
                };
                for (const key of sharedKeys){
                    const sharedValue = mergeValues(a[key], b[key]);
                    if (!sharedValue.valid) return {
                        valid: false
                    };
                    newObj[key] = sharedValue.data;
                }
                return {
                    valid: true,
                    data: newObj
                };
            }
            if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
                if (a.length !== b.length) return {
                    valid: false
                };
                const newArray = [];
                for(let index = 0; index < a.length; index++){
                    const itemA = a[index];
                    const itemB = b[index];
                    const sharedValue = mergeValues(itemA, itemB);
                    if (!sharedValue.valid) return {
                        valid: false
                    };
                    newArray.push(sharedValue.data);
                }
                return {
                    valid: true,
                    data: newArray
                };
            }
            if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) return {
                valid: true,
                data: a
            };
            return {
                valid: false
            };
        }
        class ZodIntersection extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                const handleParsed = (parsedLeft, parsedRight)=>{
                    if (isAborted(parsedLeft) || isAborted(parsedRight)) return INVALID;
                    const merged = mergeValues(parsedLeft.value, parsedRight.value);
                    if (!merged.valid) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_intersection_types
                        });
                        return INVALID;
                    }
                    if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
                    return {
                        status: status.value,
                        value: merged.data
                    };
                };
                if (ctx.common.async) return Promise.all([
                    this._def.left._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }),
                    this._def.right._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    })
                ]).then(([left, right])=>handleParsed(left, right));
                return handleParsed(this._def.left._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }), this._def.right._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }));
            }
        }
        ZodIntersection.create = (left, right, params)=>new ZodIntersection({
                left: left,
                right: right,
                typeName: ZodFirstPartyTypeKind.ZodIntersection,
                ...processCreateParams(params)
            });
        class ZodTuple extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.array) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.array,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                if (ctx.data.length < this._def.items.length) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: this._def.items.length,
                        inclusive: true,
                        exact: false,
                        type: "array"
                    });
                    return INVALID;
                }
                const rest = this._def.rest;
                if (!rest && ctx.data.length > this._def.items.length) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: this._def.items.length,
                        inclusive: true,
                        exact: false,
                        type: "array"
                    });
                    status.dirty();
                }
                const items = [
                    ...ctx.data
                ].map((item, itemIndex)=>{
                    const schema = this._def.items[itemIndex] || this._def.rest;
                    if (!schema) return null;
                    return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
                }).filter((x)=>!!x);
                if (ctx.common.async) return Promise.all(items).then((results)=>ParseStatus.mergeArray(status, results));
                return ParseStatus.mergeArray(status, items);
            }
            get items() {
                return this._def.items;
            }
            rest(rest) {
                return new ZodTuple({
                    ...this._def,
                    rest
                });
            }
        }
        ZodTuple.create = (schemas, params)=>{
            if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
            return new ZodTuple({
                items: schemas,
                typeName: ZodFirstPartyTypeKind.ZodTuple,
                rest: null,
                ...processCreateParams(params)
            });
        };
        class ZodRecord extends ZodType {
            get keySchema() {
                return this._def.keyType;
            }
            get valueSchema() {
                return this._def.valueType;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.object) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                const pairs = [];
                const keyType = this._def.keyType;
                const valueType = this._def.valueType;
                for(const key in ctx.data)pairs.push({
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                    value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                    alwaysSet: key in ctx.data
                });
                if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
                return ParseStatus.mergeObjectSync(status, pairs);
            }
            get element() {
                return this._def.valueType;
            }
            static create(first, second, third) {
                if (second instanceof ZodType) return new ZodRecord({
                    keyType: first,
                    valueType: second,
                    typeName: ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(third)
                });
                return new ZodRecord({
                    keyType: ZodString.create(),
                    valueType: first,
                    typeName: ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(second)
                });
            }
        }
        class ZodMap extends ZodType {
            get keySchema() {
                return this._def.keyType;
            }
            get valueSchema() {
                return this._def.valueType;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.map) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.map,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                const keyType = this._def.keyType;
                const valueType = this._def.valueType;
                const pairs = [
                    ...ctx.data.entries()
                ].map(([key, value], index)=>({
                        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                            index,
                            "key"
                        ])),
                        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                            index,
                            "value"
                        ]))
                    }));
                if (ctx.common.async) {
                    const finalMap = new Map();
                    return Promise.resolve().then(async ()=>{
                        for (const pair of pairs){
                            const key = await pair.key;
                            const value = await pair.value;
                            if ("aborted" === key.status || "aborted" === value.status) return INVALID;
                            if ("dirty" === key.status || "dirty" === value.status) status.dirty();
                            finalMap.set(key.value, value.value);
                        }
                        return {
                            status: status.value,
                            value: finalMap
                        };
                    });
                }
                {
                    const finalMap = new Map();
                    for (const pair of pairs){
                        const key = pair.key;
                        const value = pair.value;
                        if ("aborted" === key.status || "aborted" === value.status) return INVALID;
                        if ("dirty" === key.status || "dirty" === value.status) status.dirty();
                        finalMap.set(key.value, value.value);
                    }
                    return {
                        status: status.value,
                        value: finalMap
                    };
                }
            }
        }
        ZodMap.create = (keyType, valueType, params)=>new ZodMap({
                valueType,
                keyType,
                typeName: ZodFirstPartyTypeKind.ZodMap,
                ...processCreateParams(params)
            });
        class ZodSet extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.set) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.set,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                const def = this._def;
                if (null !== def.minSize) {
                    if (ctx.data.size < def.minSize.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: def.minSize.value,
                            type: "set",
                            inclusive: true,
                            exact: false,
                            message: def.minSize.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.maxSize) {
                    if (ctx.data.size > def.maxSize.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: def.maxSize.value,
                            type: "set",
                            inclusive: true,
                            exact: false,
                            message: def.maxSize.message
                        });
                        status.dirty();
                    }
                }
                const valueType = this._def.valueType;
                function finalizeSet(elements) {
                    const parsedSet = new Set();
                    for (const element of elements){
                        if ("aborted" === element.status) return INVALID;
                        if ("dirty" === element.status) status.dirty();
                        parsedSet.add(element.value);
                    }
                    return {
                        status: status.value,
                        value: parsedSet
                    };
                }
                const elements = [
                    ...ctx.data.values()
                ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
                if (ctx.common.async) return Promise.all(elements).then((elements)=>finalizeSet(elements));
                return finalizeSet(elements);
            }
            min(minSize, message) {
                return new ZodSet({
                    ...this._def,
                    minSize: {
                        value: minSize,
                        message: errorUtil.toString(message)
                    }
                });
            }
            max(maxSize, message) {
                return new ZodSet({
                    ...this._def,
                    maxSize: {
                        value: maxSize,
                        message: errorUtil.toString(message)
                    }
                });
            }
            size(size, message) {
                return this.min(size, message).max(size, message);
            }
            nonempty(message) {
                return this.min(1, message);
            }
        }
        ZodSet.create = (valueType, params)=>new ZodSet({
                valueType,
                minSize: null,
                maxSize: null,
                typeName: ZodFirstPartyTypeKind.ZodSet,
                ...processCreateParams(params)
            });
        class ZodFunction extends ZodType {
            constructor(){
                super(...arguments);
                this.validate = this.implement;
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.function) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.function,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                function makeArgsIssue(args, error) {
                    return makeIssue({
                        data: args,
                        path: ctx.path,
                        errorMaps: [
                            ctx.common.contextualErrorMap,
                            ctx.schemaErrorMap,
                            getErrorMap(),
                            errorMap
                        ].filter((x)=>!!x),
                        issueData: {
                            code: ZodIssueCode.invalid_arguments,
                            argumentsError: error
                        }
                    });
                }
                function makeReturnsIssue(returns, error) {
                    return makeIssue({
                        data: returns,
                        path: ctx.path,
                        errorMaps: [
                            ctx.common.contextualErrorMap,
                            ctx.schemaErrorMap,
                            getErrorMap(),
                            errorMap
                        ].filter((x)=>!!x),
                        issueData: {
                            code: ZodIssueCode.invalid_return_type,
                            returnTypeError: error
                        }
                    });
                }
                const params = {
                    errorMap: ctx.common.contextualErrorMap
                };
                const fn = ctx.data;
                if (this._def.returns instanceof ZodPromise) {
                    const me = this;
                    return OK(async function(...args) {
                        const error = new ZodError([]);
                        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                            error.addIssue(makeArgsIssue(args, e));
                            throw error;
                        });
                        const result = await Reflect.apply(fn, this, parsedArgs);
                        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                            error.addIssue(makeReturnsIssue(result, e));
                            throw error;
                        });
                        return parsedReturns;
                    });
                }
                {
                    const me = this;
                    return OK(function(...args) {
                        const parsedArgs = me._def.args.safeParse(args, params);
                        if (!parsedArgs.success) throw new ZodError([
                            makeArgsIssue(args, parsedArgs.error)
                        ]);
                        const result = Reflect.apply(fn, this, parsedArgs.data);
                        const parsedReturns = me._def.returns.safeParse(result, params);
                        if (!parsedReturns.success) throw new ZodError([
                            makeReturnsIssue(result, parsedReturns.error)
                        ]);
                        return parsedReturns.data;
                    });
                }
            }
            parameters() {
                return this._def.args;
            }
            returnType() {
                return this._def.returns;
            }
            args(...items) {
                return new ZodFunction({
                    ...this._def,
                    args: ZodTuple.create(items).rest(ZodUnknown.create())
                });
            }
            returns(returnType) {
                return new ZodFunction({
                    ...this._def,
                    returns: returnType
                });
            }
            implement(func) {
                const validatedFunc = this.parse(func);
                return validatedFunc;
            }
            strictImplement(func) {
                const validatedFunc = this.parse(func);
                return validatedFunc;
            }
            static create(args, returns, params) {
                return new ZodFunction({
                    args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
                    returns: returns || ZodUnknown.create(),
                    typeName: ZodFirstPartyTypeKind.ZodFunction,
                    ...processCreateParams(params)
                });
            }
        }
        class ZodLazy extends ZodType {
            get schema() {
                return this._def.getter();
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const lazySchema = this._def.getter();
                return lazySchema._parse({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
            }
        }
        ZodLazy.create = (getter, params)=>new ZodLazy({
                getter: getter,
                typeName: ZodFirstPartyTypeKind.ZodLazy,
                ...processCreateParams(params)
            });
        class ZodLiteral extends ZodType {
            _parse(input) {
                if (input.data !== this._def.value) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_literal,
                        expected: this._def.value
                    });
                    return INVALID;
                }
                return {
                    status: "valid",
                    value: input.data
                };
            }
            get value() {
                return this._def.value;
            }
        }
        ZodLiteral.create = (value, params)=>new ZodLiteral({
                value: value,
                typeName: ZodFirstPartyTypeKind.ZodLiteral,
                ...processCreateParams(params)
            });
        function createZodEnum(values, params) {
            return new ZodEnum({
                values,
                typeName: ZodFirstPartyTypeKind.ZodEnum,
                ...processCreateParams(params)
            });
        }
        class ZodEnum extends ZodType {
            constructor(){
                super(...arguments);
                _ZodEnum_cache.set(this, void 0);
            }
            _parse(input) {
                if ("string" != typeof input.data) {
                    const ctx = this._getOrReturnCtx(input);
                    const expectedValues = this._def.values;
                    addIssueToContext(ctx, {
                        expected: util.joinValues(expectedValues),
                        received: ctx.parsedType,
                        code: ZodIssueCode.invalid_type
                    });
                    return INVALID;
                }
                if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
                if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
                    const ctx = this._getOrReturnCtx(input);
                    const expectedValues = this._def.values;
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_enum_value,
                        options: expectedValues
                    });
                    return INVALID;
                }
                return OK(input.data);
            }
            get options() {
                return this._def.values;
            }
            get enum() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            get Values() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            get Enum() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            extract(values, newDef = this._def) {
                return ZodEnum.create(values, {
                    ...this._def,
                    ...newDef
                });
            }
            exclude(values, newDef = this._def) {
                return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
                    ...this._def,
                    ...newDef
                });
            }
        }
        _ZodEnum_cache = new WeakMap();
        ZodEnum.create = createZodEnum;
        class ZodNativeEnum extends ZodType {
            constructor(){
                super(...arguments);
                _ZodNativeEnum_cache.set(this, void 0);
            }
            _parse(input) {
                const nativeEnumValues = util.getValidEnumValues(this._def.values);
                const ctx = this._getOrReturnCtx(input);
                if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
                    const expectedValues = util.objectValues(nativeEnumValues);
                    addIssueToContext(ctx, {
                        expected: util.joinValues(expectedValues),
                        received: ctx.parsedType,
                        code: ZodIssueCode.invalid_type
                    });
                    return INVALID;
                }
                if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
                if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
                    const expectedValues = util.objectValues(nativeEnumValues);
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_enum_value,
                        options: expectedValues
                    });
                    return INVALID;
                }
                return OK(input.data);
            }
            get enum() {
                return this._def.values;
            }
        }
        _ZodNativeEnum_cache = new WeakMap();
        ZodNativeEnum.create = (values, params)=>new ZodNativeEnum({
                values: values,
                typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
                ...processCreateParams(params)
            });
        class ZodPromise extends ZodType {
            unwrap() {
                return this._def.type;
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.promise && false === ctx.common.async) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.promise,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
                return OK(promisified.then((data)=>this._def.type.parseAsync(data, {
                        path: ctx.path,
                        errorMap: ctx.common.contextualErrorMap
                    })));
            }
        }
        ZodPromise.create = (schema, params)=>new ZodPromise({
                type: schema,
                typeName: ZodFirstPartyTypeKind.ZodPromise,
                ...processCreateParams(params)
            });
        class ZodEffects extends ZodType {
            innerType() {
                return this._def.schema;
            }
            sourceType() {
                return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                const effect = this._def.effect || null;
                const checkCtx = {
                    addIssue: (arg)=>{
                        addIssueToContext(ctx, arg);
                        if (arg.fatal) status.abort();
                        else status.dirty();
                    },
                    get path () {
                        return ctx.path;
                    }
                };
                checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
                if ("preprocess" === effect.type) {
                    const processed = effect.transform(ctx.data, checkCtx);
                    if (ctx.common.async) return Promise.resolve(processed).then(async (processed)=>{
                        if ("aborted" === status.value) return INVALID;
                        const result = await this._def.schema._parseAsync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === result.status) return INVALID;
                        if ("dirty" === result.status) return DIRTY(result.value);
                        if ("dirty" === status.value) return DIRTY(result.value);
                        return result;
                    });
                    {
                        if ("aborted" === status.value) return INVALID;
                        const result = this._def.schema._parseSync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === result.status) return INVALID;
                        if ("dirty" === result.status) return DIRTY(result.value);
                        if ("dirty" === status.value) return DIRTY(result.value);
                        return result;
                    }
                }
                if ("refinement" === effect.type) {
                    const executeRefinement = (acc)=>{
                        const result = effect.refinement(acc, checkCtx);
                        if (ctx.common.async) return Promise.resolve(result);
                        if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                        return acc;
                    };
                    if (false !== ctx.common.async) return this._def.schema._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }).then((inner)=>{
                        if ("aborted" === inner.status) return INVALID;
                        if ("dirty" === inner.status) status.dirty();
                        return executeRefinement(inner.value).then(()=>({
                                status: status.value,
                                value: inner.value
                            }));
                    });
                    {
                        const inner = this._def.schema._parseSync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === inner.status) return INVALID;
                        if ("dirty" === inner.status) status.dirty();
                        executeRefinement(inner.value);
                        return {
                            status: status.value,
                            value: inner.value
                        };
                    }
                }
                if ("transform" === effect.type) {
                    if (false !== ctx.common.async) return this._def.schema._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }).then((base)=>{
                        if (!isValid(base)) return base;
                        return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                                status: status.value,
                                value: result
                            }));
                    });
                    {
                        const base = this._def.schema._parseSync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: ctx
                        });
                        if (!isValid(base)) return base;
                        const result = effect.transform(base.value, checkCtx);
                        if (result instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                        return {
                            status: status.value,
                            value: result
                        };
                    }
                }
                util.assertNever(effect);
            }
        }
        ZodEffects.create = (schema, effect, params)=>new ZodEffects({
                schema,
                typeName: ZodFirstPartyTypeKind.ZodEffects,
                effect,
                ...processCreateParams(params)
            });
        ZodEffects.createWithPreprocess = (preprocess, schema, params)=>new ZodEffects({
                schema,
                effect: {
                    type: "preprocess",
                    transform: preprocess
                },
                typeName: ZodFirstPartyTypeKind.ZodEffects,
                ...processCreateParams(params)
            });
        class ZodOptional extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType === ZodParsedType.undefined) return OK(void 0);
                return this._def.innerType._parse(input);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodOptional.create = (type, params)=>new ZodOptional({
                innerType: type,
                typeName: ZodFirstPartyTypeKind.ZodOptional,
                ...processCreateParams(params)
            });
        class ZodNullable extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType === ZodParsedType.null) return OK(null);
                return this._def.innerType._parse(input);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodNullable.create = (type, params)=>new ZodNullable({
                innerType: type,
                typeName: ZodFirstPartyTypeKind.ZodNullable,
                ...processCreateParams(params)
            });
        class ZodDefault extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                let data = ctx.data;
                if (ctx.parsedType === ZodParsedType.undefined) data = this._def.defaultValue();
                return this._def.innerType._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            removeDefault() {
                return this._def.innerType;
            }
        }
        ZodDefault.create = (type, params)=>new ZodDefault({
                innerType: type,
                typeName: ZodFirstPartyTypeKind.ZodDefault,
                defaultValue: "function" == typeof params.default ? params.default : ()=>params.default,
                ...processCreateParams(params)
            });
        class ZodCatch extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const newCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    }
                };
                const result = this._def.innerType._parse({
                    data: newCtx.data,
                    path: newCtx.path,
                    parent: {
                        ...newCtx
                    }
                });
                if (isAsync(result)) return result.then((result)=>({
                        status: "valid",
                        value: "valid" === result.status ? result.value : this._def.catchValue({
                            get error () {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data
                        })
                    }));
                return {
                    status: "valid",
                    value: "valid" === result.status ? result.value : this._def.catchValue({
                        get error () {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data
                    })
                };
            }
            removeCatch() {
                return this._def.innerType;
            }
        }
        ZodCatch.create = (type, params)=>new ZodCatch({
                innerType: type,
                typeName: ZodFirstPartyTypeKind.ZodCatch,
                catchValue: "function" == typeof params.catch ? params.catch : ()=>params.catch,
                ...processCreateParams(params)
            });
        class ZodNaN extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.nan) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.nan,
                        received: ctx.parsedType
                    });
                    return INVALID;
                }
                return {
                    status: "valid",
                    value: input.data
                };
            }
        }
        ZodNaN.create = (params)=>new ZodNaN({
                typeName: ZodFirstPartyTypeKind.ZodNaN,
                ...processCreateParams(params)
            });
        const BRAND = Symbol("zod_brand");
        class ZodBranded extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const data = ctx.data;
                return this._def.type._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            unwrap() {
                return this._def.type;
            }
        }
        class ZodPipeline extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.common.async) {
                    const handleAsync = async ()=>{
                        const inResult = await this._def.in._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === inResult.status) return INVALID;
                        if ("dirty" !== inResult.status) return this._def.out._parseAsync({
                            data: inResult.value,
                            path: ctx.path,
                            parent: ctx
                        });
                        status.dirty();
                        return DIRTY(inResult.value);
                    };
                    return handleAsync();
                }
                {
                    const inResult = this._def.in._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if ("aborted" === inResult.status) return INVALID;
                    if ("dirty" !== inResult.status) return this._def.out._parseSync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx
                    });
                    status.dirty();
                    return {
                        status: "dirty",
                        value: inResult.value
                    };
                }
            }
            static create(a, b) {
                return new ZodPipeline({
                    in: a,
                    out: b,
                    typeName: ZodFirstPartyTypeKind.ZodPipeline
                });
            }
        }
        class ZodReadonly extends ZodType {
            _parse(input) {
                const result = this._def.innerType._parse(input);
                const freeze = (data)=>{
                    if (isValid(data)) data.value = Object.freeze(data.value);
                    return data;
                };
                return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodReadonly.create = (type, params)=>new ZodReadonly({
                innerType: type,
                typeName: ZodFirstPartyTypeKind.ZodReadonly,
                ...processCreateParams(params)
            });
        function cleanParams(params, data) {
            const p = "function" == typeof params ? params(data) : "string" == typeof params ? {
                message: params
            } : params;
            const p2 = "string" == typeof p ? {
                message: p
            } : p;
            return p2;
        }
        function custom(check, _params = {}, fatal) {
            if (check) return ZodAny.create().superRefine((data, ctx)=>{
                var _a, _b;
                const r = check(data);
                if (r instanceof Promise) return r.then((r)=>{
                    var _a, _b;
                    if (!r) {
                        const params = cleanParams(_params, data);
                        const _fatal = null !== (_b = null !== (_a = params.fatal) && void 0 !== _a ? _a : fatal) && void 0 !== _b ? _b : true;
                        ctx.addIssue({
                            code: "custom",
                            ...params,
                            fatal: _fatal
                        });
                    }
                });
                if (!r) {
                    const params = cleanParams(_params, data);
                    const _fatal = null !== (_b = null !== (_a = params.fatal) && void 0 !== _a ? _a : fatal) && void 0 !== _b ? _b : true;
                    ctx.addIssue({
                        code: "custom",
                        ...params,
                        fatal: _fatal
                    });
                }
            });
            return ZodAny.create();
        }
        const late = {
            object: ZodObject.lazycreate
        };
        var ZodFirstPartyTypeKind;
        (function(ZodFirstPartyTypeKind) {
            ZodFirstPartyTypeKind["ZodString"] = "ZodString";
            ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
            ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
            ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
            ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
            ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
            ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
            ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
            ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
            ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
            ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
            ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
            ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
            ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
            ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
            ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
            ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
            ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
            ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
            ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
            ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
            ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
            ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
            ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
            ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
            ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
            ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
            ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
            ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
            ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
            ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
            ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
            ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
            ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
            ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
            ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
        })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
        const instanceOfType = (cls, params = {
            message: `Input not instance of ${cls.name}`
        })=>custom((data)=>data instanceof cls, params);
        const stringType = ZodString.create;
        const numberType = ZodNumber.create;
        const nanType = ZodNaN.create;
        const bigIntType = ZodBigInt.create;
        const booleanType = ZodBoolean.create;
        const dateType = ZodDate.create;
        const symbolType = ZodSymbol.create;
        const undefinedType = ZodUndefined.create;
        const nullType = ZodNull.create;
        const anyType = ZodAny.create;
        const unknownType = ZodUnknown.create;
        const neverType = ZodNever.create;
        const voidType = ZodVoid.create;
        const arrayType = ZodArray.create;
        const objectType = ZodObject.create;
        const strictObjectType = ZodObject.strictCreate;
        const unionType = ZodUnion.create;
        const discriminatedUnionType = ZodDiscriminatedUnion.create;
        const intersectionType = ZodIntersection.create;
        const tupleType = ZodTuple.create;
        const recordType = ZodRecord.create;
        const mapType = ZodMap.create;
        const setType = ZodSet.create;
        const functionType = ZodFunction.create;
        const lazyType = ZodLazy.create;
        const literalType = ZodLiteral.create;
        const enumType = ZodEnum.create;
        const nativeEnumType = ZodNativeEnum.create;
        const promiseType = ZodPromise.create;
        const effectsType = ZodEffects.create;
        const optionalType = ZodOptional.create;
        const nullableType = ZodNullable.create;
        const preprocessType = ZodEffects.createWithPreprocess;
        const pipelineType = ZodPipeline.create;
        const ostring = ()=>stringType().optional();
        const onumber = ()=>numberType().optional();
        const oboolean = ()=>booleanType().optional();
        const coerce = {
            string: (arg)=>ZodString.create({
                    ...arg,
                    coerce: true
                }),
            number: (arg)=>ZodNumber.create({
                    ...arg,
                    coerce: true
                }),
            boolean: (arg)=>ZodBoolean.create({
                    ...arg,
                    coerce: true
                }),
            bigint: (arg)=>ZodBigInt.create({
                    ...arg,
                    coerce: true
                }),
            date: (arg)=>ZodDate.create({
                    ...arg,
                    coerce: true
                })
        };
        const NEVER = INVALID;
        var z = /*#__PURE__*/ Object.freeze({
            __proto__: null,
            defaultErrorMap: errorMap,
            setErrorMap: setErrorMap,
            getErrorMap: getErrorMap,
            makeIssue: makeIssue,
            EMPTY_PATH: EMPTY_PATH,
            addIssueToContext: addIssueToContext,
            ParseStatus: ParseStatus,
            INVALID: INVALID,
            DIRTY: DIRTY,
            OK: OK,
            isAborted: isAborted,
            isDirty: isDirty,
            isValid: isValid,
            isAsync: isAsync,
            get util () {
                return util;
            },
            get objectUtil () {
                return objectUtil;
            },
            ZodParsedType: ZodParsedType,
            getParsedType: getParsedType,
            ZodType: ZodType,
            datetimeRegex: datetimeRegex,
            ZodString: ZodString,
            ZodNumber: ZodNumber,
            ZodBigInt: ZodBigInt,
            ZodBoolean: ZodBoolean,
            ZodDate: ZodDate,
            ZodSymbol: ZodSymbol,
            ZodUndefined: ZodUndefined,
            ZodNull: ZodNull,
            ZodAny: ZodAny,
            ZodUnknown: ZodUnknown,
            ZodNever: ZodNever,
            ZodVoid: ZodVoid,
            ZodArray: ZodArray,
            ZodObject: ZodObject,
            ZodUnion: ZodUnion,
            ZodDiscriminatedUnion: ZodDiscriminatedUnion,
            ZodIntersection: ZodIntersection,
            ZodTuple: ZodTuple,
            ZodRecord: ZodRecord,
            ZodMap: ZodMap,
            ZodSet: ZodSet,
            ZodFunction: ZodFunction,
            ZodLazy: ZodLazy,
            ZodLiteral: ZodLiteral,
            ZodEnum: ZodEnum,
            ZodNativeEnum: ZodNativeEnum,
            ZodPromise: ZodPromise,
            ZodEffects: ZodEffects,
            ZodTransformer: ZodEffects,
            ZodOptional: ZodOptional,
            ZodNullable: ZodNullable,
            ZodDefault: ZodDefault,
            ZodCatch: ZodCatch,
            ZodNaN: ZodNaN,
            BRAND: BRAND,
            ZodBranded: ZodBranded,
            ZodPipeline: ZodPipeline,
            ZodReadonly: ZodReadonly,
            custom: custom,
            Schema: ZodType,
            ZodSchema: ZodType,
            late: late,
            get ZodFirstPartyTypeKind () {
                return ZodFirstPartyTypeKind;
            },
            coerce: coerce,
            any: anyType,
            array: arrayType,
            bigint: bigIntType,
            boolean: booleanType,
            date: dateType,
            discriminatedUnion: discriminatedUnionType,
            effect: effectsType,
            enum: enumType,
            function: functionType,
            instanceof: instanceOfType,
            intersection: intersectionType,
            lazy: lazyType,
            literal: literalType,
            map: mapType,
            nan: nanType,
            nativeEnum: nativeEnumType,
            never: neverType,
            null: nullType,
            nullable: nullableType,
            number: numberType,
            object: objectType,
            oboolean: oboolean,
            onumber: onumber,
            optional: optionalType,
            ostring: ostring,
            pipeline: pipelineType,
            preprocess: preprocessType,
            promise: promiseType,
            record: recordType,
            set: setType,
            strictObject: strictObjectType,
            string: stringType,
            symbol: symbolType,
            transformer: effectsType,
            tuple: tupleType,
            undefined: undefinedType,
            union: unionType,
            unknown: unknownType,
            void: voidType,
            NEVER: NEVER,
            ZodIssueCode: ZodIssueCode,
            quotelessJson: quotelessJson,
            ZodError: ZodError
        });
    },
    "../../../../node_modules/mime-types/node_modules/mime-db/db.json": function(module) {
        module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/ace+json":{"source":"iana","compressible":true},"application/ace-groupcomm+cbor":{"source":"iana"},"application/ace-trl+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/aif+cbor":{"source":"iana"},"application/aif+json":{"source":"iana","compressible":true},"application/alto-cdni+json":{"source":"iana","compressible":true},"application/alto-cdnifilter+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-propmap+json":{"source":"iana","compressible":true},"application/alto-propmapparams+json":{"source":"iana","compressible":true},"application/alto-tips+json":{"source":"iana","compressible":true},"application/alto-tipsparams+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/appinstaller":{"compressible":false,"extensions":["appinstaller"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/appx":{"compressible":false,"extensions":["appx"]},"application/appxbundle":{"compressible":false,"extensions":["appxbundle"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/automationml-aml+xml":{"source":"iana","compressible":true,"extensions":["aml"]},"application/automationml-amlx+zip":{"source":"iana","compressible":false,"extensions":["amlx"]},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/bufr":{"source":"iana"},"application/c2pa":{"source":"iana"},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/ce+cbor":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/cid-edhoc+cbor-seq":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/city+json-seq":{"source":"iana"},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-eap":{"source":"iana"},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/concise-problem-details+cbor":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cose-x509":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwl":{"source":"iana","extensions":["cwl"]},"application/cwl+json":{"source":"iana","compressible":true},"application/cwl+yaml":{"source":"iana"},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana","extensions":["dcm"]},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dpop+jwt":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/eat+cwt":{"source":"iana"},"application/eat+jwt":{"source":"iana"},"application/eat-bun+cbor":{"source":"iana"},"application/eat-bun+json":{"source":"iana","compressible":true},"application/eat-ucs+cbor":{"source":"iana"},"application/eat-ucs+json":{"source":"iana","compressible":true},"application/ecmascript":{"source":"apache","compressible":true,"extensions":["ecma"]},"application/edhoc+cbor-seq":{"source":"iana"},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.legacyesn+json":{"source":"iana","compressible":true},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/entity-statement+jwt":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdf":{"source":"iana","extensions":["fdf"]},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geopose+json":{"source":"iana","compressible":true},"application/geoxacml+json":{"source":"iana","compressible":true},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gnap-binding-jws":{"source":"iana"},"application/gnap-binding-jwsd":{"source":"iana"},"application/gnap-binding-rotation-jws":{"source":"iana"},"application/gnap-binding-rotation-jwsd":{"source":"iana"},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/grib":{"source":"iana"},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"iana","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"apache","charset":"UTF-8","compressible":true,"extensions":["js"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/jscontact+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jsonpath":{"source":"iana"},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwk-set+jwt":{"source":"iana"},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/linkset":{"source":"iana"},"application/linkset+json":{"source":"iana","compressible":true},"application/load-control+xml":{"source":"iana","compressible":true},"application/logout+jwt":{"source":"iana"},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4","mpg4","mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msix":{"compressible":false,"extensions":["msix"]},"application/msixbundle":{"compressible":false,"extensions":["msixbundle"]},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":true,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/ohttp-keys":{"source":"iana"},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg","one","onea"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["sig","asc"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/private-token-issuer-directory":{"source":"iana"},"application/private-token-request":{"source":"iana"},"application/private-token-response":{"source":"iana"},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/provided-claims+jwt":{"source":"iana"},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.implied-document+xml":{"source":"iana","compressible":true},"application/prs.implied-executable":{"source":"iana"},"application/prs.implied-object+json":{"source":"iana","compressible":true},"application/prs.implied-object+json-seq":{"source":"iana"},"application/prs.implied-object+yaml":{"source":"iana"},"application/prs.implied-structure":{"source":"iana"},"application/prs.mayfile":{"source":"iana"},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.vcfbzip2":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true,"extensions":["xsf"]},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"apache"},"application/reputon+json":{"source":"iana","compressible":true},"application/resolve-response+jwt":{"source":"iana"},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-checklist":{"source":"iana"},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-signed-tal":{"source":"iana"},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"apache"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana","extensions":["sql"]},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/sslkeylogfile":{"source":"iana"},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/st2110-41":{"source":"iana"},"application/stix+json":{"source":"iana","compressible":true},"application/stratum":{"source":"iana"},"application/swid+cbor":{"source":"iana"},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tm+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/toc+cbor":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"source":"iana","compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/trust-chain+json":{"source":"iana","compressible":true},"application/trust-mark+jwt":{"source":"iana"},"application/trust-mark-delegation+jwt":{"source":"iana"},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/uccs+cbor":{"source":"iana"},"application/ujcs+json":{"source":"iana","compressible":true},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vc":{"source":"iana"},"application/vc+cose":{"source":"iana"},"application/vc+jwt":{"source":"iana"},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.1ob":{"source":"iana"},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3a+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ach+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc8+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.5gsa2x":{"source":"iana"},"application/vnd.3gpp.5gsa2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gsv2x":{"source":"iana"},"application/vnd.3gpp.5gsv2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.crs+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.current-location-discovery+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.pinapp-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.seal-group-doc+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-network-qos-management-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-ue-config-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-unicast-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-user-profile-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.v2x":{"source":"iana"},"application/vnd.3gpp.vae-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acm.addressxfer+json":{"source":"iana","compressible":true},"application/vnd.acm.chatbot+json":{"source":"iana","compressible":true},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"apache","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"apache"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.parquet":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.apexlang":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"apache"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autodesk.fbx":{"extensions":["fbx"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.belightsoft.lhzd+zip":{"source":"iana","compressible":false},"application/vnd.belightsoft.lhzl+zip":{"source":"iana","compressible":false},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.bzip3":{"source":"iana"},"application/vnd.c3voc.schedule+xml":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.cncf.helm.chart.content.v1.tar+gzip":{"source":"iana"},"application/vnd.cncf.helm.chart.provenance.v1.prov":{"source":"iana"},"application/vnd.cncf.helm.config.v1+json":{"source":"iana","compressible":true},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datalog":{"source":"iana"},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.dcmp+xml":{"source":"iana","compressible":true,"extensions":["dcmp"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.eln+zip":{"source":"iana","compressible":false},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.erofs":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"apache","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.fdsn.stationxml+xml":{"source":"iana","charset":"XML-BASED","compressible":true},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.freelog.comic":{"source":"iana"},"application/vnd.frogans.fnc":{"source":"apache","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"apache","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.ga4gh.passport+jwt":{"source":"iana"},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.genozip":{"source":"iana"},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.gentoo.catmetadata+xml":{"source":"iana","compressible":true},"application/vnd.gentoo.ebuild":{"source":"iana"},"application/vnd.gentoo.eclass":{"source":"iana"},"application/vnd.gentoo.gpkg":{"source":"iana"},"application/vnd.gentoo.manifest":{"source":"iana"},"application/vnd.gentoo.pkgmetadata+xml":{"source":"iana","compressible":true},"application/vnd.gentoo.xpak":{"source":"iana"},"application/vnd.geo+json":{"source":"apache","compressible":true},"application/vnd.geocube+xml":{"source":"apache","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.pinboard":{"source":"iana"},"application/vnd.geogebra.slides":{"source":"iana","extensions":["ggs"]},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.gnu.taler.exchange+json":{"source":"iana","compressible":true},"application/vnd.gnu.taler.merchant+json":{"source":"iana","compressible":true},"application/vnd.google-apps.audio":{},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.drawing":{"compressible":false,"extensions":["gdraw"]},"application/vnd.google-apps.drive-sdk":{"compressible":false},"application/vnd.google-apps.file":{},"application/vnd.google-apps.folder":{"compressible":false},"application/vnd.google-apps.form":{"compressible":false,"extensions":["gform"]},"application/vnd.google-apps.fusiontable":{},"application/vnd.google-apps.jam":{"compressible":false,"extensions":["gjam"]},"application/vnd.google-apps.mail-layout":{},"application/vnd.google-apps.map":{"compressible":false,"extensions":["gmap"]},"application/vnd.google-apps.photo":{},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.script":{"compressible":false,"extensions":["gscript"]},"application/vnd.google-apps.shortcut":{},"application/vnd.google-apps.site":{"compressible":false,"extensions":["gsite"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-apps.unknown":{},"application/vnd.google-apps.video":{},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"apache","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true,"extensions":["xdcf"]},"application/vnd.gpxsee.map+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.hsl":{"source":"iana"},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"apache"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"apache","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"apache"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.ipfs.ipns-record":{"source":"iana"},"application/vnd.ipld.car":{"source":"iana"},"application/vnd.ipld.dag-cbor":{"source":"iana"},"application/vnd.ipld.dag-json":{"source":"iana"},"application/vnd.ipld.raw":{"source":"iana"},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kdl":{"source":"iana"},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.keyman.kmp+zip":{"source":"iana","compressible":false},"application/vnd.keyman.kmx":{"source":"iana"},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.ldev.productlicensing":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.mdl":{"source":"iana"},"application/vnd.mdl-mbsdf":{"source":"iana"},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.medicalholodeck.recordxr":{"source":"iana"},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mermaid":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.modl":{"source":"iana"},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-visio.viewer":{"extensions":["vdx"]},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msgpack":{"source":"iana"},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.nato.bindingdataobject+cbor":{"source":"iana"},"application/vnd.nato.bindingdataobject+json":{"source":"iana","compressible":true},"application/vnd.nato.bindingdataobject+xml":{"source":"iana","compressible":true,"extensions":["bdo"]},"application/vnd.nato.openxmlformats-package.iepd+zip":{"source":"iana","compressible":false},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"apache","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oai.workflows":{"source":"iana"},"application/vnd.oai.workflows+json":{"source":"iana","compressible":true},"application/vnd.oai.workflows+yaml":{"source":"iana"},"application/vnd.oasis.opendocument.base":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"apache","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-master-template":{"source":"iana"},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"apache","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"apache","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.onvif.metadata":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openvpi.dspx+json":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.procrate.brushset":{"extensions":["brushset"]},"application/vnd.procreate.brush":{"extensions":["brush"]},"application/vnd.procreate.dream":{"extensions":["drm"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.pt.mundusmundi":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true,"extensions":["xhtm"]},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.relpipe":{"source":"iana"},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.sketchometry":{"source":"iana"},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.smintio.portals.archive":{"source":"iana"},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sybyl.mol2":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uic.osdm+json":{"source":"iana","compressible":true},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml","uo"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.veraison.tsm-report+cbor":{"source":"iana"},"application/vnd.veraison.tsm-report+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw","vsdx","vtx"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vocalshaper.vsp4":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.wasmflow.wafl":{"source":"iana"},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordlift":{"source":"iana"},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xarin.cpj":{"source":"iana"},"application/vnd.xecrets-encrypted":{"source":"iana"},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/voucher-jws+json":{"source":"iana","compressible":true},"application/vp":{"source":"iana"},"application/vp+cose":{"source":"iana"},"application/vp+jwt":{"source":"iana"},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blender":{"extensions":["blend"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-compressed":{"extensions":["rar"]},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-ipynb+json":{"compressible":true,"extensions":["ipynb"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zip-compressed":{"extensions":["zip"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xfdf":{"source":"iana","extensions":["xfdf"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yaml":{"source":"iana"},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+cbor":{"source":"iana"},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yang-sid+json":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zip+dotlottie":{"extensions":["lottie"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana","extensions":["adts","aac"]},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flac":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/matroska":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/midi-clip":{"source":"iana"},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a","m4b"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"apache"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"source":"iana","compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp","dib"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/dpx":{"source":"iana","extensions":["dpx"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/j2c":{"source":"iana"},"image/jaii":{"source":"iana","extensions":["jaii"]},"image/jais":{"source":"iana","extensions":["jais"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpg","jpeg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm","jpgm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxl":{"source":"iana","extensions":["jxl"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false,"extensions":["jfif"]},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif","btf"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.clip":{"source":"iana"},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"iana","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-adobe-dng":{"extensions":["dng"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-emf":{"source":"iana"},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-wmf":{"source":"iana"},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/bhttp":{"source":"iana"},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/mls":{"source":"iana"},"message/news":{"source":"apache"},"message/ohttp-req":{"source":"iana"},"message/ohttp-res":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime","mht","mhtml"]},"message/s-http":{"source":"apache"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"apache"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/jt":{"source":"iana","extensions":["jt"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/prc":{"source":"iana","extensions":["prc"]},"model/step":{"source":"iana","extensions":["step","stp","stpnc","p21","210"]},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/u3d":{"source":"iana","extensions":["u3d"]},"model/vnd.bary":{"source":"iana","extensions":["bary"]},"model/vnd.cld":{"source":"iana","extensions":["cld"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana","extensions":["pyo","pyox"]},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usda":{"source":"iana","extensions":["usda"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"apache"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/hl7v2":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["md","markdown"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/prs.texi":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.exchangeable":{"source":"iana"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"apache"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.vcf":{"source":"iana"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vnd.zoo.kcl":{"source":"iana"},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/wgsl":{"source":"iana","extensions":["wgsl"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/evc":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/h266":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/lottie+json":{"source":"iana","compressible":true},"video/matroska":{"source":"iana"},"video/matroska-3d":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts","m2t","m2ts","mts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.planar":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"apache"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');
    },
    "../../../../node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json": function(module) {
        module.exports = JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]');
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        id: moduleId,
        loaded: false,
        exports: {}
    };
    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.loaded = true;
    return module.exports;
}
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    __webpack_require__.nmd = (module)=>{
        module.paths = [];
        if (!module.children) module.children = [];
        return module;
    };
})();
var lib = __webpack_require__("../../../../node_modules/zod/lib/index.mjs");
__WEBPACK_EXTERNAL_MODULE_crypto__["default"].randomUUID;
const rnds8Pool = new Uint8Array(256);
rnds8Pool.length;
const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
const DEFAULT_BROWSER_CONTEXT_CONFIG = {
    minimumWaitPageLoadTime: 1,
    waitForNetworkIdlePageLoadTime: 1.0,
    maximumWaitPageLoadTime: 5.0,
    waitBetweenActions: 1.0,
    browserWindowSize: {
        width: 1280,
        height: 1100
    },
    highlightElements: true,
    viewportExpansion: 500,
    includeDynamicAttributes: true,
    homePageUrl: 'https://www.google.com'
};
var external_fs_ = __webpack_require__("fs");
var external_path_ = __webpack_require__("path");
var which = __webpack_require__("../../../../node_modules/which/which.js");
let dist_platform = process.platform;
function getEdgeLinux(name) {
    try {
        let path = which.sync(name);
        return path;
    } catch (e) {}
    return null;
}
function getEdgeWindows(edgeDirName) {
    let paths = [];
    let suffix = `\\Microsoft\\${edgeDirName}\\Application\\msedge.exe`;
    let prefixes = [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"]
    ].filter((v)=>!!v);
    for (let prefix of prefixes){
        let edgePath = external_path_["default"].join(prefix, suffix);
        paths.push(edgePath);
        if ((0, external_fs_.existsSync)(edgePath)) return edgePath;
    }
    return null;
}
function getEdgeDarwin(defaultPath) {
    if ((0, external_fs_.existsSync)(defaultPath)) return defaultPath;
    return null;
}
const edgePaths = {
    edge: {
        linux: ()=>getEdgeLinux("microsoft-edge-stable"),
        darwin: ()=>getEdgeDarwin("/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge"),
        win32: ()=>getEdgeWindows("Edge")
    },
    dev: {
        linux: ()=>getEdgeLinux("microsoft-edge-dev"),
        darwin: ()=>getEdgeDarwin("/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev"),
        win32: ()=>getEdgeWindows("Edge Dev")
    },
    beta: {
        linux: ()=>getEdgeLinux("microsoft-edge-beta"),
        darwin: ()=>getEdgeDarwin("/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta"),
        win32: ()=>getEdgeWindows("Edge Beta")
    },
    canary: {
        darwin: ()=>getEdgeDarwin("/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary"),
        win32: ()=>getEdgeWindows("Edge SxS")
    }
};
function getEdgePath() {
    let edge = edgePaths.edge;
    if (dist_platform && dist_platform in edgePaths.edge) {
        let pth = edge[dist_platform]();
        if (pth) return pth;
    }
    throwInvalidPlatformError("Edge Stable", edgePaths);
}
function getEdgeDevPath() {
    let edgeDev = edgePaths.dev;
    if (dist_platform && dist_platform in edgeDev) {
        let pth = edgeDev[dist_platform]();
        if (pth) return pth;
    }
    throwInvalidPlatformError("Edge Dev", edgePaths);
}
function getEdgeBetaPath() {
    let edgeBeta = edgePaths.beta;
    if (dist_platform && dist_platform in edgeBeta) {
        let pth = edgeBeta[dist_platform]();
        if (pth) return pth;
    }
    throwInvalidPlatformError("Edge Beta", edgePaths);
}
function getEdgeCanaryPath() {
    let edgeCanary = edgePaths.canary;
    if (dist_platform && dist_platform in edgeCanary) {
        let pth = edgeCanary[dist_platform]();
        if (pth) return pth;
    }
    throwInvalidPlatformError("Edge Canary", edgePaths);
}
function getAnyEdgeStable() {
    try {
        return getEdgePath();
    } catch (e) {
        throwIfNotEdgePathIssue(e);
    }
    try {
        return getEdgeBetaPath();
    } catch (e) {
        throwIfNotEdgePathIssue(e);
    }
    try {
        return getEdgeDevPath();
    } catch (e) {
        throwIfNotEdgePathIssue(e);
    }
    try {
        return getEdgeCanaryPath();
    } catch (e) {
        throwIfNotEdgePathIssue(e);
    }
    throw {
        name: "edge-paths",
        message: "Unable to find any ms-edge-browser."
    };
}
function throwInvalidPlatformError(additionalInfo = "", otherDetails) {
    throw {
        name: "edge-paths",
        message: `Couldn't find the edge browser. ${additionalInfo}`,
        additionalInfo,
        otherDetails
    };
}
function throwIfNotEdgePathIssue(obj) {
    if ("[object Object]" === Object.prototype.toString.call(obj) && obj && obj.name && "edge-paths" === obj.name) return;
    throw obj;
}
var which_lib = __webpack_require__("../../browser/node_modules/which/lib/index.js");
const chrome_paths_platform = process.platform;
function getChromeOnLinux(list) {
    try {
        for (const name of list){
            const path = which_lib.sync(name);
            return path;
        }
    } catch (e) {}
    return null;
}
function getChromeOnWindows(name) {
    const suffix = `${external_path_.sep}Google${external_path_.sep}${name}${external_path_.sep}Application${external_path_.sep}chrome.exe`;
    const prefixes = [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env['PROGRAMFILES(X86)']
    ].filter(Boolean);
    for (const prefix of prefixes){
        const chrome = (0, external_path_.join)(prefix, suffix);
        if ((0, external_fs_.existsSync)(chrome)) return chrome;
    }
    return null;
}
function getChromeOnDarwin(name) {
    const suffix = `/Applications/${name}.app/Contents/MacOS/${name}`;
    const prefixes = [
        '',
        process.env.HOME
    ].filter((item)=>void 0 !== item);
    for (const prefix of prefixes){
        const chromePath = (0, external_path_.join)(prefix, suffix);
        if ((0, external_fs_.existsSync)(chromePath)) return chromePath;
    }
    return null;
}
const chromePaths = {
    chrome: {
        linux: ()=>getChromeOnLinux([
                'google-chrome-stable',
                'google-chrome'
            ]),
        darwin: ()=>getChromeOnDarwin('Google Chrome'),
        win32: ()=>getChromeOnWindows('Chrome')
    },
    beta: {
        linux: ()=>getChromeOnLinux([
                'google-chrome-beta'
            ]),
        darwin: ()=>getChromeOnDarwin('Google Chrome Beta'),
        win32: ()=>getChromeOnWindows('Chrome Beta')
    },
    dev: {
        linux: ()=>getChromeOnLinux([
                'google-chrome-dev'
            ]),
        darwin: ()=>getChromeOnDarwin('Google Chrome Dev'),
        win32: ()=>getChromeOnWindows('Chrome Dev')
    },
    canary: {
        linux: ()=>getChromeOnLinux([
                'chromium-browser',
                'chromium'
            ]),
        darwin: ()=>getChromeOnDarwin('Google Chrome Canary'),
        win32: ()=>getChromeOnWindows('Chrome SxS')
    }
};
function getChromePath() {
    const chrome = chromePaths.chrome;
    if (chrome_paths_platform && Object.keys(chrome).includes(chrome_paths_platform)) {
        const pth = chrome[chrome_paths_platform]();
        if (pth) return pth;
    }
}
function getChromeBetaPath() {
    const beta = chromePaths.beta;
    if (chrome_paths_platform && Object.keys(beta).includes(chrome_paths_platform)) {
        const pth = beta[chrome_paths_platform]();
        if (pth) return pth;
    }
}
function getChromeDevPath() {
    const dev = chromePaths.dev;
    if (chrome_paths_platform && Object.keys(dev).includes(chrome_paths_platform)) {
        const pth = dev[chrome_paths_platform]();
        if (pth) return pth;
    }
}
function getChromeCanaryPath() {
    const canary = chromePaths.canary;
    if (chrome_paths_platform && Object.keys(canary).includes(chrome_paths_platform)) {
        const pth = canary[chrome_paths_platform]();
        if (pth) return pth;
    }
}
function getAnyChromeStable() {
    const chrome = getChromePath();
    if (chrome) return chrome;
    const beta = getChromeBetaPath();
    if (beta) return beta;
    const dev = getChromeDevPath();
    if (dev) return dev;
    const canary = getChromeCanaryPath();
    if (canary) return canary;
    const error = new Error('Unable to find any chrome browser.');
    error.name = 'ChromePathsError';
    throw error;
}
const firefox_paths_platform = process.platform;
function getFirefoxOnLinux(name) {
    try {
        const path = which_lib.sync(name);
        return path;
    } catch (e) {}
    return null;
}
function getFirefoxOnWindows(name) {
    const suffix = `${external_path_.sep}${name}${external_path_.sep}firefox.exe`;
    const prefixes = [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env['PROGRAMFILES(X86)']
    ].filter(Boolean);
    for (const prefix of prefixes){
        const firefoxPath = (0, external_path_.join)(prefix, suffix);
        if ((0, external_fs_.existsSync)(firefoxPath)) return firefoxPath;
    }
    return null;
}
function getFireFoxOnDarwin(name) {
    const suffix = `/Applications/${name}.app/Contents/MacOS/firefox`;
    const prefixes = [
        '',
        process.env.HOME
    ].filter((item)=>void 0 !== item);
    for (const prefix of prefixes){
        const firefoxPath = (0, external_path_.join)(prefix, suffix);
        if ((0, external_fs_.existsSync)(firefoxPath)) return firefoxPath;
    }
    return null;
}
const firefoxPaths = {
    firefox: {
        linux: ()=>getFirefoxOnLinux('firefox'),
        darwin: ()=>getFireFoxOnDarwin('Firefox'),
        win32: ()=>getFirefoxOnWindows('Mozilla Firefox')
    },
    dev: {
        darwin: ()=>getFireFoxOnDarwin('Firefox Developer Edition'),
        win32: ()=>getFirefoxOnWindows('Firefox Developer Edition')
    },
    nightly: {
        darwin: ()=>getFireFoxOnDarwin('Firefox Nightly'),
        win32: ()=>getFirefoxOnWindows('Firefox Nightly')
    }
};
function getFirefoxPath() {
    const firefox = firefoxPaths.firefox;
    if (firefox_paths_platform && Object.keys(firefox).includes(firefox_paths_platform)) {
        const pth = firefox[firefox_paths_platform]();
        if (pth) return pth;
    }
}
function getFirefoxDevPath() {
    const dev = firefoxPaths.dev;
    if (firefox_paths_platform && Object.keys(dev).includes(firefox_paths_platform)) {
        const pth = dev[firefox_paths_platform]();
        if (pth) return pth;
    }
}
function getFirefoxNightlyPath() {
    const nightly = firefoxPaths.nightly;
    if (firefox_paths_platform && Object.keys(nightly).includes(firefox_paths_platform)) {
        const pth = nightly[firefox_paths_platform]();
        if (pth) return pth;
    }
}
function getAnyFirefoxStable() {
    const firefox = getFirefoxPath();
    if (firefox) return firefox;
    const dev = getFirefoxDevPath();
    if (dev) return dev;
    const canary = getFirefoxNightlyPath();
    if (canary) return canary;
    const error = new Error('Unable to find any firefox browser.');
    error.name = 'FirefoxPathsError';
    throw error;
}
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class BrowserFinder {
    findBrowser(name) {
        const platform = process.platform;
        let browserPath;
        let browserType;
        this.logger.info('Find browser on platform:', platform);
        if (![
            'darwin',
            'win32',
            'linux'
        ].includes(platform)) {
            const error = new Error(`Unsupported platform: ${platform}`);
            this.logger.error(error.message);
            throw error;
        }
        switch(name){
            case 'chrome':
                browserPath = this.findChrome();
                browserType = 'chrome';
                break;
            case 'edge':
                browserPath = this.findEdge();
                browserType = 'edge';
                break;
            case 'firefox':
                browserPath = this.findFirefox();
                browserType = 'firefox';
                break;
            default:
                const value = this.findAnyBrowser();
                browserPath = value.path;
                browserType = value.type;
                break;
        }
        this.logger.info('browserPath:', browserPath);
        return {
            path: browserPath,
            type: browserType
        };
    }
    findChrome() {
        try {
            return getAnyChromeStable();
        } catch (e) {
            this.logger.error('Find Chrome Error:', e);
            throw e;
        }
    }
    findEdge() {
        try {
            return getAnyEdgeStable();
        } catch (e) {
            this.logger.error('Find Edge Error:', e);
            throw e;
        }
    }
    findFirefox() {
        try {
            return getAnyFirefoxStable();
        } catch (e) {
            this.logger.error('Find Firefox Error:', e);
            throw e;
        }
    }
    findAnyBrowser() {
        try {
            return {
                path: getAnyChromeStable(),
                type: 'chrome'
            };
        } catch (e) {
            this.logger.warn('Find Chrome Error:', e);
        }
        try {
            return {
                path: getAnyEdgeStable(),
                type: 'edge'
            };
        } catch (e) {
            this.logger.warn('Find Edge Error:', e);
        }
        try {
            return {
                path: getAnyFirefoxStable(),
                type: 'firefox'
            };
        } catch (e) {
            this.logger.warn('Find Firefox Error:', e);
        }
        const error = new Error('Unable to find any browser.');
        error.name = 'BrowserPathsError';
        throw error;
    }
    constructor(logger){
        _define_property(this, "logger", void 0);
        this.logger = logger ?? __WEBPACK_EXTERNAL_MODULE__agent_infra_logger_ddae3da2__.defaultLogger;
    }
}
function base_browser_define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class BaseBrowser {
    async isBrowserAlive() {
        if (!this.browser) return false;
        try {
            const version = await this.browser.version();
            this.logger.info('Browser version:', version);
            return true;
        } catch (error) {
            this.logger.warn('Browser instance is no longer active:', error);
            this.browser = null;
            return false;
        }
    }
    getBrowser() {
        if (!this.browser) throw new Error('Browser not launched');
        return this.browser;
    }
    async setupPageListener() {
        this.logger.info('setupPageListener()');
        if (!this.browser) return;
        this.browser.on('targetcreated', async (target)=>{
            this.logger.info('PageListener: targetcreated, type:', target.type());
            const page = await target.page();
            if (page) {
                this.logger.info('New page created:', await page.url());
                this.activePage = page;
                page.once('close', ()=>{
                    if (this.activePage === page) this.activePage = null;
                });
                page.once('error', ()=>{
                    if (this.activePage === page) this.activePage = null;
                });
            }
        });
        this.browser.on('targetchanged', async (target)=>{
            this.logger.info('PageListener: targetchanged:', target.type());
            try {
                const changedPage = await target.page();
                if (changedPage) {
                    const currentUrl = await changedPage.url();
                    this.logger.info('The target changed', currentUrl);
                    if (currentUrl && 'about:blank' !== currentUrl) this.activePage = changedPage;
                }
            } catch (error) {
                this.logger.error('error on targetchanged:', error);
            }
        });
        this.browser.on('targetdestroyed', async (target)=>{
            this.logger.info('PageListener: targetdestroyed:', target.type());
            if ('page' === target.type()) try {
                var _this_browser;
                const pages = await (null === (_this_browser = this.browser) || void 0 === _this_browser ? void 0 : _this_browser.pages());
                this.logger.info('Destoryed, left pages:', null == pages ? void 0 : pages.length);
                this.activePage = null;
            } catch (error) {
                this.logger.error('error on targetdestroyed:', error);
            }
        });
    }
    async close() {
        this.logger.info('Closing browser');
        try {
            var _this_browser;
            await (null === (_this_browser = this.browser) || void 0 === _this_browser ? void 0 : _this_browser.close());
            this.browser = null;
            this.logger.success('Browser closed successfully');
        } catch (error) {
            this.logger.error('Failed to close browser:', error);
            throw error;
        }
    }
    async evaluateOnNewPage(options) {
        const { url, pageFunction, pageFunctionParams, beforePageLoad, afterPageLoad, beforeSendResult, waitForOptions } = options;
        const page = await this.browser.newPage();
        try {
            await (null == beforePageLoad ? void 0 : beforePageLoad(page));
            await page.goto(url, {
                waitUntil: 'networkidle2',
                ...waitForOptions
            });
            await (null == afterPageLoad ? void 0 : afterPageLoad(page));
            const _window = await page.evaluateHandle(()=>window);
            const result = await page.evaluate(pageFunction, _window, ...pageFunctionParams);
            await (null == beforeSendResult ? void 0 : beforeSendResult(page, result));
            await _window.dispose();
            await page.close();
            return result;
        } catch (error) {
            await page.close();
            throw error;
        }
    }
    async createPage() {
        if (!this.browser) {
            this.logger.error('No active browser');
            throw new Error('Browser not launched');
        }
        const page = await this.browser.newPage();
        return page;
    }
    async getActivePage() {
        this.logger.info('getActivePage: current activePage', this.activePage);
        if (!this.browser) throw new Error('Browser not launched');
        if (this.activePage) try {
            await this.activePage.evaluate(()=>document.readyState);
            return this.activePage;
        } catch (e) {
            this.logger.warn('Active page no longer available:', e);
            this.activePage = null;
        }
        const pages = await this.browser.pages();
        this.logger.info('getActivePage: all of pages lenght:', pages.length);
        if (0 === pages.length) {
            this.activePage = await this.createPage();
            return this.activePage;
        }
        for(let i = pages.length - 1; i >= 0; i--){
            const page = pages[i];
            this.logger.info('getActivePage: page:', await page.title(), await page.url());
            try {
                await page.evaluate(()=>document.readyState);
                this.activePage = page;
                return page;
            } catch (e) {
                continue;
            }
        }
        throw new Error('No active page found');
    }
    constructor(options){
        base_browser_define_property(this, "browser", null);
        base_browser_define_property(this, "logger", void 0);
        base_browser_define_property(this, "activePage", null);
        this.logger = ((null == options ? void 0 : options.logger) ?? __WEBPACK_EXTERNAL_MODULE__agent_infra_logger_ddae3da2__.defaultLogger).spawn('[BaseBrowser]');
        this.logger.info('Browser Options:', options);
    }
}
class LocalBrowser extends BaseBrowser {
    async launch(options = {}) {
        var _options_defaultViewport, _options_defaultViewport1;
        this.logger.info('Launching browser with options:', options);
        const { path, type } = this.getBrowserInfo(options);
        const viewportWidth = (null == options ? void 0 : null === (_options_defaultViewport = options.defaultViewport) || void 0 === _options_defaultViewport ? void 0 : _options_defaultViewport.width) ?? 1280;
        const viewportHeight = (null == options ? void 0 : null === (_options_defaultViewport1 = options.defaultViewport) || void 0 === _options_defaultViewport1 ? void 0 : _options_defaultViewport1.height) ?? 800;
        const puppeteerLaunchOptions = {
            browser: type,
            executablePath: path,
            dumpio: (null == options ? void 0 : options.dumpio) ?? false,
            headless: (null == options ? void 0 : options.headless) ?? false,
            defaultViewport: {
                width: viewportWidth,
                height: viewportHeight,
                deviceScaleFactor: 0
            },
            ...options.userDataDir && {
                userDataDir: options.userDataDir
            },
            args: [
                '--no-sandbox',
                '--mute-audio',
                '--disable-gpu',
                '--disable-blink-features=AutomationControlled',
                '--disable-infobars',
                '--disable-background-timer-throttling',
                '--disable-popup-blocking',
                '--disable-backgrounding-occluded-windows',
                '--disable-renderer-backgrounding',
                '--disable-window-activation',
                '--disable-focus-on-load',
                '--no-default-browser-check',
                '--disable-web-security',
                '--disable-features=IsolateOrigins,site-per-process',
                '--disable-site-isolation-trials',
                `--window-size=${viewportWidth},${viewportHeight + 90}`,
                (null == options ? void 0 : options.proxy) ? `--proxy-server=${options.proxy}` : '',
                (null == options ? void 0 : options.proxyBypassList) ? `--proxy-bypass-list=${options.proxyBypassList}` : '',
                (null == options ? void 0 : options.profilePath) ? `--profile-directory=${options.profilePath}` : '',
                ...options.args ?? []
            ].filter((item)=>{
                if ('firefox' === type) {
                    if ('--disable-features=IsolateOrigins,site-per-process' === item || item === `--window-size=${viewportWidth},${viewportHeight + 90}`) return false;
                }
                return !!item;
            }),
            ignoreDefaultArgs: [
                '--enable-automation'
            ],
            timeout: options.timeout ?? 0,
            downloadBehavior: {
                policy: 'deny'
            }
        };
        this.logger.info('Launch options:', puppeteerLaunchOptions);
        try {
            this.browser = await __WEBPACK_EXTERNAL_MODULE_puppeteer_core_17481843__.launch(puppeteerLaunchOptions);
            await this.setupPageListener();
            this.logger.success('Browser launched successfully');
        } catch (error) {
            this.logger.error('Failed to launch browser:', error);
            throw error;
        }
    }
    getBrowserInfo(options = {}) {
        const map = {
            chrome: 'chrome',
            edge: 'chrome',
            firefox: 'firefox'
        };
        let browserPath = options.executablePath;
        let browserType = options.browserType && map[options.browserType];
        if (browserPath) {
            if (!browserType) {
                const lowercasePath = browserPath.toLowerCase();
                browserType = lowercasePath.includes('chrome') ? 'chrome' : lowercasePath.includes('edge') ? 'chrome' : lowercasePath.includes('firefox') ? 'firefox' : 'chrome';
            }
        } else {
            const browserInfo = new BrowserFinder(this.logger).findBrowser();
            browserPath = browserInfo.path;
            browserType = map[browserInfo.type];
        }
        this.logger.info('Using executable path:', browserPath);
        return {
            path: browserPath,
            type: browserType
        };
    }
}
function remote_browser_define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class RemoteBrowser extends BaseBrowser {
    async launch(options) {
        var _this_options;
        this.logger.info('Browser Launch options:', options);
        let browserWSEndpoint = null === (_this_options = this.options) || void 0 === _this_options ? void 0 : _this_options.wsEndpoint;
        if (!browserWSEndpoint) {
            var _this_options1;
            const cdpEndpoint = (null === (_this_options1 = this.options) || void 0 === _this_options1 ? void 0 : _this_options1.cdpEndpoint) || "http://127.0.0.1:9222/json/version";
            const response = await fetch(cdpEndpoint);
            const { webSocketDebuggerUrl } = await response.json();
            browserWSEndpoint = webSocketDebuggerUrl;
        }
        this.logger.info('Using WebSocket endpoint:', browserWSEndpoint);
        const puppeteerConnectOptions = {
            browserWSEndpoint,
            defaultViewport: (null == options ? void 0 : options.defaultViewport) ?? {
                width: 1280,
                height: 800
            }
        };
        try {
            this.browser = await __WEBPACK_EXTERNAL_MODULE_puppeteer_core_17481843__.connect(puppeteerConnectOptions);
            await this.setupPageListener();
            this.logger.success('Connected to remote browser successfully');
        } catch (error) {
            this.logger.error('Failed to connect to remote browser:', error);
            throw error;
        }
    }
    async setupPageListener() {
        super.setupPageListener();
    }
    constructor(options){
        super(options), remote_browser_define_property(this, "options", void 0), this.options = options;
    }
}
function createLogger(name) {
    const prefix = `[${name}]`;
    return {
        info: (...args)=>console.log(prefix, ...args),
        error: (...args)=>console.error(prefix, ...args),
        warning: (...args)=>console.warn(prefix, ...args),
        debug: (...args)=>console.debug(prefix, ...args)
    };
}
const getBuildDomTreeScript = ()=>{
    const injectedScript = "/**\n * The following code is modified based on\n * https://github.com/nanobrowser/nanobrowser/blob/master/chrome-extension/public/buildDomTree.js\n * https://github.com/browser-use/browser-use/blob/main/browser_use/dom/buildDomTree.js\n *\n * Apache-2.0 License\n * Copyright (c) 2024 alexchenzl\n * https://github.com/nanobrowser/nanobrowser/blob/master/LICENSE\n *\n * MIT License\n * Copyright (c) 2024 Gregor Zunic\n * https://github.com/browser-use/browser-use/blob/main/LICENSE\n */\nwindow.buildDomTree = (\n  args = {\n    doHighlightElements: true,\n    focusHighlightIndex: -1,\n    viewportExpansion: 0,\n  },\n) => {\n  const { doHighlightElements, focusHighlightIndex, viewportExpansion } = args;\n  let highlightIndex = 0; // Reset highlight index\n\n  const DOM_CACHE = {\n    boundingRects: new WeakMap(),\n    clientRects: new WeakMap(),\n    computedStyles: new WeakMap(),\n    clearCache: () => {\n      DOM_CACHE.boundingRects = new WeakMap();\n      DOM_CACHE.clientRects = new WeakMap();\n      DOM_CACHE.computedStyles = new WeakMap();\n    },\n  };\n\n  function getCachedBoundingRect(element) {\n    if (!element) return null;\n    if (DOM_CACHE.boundingRects.has(element)) {\n      return DOM_CACHE.boundingRects.get(element);\n    }\n    const rect = element.getBoundingClientRect();\n    if (rect) {\n      DOM_CACHE.boundingRects.set(element, rect);\n    }\n    return rect;\n  }\n\n  // Add a new function to get cached client rects\n  function getCachedClientRects(element) {\n    if (!element) return null;\n\n    if (DOM_CACHE.clientRects.has(element)) {\n      return DOM_CACHE.clientRects.get(element);\n    }\n\n    const rects = element.getClientRects();\n\n    if (rects) {\n      DOM_CACHE.clientRects.set(element, rects);\n    }\n    return rects;\n  }\n\n  function getCachedComputedStyle(element) {\n    if (!element) return null;\n    if (DOM_CACHE.computedStyles.has(element)) {\n      return DOM_CACHE.computedStyles.get(element);\n    }\n    const style = getComputedStyle(element);\n    if (style) {\n      DOM_CACHE.computedStyles.set(element, style);\n    }\n    return style;\n  }\n\n  function highlightElement(element, index, parentIframe = null) {\n    // Create or get highlight container\n    let container = document.getElementById('playwright-highlight-container');\n    if (!container) {\n      container = document.createElement('div');\n      container.id = 'playwright-highlight-container';\n      container.style.position = 'absolute';\n      container.style.pointerEvents = 'none';\n      container.style.top = '0';\n      container.style.left = '0';\n      container.style.width = '100%';\n      container.style.height = '100%';\n      container.style.zIndex = '2147483647'; // Maximum z-index value\n      container.style.backgroundColor = 'transparent';\n      document.body.appendChild(container);\n    }\n\n    // Generate a color based on the index\n    const colors = [\n      '#FF0000',\n      '#00FF00',\n      '#0000FF',\n      '#FFA500',\n      '#800080',\n      '#008080',\n      '#FF69B4',\n      '#4B0082',\n      '#FF4500',\n      '#2E8B57',\n      '#DC143C',\n      '#4682B4',\n    ];\n    const colorIndex = index % colors.length;\n    const baseColor = colors[colorIndex];\n    const backgroundColor = `${baseColor}1A`; // 10% opacity version of the color\n\n    // Create highlight overlay\n    const overlay = document.createElement('div');\n    overlay.style.position = 'absolute';\n    overlay.style.border = `2px solid ${baseColor}`;\n    overlay.style.backgroundColor = backgroundColor;\n    overlay.style.pointerEvents = 'none';\n    overlay.style.boxSizing = 'border-box';\n\n    // Position overlay based on element, including scroll position\n    const rect = getCachedBoundingRect(element);\n    let top = rect.top + window.scrollY;\n    let left = rect.left + window.scrollX;\n\n    // Adjust position if element is inside an iframe\n    if (parentIframe) {\n      const iframeRect = getCachedBoundingRect(parentIframe);\n      top += iframeRect.top;\n      left += iframeRect.left;\n    }\n\n    overlay.style.top = `${top}px`;\n    overlay.style.left = `${left}px`;\n    overlay.style.width = `${rect.width}px`;\n    overlay.style.height = `${rect.height}px`;\n\n    // Create label\n    const label = document.createElement('div');\n    label.className = 'playwright-highlight-label';\n    label.style.position = 'absolute';\n    label.style.background = baseColor;\n    label.style.color = 'white';\n    label.style.padding = '1px 4px';\n    label.style.borderRadius = '4px';\n    label.style.fontSize = `${Math.min(12, Math.max(8, rect.height / 2))}px`; // Responsive font size\n    label.textContent = index;\n\n    // Calculate label position\n    const labelWidth = 20; // Approximate width\n    const labelHeight = 16; // Approximate height\n\n    // Default position (top-right corner inside the box)\n    let labelTop = top + 2;\n    let labelLeft = left + rect.width - labelWidth - 2;\n\n    // Adjust if box is too small\n    if (rect.width < labelWidth + 4 || rect.height < labelHeight + 4) {\n      // Position outside the box if it's too small\n      labelTop = top - labelHeight - 2;\n      labelLeft = left + rect.width - labelWidth;\n    }\n\n    label.style.top = `${labelTop}px`;\n    label.style.left = `${labelLeft}px`;\n\n    // Add to container\n    container.appendChild(overlay);\n    container.appendChild(label);\n\n    // Store reference for cleanup\n    element.setAttribute(\n      'browser-user-highlight-id',\n      `playwright-highlight-${index}`,\n    );\n\n    return index + 1;\n  }\n\n  // Helper function to generate XPath as a tree\n  function getXPathTree(element, stopAtBoundary = true) {\n    const segments = [];\n    let currentElement = element;\n\n    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {\n      // Stop if we hit a shadow root or iframe\n      if (\n        stopAtBoundary &&\n        (currentElement.parentNode instanceof ShadowRoot ||\n          currentElement.parentNode instanceof HTMLIFrameElement)\n      ) {\n        break;\n      }\n\n      let index = 0;\n      let sibling = currentElement.previousSibling;\n      while (sibling) {\n        if (\n          sibling.nodeType === Node.ELEMENT_NODE &&\n          sibling.nodeName === currentElement.nodeName\n        ) {\n          index++;\n        }\n        sibling = sibling.previousSibling;\n      }\n\n      const tagName = currentElement.nodeName\n        ? currentElement.nodeName.toLowerCase()\n        : null;\n      const xpathIndex = index > 0 ? `[${index + 1}]` : '';\n      segments.unshift(`${tagName}${xpathIndex}`);\n\n      currentElement = currentElement.parentNode;\n    }\n\n    return segments.join('/');\n  }\n\n  function getCssSelector(element) {\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) return null;\n\n    // if element has ID, use ID selector (most concise and effective)\n    if (element.id) {\n      return `#${element.id}`;\n    }\n\n    let path = [];\n    while (element && element.nodeType === Node.ELEMENT_NODE) {\n      let selector = element.nodeName ? element.nodeName.toLowerCase() : null;\n\n      // if element has ID, use ID selector\n      if (element.id) {\n        selector = `#${element.id}`;\n        path.unshift(selector);\n        break;\n      }\n      // if element has class name, use class selector (but be careful about multiple class names)\n      else if (element.className && typeof element.className === 'string') {\n        const classes = element.className.trim().split(/\\s+/);\n        if (classes.length > 0 && classes[0]) {\n          selector += `.${classes[0]}`;\n        }\n      }\n\n      // add nth-of-type to ensure the selector is unique\n      let sibling = element;\n      let nth = 1;\n      while ((sibling = sibling.previousElementSibling)) {\n        if (\n          sibling.nodeName &&\n          element.nodeName &&\n          sibling.nodeName.toLowerCase() === element.nodeName.toLowerCase()\n        )\n          nth++;\n      }\n      if (nth > 1) selector += `:nth-of-type(${nth})`;\n\n      path.unshift(selector);\n\n      // if we have reached an element with ID or body, stop\n      if (\n        element.parentNode &&\n        (element.parentNode.id ||\n          (element.parentNode.nodeName &&\n            element.parentNode.nodeName.toLowerCase() === 'body'))\n      ) {\n        if (element.parentNode.id) {\n          path.unshift(`#${element.parentNode.id}`);\n        } else {\n          path.unshift('body');\n        }\n        break;\n      }\n\n      element = element.parentNode;\n    }\n\n    return path.join(' > ');\n  }\n  // Helper function to check if element is accepted\n  function isElementAccepted(element) {\n    const leafElementDenyList = new Set([\n      'svg',\n      'script',\n      'style',\n      'link',\n      'meta',\n    ]);\n    return !leafElementDenyList.has(\n      element.tagName ? element.tagName.toLowerCase() : null,\n    );\n  }\n\n  // Helper function to check if element is interactive\n  function isInteractiveElement(element) {\n    // Immediately return false for body tag\n    if (element.tagName && element.tagName.toLowerCase() === 'body') {\n      return false;\n    }\n\n    // Base interactive elements and roles\n    const interactiveElements = new Set([\n      'a',\n      'button',\n      'details',\n      'embed',\n      'input',\n      'label',\n      'menu',\n      'menuitem',\n      'object',\n      'select',\n      'textarea',\n      'summary',\n    ]);\n\n    const interactiveRoles = new Set([\n      'button',\n      'menu',\n      'menuitem',\n      'link',\n      'checkbox',\n      'radio',\n      'slider',\n      'tab',\n      'tabpanel',\n      'textbox',\n      'combobox',\n      'grid',\n      'listbox',\n      'option',\n      'progressbar',\n      'scrollbar',\n      'searchbox',\n      'switch',\n      'tree',\n      'treeitem',\n      'spinbutton',\n      'tooltip',\n      'a-button-inner',\n      'a-dropdown-button',\n      'click',\n      'menuitemcheckbox',\n      'menuitemradio',\n      'a-button-text',\n      'button-text',\n      'button-icon',\n      'button-icon-only',\n      'button-text-icon-only',\n      'dropdown',\n      'combobox',\n    ]);\n\n    const tagName = element.tagName ? element.tagName.toLowerCase() : null;\n    const role = element.getAttribute('role');\n    const ariaRole = element.getAttribute('aria-role');\n    const tabIndex = element.getAttribute('tabindex');\n\n    // Add check for specific class\n    const hasAddressInputClass = element.classList.contains(\n      'address-input__container__input',\n    );\n\n    // Basic role/attribute checks\n    const hasInteractiveRole =\n      hasAddressInputClass ||\n      interactiveElements.has(tagName) ||\n      interactiveRoles.has(role) ||\n      interactiveRoles.has(ariaRole) ||\n      (tabIndex !== null &&\n        tabIndex !== '-1' &&\n        element.parentElement?.tagName &&\n        element.parentElement?.tagName.toLowerCase() !== 'body') ||\n      element.getAttribute('data-action') === 'a-dropdown-select' ||\n      element.getAttribute('data-action') === 'a-dropdown-button';\n\n    if (hasInteractiveRole) return true;\n\n    // Get computed style\n    const style = getCachedComputedStyle(element);\n\n    // Check if element has click-like styling\n    // const hasClickStyling = style.cursor === 'pointer' ||\n    //     element.style.cursor === 'pointer' ||\n    //     style.pointerEvents !== 'none';\n\n    // Check for event listeners\n    const hasClickHandler =\n      element.onclick !== null ||\n      element.getAttribute('onclick') !== null ||\n      element.hasAttribute('ng-click') ||\n      element.hasAttribute('@click') ||\n      element.hasAttribute('v-on:click');\n\n    // Helper function to safely get event listeners\n    function getEventListeners(el) {\n      try {\n        // Try to get listeners using Chrome DevTools API\n        return window.getEventListeners?.(el) || {};\n      } catch (e) {\n        // Fallback: check for common event properties\n        const listeners = {};\n\n        // List of common event types to check\n        const eventTypes = [\n          'click',\n          'mousedown',\n          'mouseup',\n          'touchstart',\n          'touchend',\n          'keydown',\n          'keyup',\n          'focus',\n          'blur',\n        ];\n\n        for (const type of eventTypes) {\n          const handler = el[`on${type}`];\n          if (handler) {\n            listeners[type] = [\n              {\n                listener: handler,\n                useCapture: false,\n              },\n            ];\n          }\n        }\n\n        return listeners;\n      }\n    }\n\n    // Check for click-related events on the element itself\n    const listeners = getEventListeners(element);\n    const hasClickListeners =\n      listeners &&\n      (listeners.click?.length > 0 ||\n        listeners.mousedown?.length > 0 ||\n        listeners.mouseup?.length > 0 ||\n        listeners.touchstart?.length > 0 ||\n        listeners.touchend?.length > 0);\n\n    // Check for ARIA properties that suggest interactivity\n    const hasAriaProps =\n      element.hasAttribute('aria-expanded') ||\n      element.hasAttribute('aria-pressed') ||\n      element.hasAttribute('aria-selected') ||\n      element.hasAttribute('aria-checked');\n\n    // Check for form-related functionality\n    const isFormRelated =\n      element.form !== undefined ||\n      element.hasAttribute('contenteditable') ||\n      style.userSelect !== 'none';\n\n    // Check if element is draggable\n    const isDraggable =\n      element.draggable || element.getAttribute('draggable') === 'true';\n\n    // Additional check to prevent body from being marked as interactive\n    if (\n      (element.tagName && element.tagName.toLowerCase() === 'body') ||\n      (element.parentElement &&\n        element.parentElement.tagName &&\n        element.parentElement.tagName.toLowerCase() === 'body')\n    ) {\n      return false;\n    }\n\n    return (\n      hasAriaProps ||\n      // hasClickStyling ||\n      hasClickHandler ||\n      hasClickListeners ||\n      // isFormRelated ||\n      isDraggable\n    );\n  }\n\n  // Helper function to check if element is visible\n  function isElementVisible(element) {\n    const style = getCachedComputedStyle(element);\n    return (\n      element.offsetWidth > 0 &&\n      element.offsetHeight > 0 &&\n      style.visibility !== 'hidden' &&\n      style.display !== 'none'\n    );\n  }\n\n  // Helper function to check if element is the top element at its position\n  function isTopElement(element) {\n    // Special case: when viewportExpansion is -1, consider all elements as \"top\" elements\n    if (viewportExpansion === -1) {\n      return true;\n    }\n\n    const rects = getCachedClientRects(element); // Replace element.getClientRects()\n\n    if (!rects || rects.length === 0) {\n      return false; // No geometry, cannot be top\n    }\n\n    let isAnyRectInViewport = false;\n    for (const rect of rects) {\n      // Use the same logic as isInExpandedViewport check\n      if (\n        rect.width > 0 &&\n        rect.height > 0 &&\n        !(\n          // Only check non-empty rects\n          (\n            rect.bottom < -viewportExpansion ||\n            rect.top > window.innerHeight + viewportExpansion ||\n            rect.right < -viewportExpansion ||\n            rect.left > window.innerWidth + viewportExpansion\n          )\n        )\n      ) {\n        isAnyRectInViewport = true;\n        break;\n      }\n    }\n\n    if (!isAnyRectInViewport) {\n      return false; // All rects are outside the viewport area\n    }\n\n    // Find the correct document context and root element\n    let doc = element.ownerDocument;\n\n    // If we're in an iframe, elements are considered top by default\n    if (doc !== window.document) {\n      return true;\n    }\n\n    // For shadow DOM, we need to check within its own root context\n    const shadowRoot = element.getRootNode();\n    if (shadowRoot instanceof ShadowRoot) {\n      const rect = getCachedBoundingRect(element);\n      const point = {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      };\n\n      try {\n        // Use shadow root's elementFromPoint to check within shadow DOM context\n        const topEl = shadowRoot.elementFromPoint(point.x, point.y);\n        if (!topEl) return false;\n\n        // Check if the element or any of its parents match our target element\n        let current = topEl;\n        while (current && current !== shadowRoot) {\n          if (current === element) return true;\n          current = current.parentElement;\n        }\n        return false;\n      } catch (e) {\n        return true; // If we can't determine, consider it visible\n      }\n    }\n\n    // Regular DOM elements\n    const rect = getCachedBoundingRect(element);\n\n    // If viewportExpansion is -1, check if element is the top one at its position\n    if (viewportExpansion === -1) {\n      return true; // Consider all elements as top elements when expansion is -1\n    }\n\n    // Calculate expanded viewport boundaries including scroll position\n    const scrollX = window.scrollX;\n    const scrollY = window.scrollY;\n    const viewportTop = -viewportExpansion + scrollY;\n    const viewportLeft = -viewportExpansion + scrollX;\n    const viewportBottom = window.innerHeight + viewportExpansion + scrollY;\n    const viewportRight = window.innerWidth + viewportExpansion + scrollX;\n\n    // Get absolute element position\n    const absTop = rect.top + scrollY;\n    const absLeft = rect.left + scrollX;\n    const absBottom = rect.bottom + scrollY;\n    const absRight = rect.right + scrollX;\n\n    // Skip if element is completely outside expanded viewport\n    if (\n      absBottom < viewportTop ||\n      absTop > viewportBottom ||\n      absRight < viewportLeft ||\n      absLeft > viewportRight\n    ) {\n      return false;\n    }\n\n    // For elements within expanded viewport, check if they're the top element\n    try {\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n\n      // Only clamp the point if it's outside the actual document\n      const point = {\n        x: centerX,\n        y: centerY,\n      };\n\n      if (\n        point.x < 0 ||\n        point.x >= window.innerWidth ||\n        point.y < 0 ||\n        point.y >= window.innerHeight\n      ) {\n        return true; // Consider elements with center outside viewport as visible\n      }\n\n      const topEl = document.elementFromPoint(point.x, point.y);\n      if (!topEl) return false;\n\n      let current = topEl;\n      while (current && current !== document.documentElement) {\n        if (current === element) return true;\n        current = current.parentElement;\n      }\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n\n  // Helper function to check if text node is visible\n  function isTextNodeVisible(textNode) {\n    const range = document.createRange();\n    range.selectNodeContents(textNode);\n    const rect = range.getBoundingClientRect();\n\n    return (\n      rect.width !== 0 &&\n      rect.height !== 0 &&\n      rect.top >= 0 &&\n      rect.top <= window.innerHeight &&\n      textNode.parentElement &&\n      textNode.parentElement.checkVisibility({\n        checkOpacity: true,\n        checkVisibilityCSS: true,\n      })\n    );\n  }\n\n  // Function to traverse the DOM and create nested JSON\n  function buildDomTree(node, parentIframe = null) {\n    DOM_CACHE.clearCache();\n\n    if (!node) return null;\n\n    // Special case for text nodes\n    if (node.nodeType === Node.TEXT_NODE) {\n      const textContent = node.textContent.trim();\n      if (textContent && isTextNodeVisible(node)) {\n        return {\n          type: 'TEXT_NODE',\n          text: textContent,\n          isVisible: true,\n        };\n      }\n      return null;\n    }\n\n    // Check if element is accepted\n    if (node.nodeType === Node.ELEMENT_NODE && !isElementAccepted(node)) {\n      return null;\n    }\n\n    const nodeData = {\n      tagName: node.tagName ? node.tagName.toLowerCase() : null,\n      attributes: {},\n      xpath:\n        node.nodeType === Node.ELEMENT_NODE ? getXPathTree(node, true) : null,\n      cssSelector:\n        node.nodeType === Node.ELEMENT_NODE ? getCssSelector(node) : null,\n      children: [],\n    };\n\n    // Add coordinates for element nodes\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const rect = node.getBoundingClientRect();\n      const scrollX = window.scrollX;\n      const scrollY = window.scrollY;\n\n      // Viewport-relative coordinates (can be negative when scrolled)\n      nodeData.viewportCoordinates = {\n        topLeft: {\n          x: Math.round(rect.left),\n          y: Math.round(rect.top),\n        },\n        topRight: {\n          x: Math.round(rect.right),\n          y: Math.round(rect.top),\n        },\n        bottomLeft: {\n          x: Math.round(rect.left),\n          y: Math.round(rect.bottom),\n        },\n        bottomRight: {\n          x: Math.round(rect.right),\n          y: Math.round(rect.bottom),\n        },\n        center: {\n          x: Math.round(rect.left + rect.width / 2),\n          y: Math.round(rect.top + rect.height / 2),\n        },\n        width: Math.round(rect.width),\n        height: Math.round(rect.height),\n      };\n\n      // Page-relative coordinates (always positive, relative to page origin)\n      nodeData.pageCoordinates = {\n        topLeft: {\n          x: Math.round(rect.left + scrollX),\n          y: Math.round(rect.top + scrollY),\n        },\n        topRight: {\n          x: Math.round(rect.right + scrollX),\n          y: Math.round(rect.top + scrollY),\n        },\n        bottomLeft: {\n          x: Math.round(rect.left + scrollX),\n          y: Math.round(rect.bottom + scrollY),\n        },\n        bottomRight: {\n          x: Math.round(rect.right + scrollX),\n          y: Math.round(rect.bottom + scrollY),\n        },\n        center: {\n          x: Math.round(rect.left + rect.width / 2 + scrollX),\n          y: Math.round(rect.top + rect.height / 2 + scrollY),\n        },\n        width: Math.round(rect.width),\n        height: Math.round(rect.height),\n      };\n\n      // Add viewport and scroll information\n      nodeData.viewport = {\n        scrollX: Math.round(scrollX),\n        scrollY: Math.round(scrollY),\n        width: window.innerWidth,\n        height: window.innerHeight,\n      };\n    }\n\n    // Copy all attributes if the node is an element\n    if (node.nodeType === Node.ELEMENT_NODE && node.attributes) {\n      // Use getAttributeNames() instead of directly iterating attributes\n      const attributeNames = node.getAttributeNames?.() || [];\n      for (const name of attributeNames) {\n        nodeData.attributes[name] = node.getAttribute(name);\n      }\n    }\n\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const isInteractive = isInteractiveElement(node);\n      const isVisible = isElementVisible(node);\n      const isTop = isTopElement(node);\n\n      nodeData.isInteractive = isInteractive;\n      nodeData.isVisible = isVisible;\n      nodeData.isTopElement = isTop;\n\n      // Highlight if element meets all criteria and highlighting is enabled\n      if (isInteractive && isVisible && isTop) {\n        nodeData.highlightIndex = highlightIndex++;\n        if (doHighlightElements) {\n          if (focusHighlightIndex >= 0) {\n            if (focusHighlightIndex === nodeData.highlightIndex) {\n              highlightElement(node, nodeData.highlightIndex, parentIframe);\n            }\n          } else {\n            highlightElement(node, nodeData.highlightIndex, parentIframe);\n          }\n        }\n      }\n    }\n\n    // Only add iframeContext if we're inside an iframe\n    // if (parentIframe) {\n    //     nodeData.iframeContext = `iframe[src=\"${parentIframe.src || ''}\"]`;\n    // }\n\n    // Only add shadowRoot field if it exists\n    if (node.shadowRoot) {\n      nodeData.shadowRoot = true;\n    }\n\n    // Handle shadow DOM\n    if (node.shadowRoot) {\n      const shadowChildren = Array.from(node.shadowRoot.childNodes).map(\n        (child) => buildDomTree(child, parentIframe),\n      );\n      nodeData.children.push(...shadowChildren);\n    }\n\n    // Handle iframes\n    if (node.tagName === 'IFRAME') {\n      try {\n        const iframeDoc = node.contentDocument || node.contentWindow.document;\n        if (iframeDoc) {\n          const iframeChildren = Array.from(iframeDoc.body.childNodes).map(\n            (child) => buildDomTree(child, node),\n          );\n          nodeData.children.push(...iframeChildren);\n        }\n      } catch (e) {\n        console.warn('Unable to access iframe:', node);\n      }\n    } else {\n      const children = Array.from(node.childNodes).map((child) =>\n        buildDomTree(child, parentIframe),\n      );\n      nodeData.children.push(...children);\n    }\n\n    return nodeData;\n  }\n\n  return buildDomTree(document.body);\n};\n";
    if (injectedScript) return injectedScript;
    return external_fs_["default"].readFileSync(external_path_["default"].join(__dirname, '../assets/buildDomTree.js'), 'utf8');
};
function views_define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class DOMBaseNode {
    constructor(isVisible, parent){
        views_define_property(this, "isVisible", void 0);
        views_define_property(this, "parent", void 0);
        this.isVisible = isVisible;
        this.parent = parent;
    }
}
class DOMTextNode extends DOMBaseNode {
    hasParentWithHighlightIndex() {
        let current = this.parent;
        while(null != current){
            if (void 0 !== current.highlightIndex) return true;
            current = current.parent;
        }
        return false;
    }
    constructor(text, isVisible, parent){
        super(isVisible, parent), views_define_property(this, "type", 'TEXT_NODE'), views_define_property(this, "text", void 0);
        this.text = text;
    }
}
class DOMElementNode extends DOMBaseNode {
    getAllTextTillNextClickableElement(maxDepth = -1) {
        const textParts = [];
        const collectText = (node, currentDepth)=>{
            if (-1 !== maxDepth && currentDepth > maxDepth) return;
            if (node instanceof DOMElementNode && node !== this && void 0 !== node.highlightIndex) return;
            if (node instanceof DOMTextNode) textParts.push(node.text);
            else if (node instanceof DOMElementNode) for (const child of node.children)collectText(child, currentDepth + 1);
        };
        collectText(this, 0);
        return textParts.join('\n').trim();
    }
    clickableElementsToString(includeAttributes = []) {
        const formattedText = [];
        const processNode = (node, depth)=>{
            if (node instanceof DOMElementNode) {
                if (void 0 !== node.highlightIndex) {
                    let attributesStr = '';
                    if (includeAttributes.length) attributesStr = ` ${includeAttributes.map((key)=>node.attributes[key] ? `${key}="${node.attributes[key]}"` : '').filter(Boolean).join(' ')}`;
                    formattedText.push(`[${node.highlightIndex}]<${node.tagName}${attributesStr}>${node.getAllTextTillNextClickableElement()}</${node.tagName}>`);
                }
                for (const child of node.children)processNode(child, depth + 1);
            } else if (node instanceof DOMTextNode) {
                if (!node.hasParentWithHighlightIndex()) formattedText.push(`[]${node.text}`);
            }
        };
        processNode(this, 0);
        return formattedText.join('\n');
    }
    getFileUploadElement(checkSiblings = true) {
        if ('input' === this.tagName && 'file' === this.attributes['type']) return this;
        for (const child of this.children)if (child instanceof DOMElementNode) {
            const result = child.getFileUploadElement(false);
            if (result) return result;
        }
        if (checkSiblings && this.parent) {
            for (const sibling of this.parent.children)if (sibling !== this && sibling instanceof DOMElementNode) {
                const result = sibling.getFileUploadElement(false);
                if (result) return result;
            }
        }
        return null;
    }
    getAdvancedCssSelector() {
        return this.enhancedCssSelectorForElement();
    }
    convertSimpleXPathToCssSelector(xpath) {
        if (!xpath) return '';
        const cleanXpath = xpath.replace(/^\//, '');
        const parts = cleanXpath.split('/');
        const cssParts = [];
        for (const part of parts)if (!!part) {
            if (part.includes('[')) {
                const bracketIndex = part.indexOf('[');
                let basePart = part.substring(0, bracketIndex);
                const indexPart = part.substring(bracketIndex);
                const indices = indexPart.split(']').slice(0, -1).map((i)=>i.replace('[', ''));
                for (const idx of indices)if (/^\d+$/.test(idx)) try {
                    const index = Number.parseInt(idx, 10) - 1;
                    basePart += `:nth-of-type(${index + 1})`;
                } catch (error) {}
                else if ('last()' === idx) basePart += ':last-of-type';
                else if (idx.includes('position()')) {
                    if (idx.includes('>1')) basePart += ':nth-of-type(n+2)';
                }
                cssParts.push(basePart);
            } else cssParts.push(part);
        }
        const baseSelector = cssParts.join(' > ');
        return baseSelector;
    }
    enhancedCssSelectorForElement(includeDynamicAttributes = true) {
        try {
            if (!this.xpath) return '';
            let cssSelector = this.convertSimpleXPathToCssSelector(this.xpath);
            if (this.attributes['class'] && includeDynamicAttributes) {
                const validClassNamePattern = /^[a-zA-Z_][a-zA-Z0-9_-]*$/;
                const classes = this.attributes['class'].split(/\s+/);
                for (const className of classes)if (!!className.trim()) {
                    if (validClassNamePattern.test(className)) cssSelector += `.${className}`;
                }
            }
            const SAFE_ATTRIBUTES = new Set([
                'id',
                'name',
                'type',
                'value',
                'placeholder',
                'aria-label',
                'aria-labelledby',
                'aria-describedby',
                'role',
                'for',
                'autocomplete',
                'required',
                'readonly',
                'alt',
                'title',
                'src',
                'href',
                'target'
            ]);
            if (includeDynamicAttributes) {
                SAFE_ATTRIBUTES.add('data-id');
                SAFE_ATTRIBUTES.add('data-qa');
                SAFE_ATTRIBUTES.add('data-cy');
                SAFE_ATTRIBUTES.add('data-testid');
            }
            for (const [attribute, value] of Object.entries(this.attributes)){
                if ('class' === attribute) continue;
                if (!attribute.trim()) continue;
                if (!SAFE_ATTRIBUTES.has(attribute)) continue;
                const safeAttribute = attribute.replace(':', '\\:');
                if ('' === value) cssSelector += `[${safeAttribute}]`;
                else if (/["'<>`\n\r\t]/.test(value)) {
                    const collapsedValue = value.replace(/\s+/g, ' ').trim();
                    const safeValue = collapsedValue.replace(/"/g, '\\"');
                    cssSelector += `[${safeAttribute}*="${safeValue}"]`;
                } else cssSelector += `[${safeAttribute}="${value}"]`;
            }
            return cssSelector;
        } catch (error) {
            const tagName = this.tagName || '*';
            return `${tagName}[highlight-index='${this.highlightIndex}']`;
        }
    }
    constructor(params){
        super(params.isVisible, params.parent), views_define_property(this, "tagName", void 0), views_define_property(this, "xpath", void 0), views_define_property(this, "cssSelector", void 0), views_define_property(this, "attributes", void 0), views_define_property(this, "children", void 0), views_define_property(this, "isInteractive", void 0), views_define_property(this, "isTopElement", void 0), views_define_property(this, "shadowRoot", void 0), views_define_property(this, "highlightIndex", void 0), views_define_property(this, "viewportCoordinates", void 0), views_define_property(this, "pageCoordinates", void 0), views_define_property(this, "viewportInfo", void 0);
        this.tagName = params.tagName;
        this.xpath = params.xpath;
        this.cssSelector = params.cssSelector;
        this.attributes = params.attributes;
        this.children = params.children;
        this.isInteractive = params.isInteractive ?? false;
        this.isTopElement = params.isTopElement ?? false;
        this.shadowRoot = params.shadowRoot ?? false;
        this.highlightIndex = params.highlightIndex;
        this.viewportCoordinates = params.viewportCoordinates;
        this.pageCoordinates = params.pageCoordinates;
        this.viewportInfo = params.viewportInfo;
    }
}
const service_logger = createLogger('DOMService');
function createSelectorMap(elementTree) {
    const selectorMap = new Map();
    function processNode(node) {
        if (node instanceof DOMElementNode) {
            if (null != node.highlightIndex) selectorMap.set(node.highlightIndex, node);
            node.children.forEach(processNode);
        }
    }
    processNode(elementTree);
    return selectorMap;
}
function parseNode(nodeData, parent = null) {
    if (!nodeData) return null;
    if ('type' in nodeData) return new DOMTextNode(nodeData.text, nodeData.isVisible, parent);
    const tagName = nodeData.tagName;
    const viewportCoordinates = nodeData.viewportCoordinates;
    const pageCoordinates = nodeData.pageCoordinates;
    const viewportInfo = nodeData.viewportInfo;
    const elementNode = new DOMElementNode({
        tagName: tagName,
        xpath: nodeData.xpath,
        cssSelector: nodeData.cssSelector,
        attributes: nodeData.attributes ?? {},
        children: [],
        isVisible: nodeData.isVisible ?? false,
        isInteractive: nodeData.isInteractive ?? false,
        isTopElement: nodeData.isTopElement ?? false,
        highlightIndex: nodeData.highlightIndex,
        viewportCoordinates: viewportCoordinates ?? void 0,
        pageCoordinates: pageCoordinates ?? void 0,
        viewportInfo: viewportInfo ?? void 0,
        shadowRoot: nodeData.shadowRoot ?? false,
        parent
    });
    const children = [];
    for (const child of nodeData.children || [])if (null !== child) {
        const childNode = parseNode(child, elementNode);
        if (null !== childNode) children.push(childNode);
    }
    elementNode.children = children;
    return elementNode;
}
async function removeHighlights(page) {
    try {
        await page.evaluate(()=>{
            const container = document.getElementById('playwright-highlight-container');
            if (container) container.remove();
            const highlightedElements = document.querySelectorAll('[browser-user-highlight-id^="playwright-highlight-"]');
            for (const el of Array.from(highlightedElements))el.removeAttribute('browser-user-highlight-id');
        });
    } catch (error) {
        service_logger.error('Failed to remove highlights:', error);
    }
}
async function scrollIntoViewIfNeeded(element, timeout = 2500) {
    const startTime = Date.now();
    while(true){
        const isVisible = await element.evaluate((el)=>{
            const rect = el.getBoundingClientRect();
            if (0 === rect.width || 0 === rect.height) return false;
            const style = window.getComputedStyle(el);
            if ('hidden' === style.visibility || 'none' === style.display || '0' === style.opacity) return false;
            const isInViewport = rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
            if (!isInViewport) {
                el.scrollIntoView({
                    behavior: 'auto',
                    block: 'center',
                    inline: 'center'
                });
                return false;
            }
            return true;
        });
        if (isVisible) break;
        if (Date.now() - startTime > timeout) throw new Error('Timed out while trying to scroll element into view');
        await new Promise((resolve)=>setTimeout(resolve, 100));
    }
}
async function locateElement(page, element, _options) {
    const options = {
        ...DEFAULT_BROWSER_CONTEXT_CONFIG,
        ..._options
    };
    if (!page) {
        console.warn('Puppeteer is not connected');
        return null;
    }
    let currentFrame = page;
    const parents = [];
    let current = element;
    while(current.parent){
        parents.push(current.parent);
        current = current.parent;
    }
    const iframes = parents.reverse().filter((item)=>'iframe' === item.tagName);
    for (const parent of iframes){
        const cssSelector = parent.enhancedCssSelectorForElement(options.includeDynamicAttributes);
        const frameElement = await currentFrame.$(cssSelector);
        if (!frameElement) {
            console.warn(`Could not find iframe with selector: ${cssSelector}`);
            return null;
        }
        const frame = await frameElement.contentFrame();
        if (!frame) {
            console.warn(`Could not access frame content for selector: ${cssSelector}`);
            return null;
        }
        currentFrame = frame;
    }
    const cssSelector = element.enhancedCssSelectorForElement(options.includeDynamicAttributes);
    try {
        const elementHandle = await currentFrame.$(cssSelector);
        if (elementHandle) {
            await scrollIntoViewIfNeeded(elementHandle);
            return elementHandle;
        }
    } catch (error) {
        console.error('Failed to locate element:', error);
    }
    return null;
}
createLogger('Page');
createLogger('BrowserContext');
lib.z.object({
    page_summary: lib.z.string(),
    evaluation_previous_goal: lib.z.string(),
    memory: lib.z.string(),
    next_goal: lib.z.string()
});
__webpack_require__("../../../../node_modules/@langchain/core/dist/messages/index.js");
createLogger('agent');
lib.z.object({
    text: lib.z.string()
});
lib.z.object({
    query: lib.z.string()
});
lib.z.object({
    url: lib.z.string()
});
lib.z.object({});
lib.z.object({
    desc: lib.z.string().optional(),
    index: lib.z.number(),
    xpath: lib.z.string().optional()
});
lib.z.object({
    desc: lib.z.string().optional(),
    index: lib.z.number(),
    text: lib.z.string(),
    xpath: lib.z.string().optional()
});
lib.z.object({
    tab_id: lib.z.number()
});
lib.z.object({
    url: lib.z.string()
});
lib.z.object({
    goal: lib.z.string()
});
lib.z.object({
    content: lib.z.string()
});
lib.z.object({
    desc: lib.z.string().optional(),
    amount: lib.z.number().optional()
});
lib.z.object({
    desc: lib.z.string().optional(),
    amount: lib.z.number().optional()
});
lib.z.object({
    desc: lib.z.string().optional(),
    keys: lib.z.string()
});
lib.z.object({
    desc: lib.z.string().optional(),
    text: lib.z.string()
});
lib.z.object({
    index: lib.z.number()
});
lib.z.object({
    index: lib.z.number(),
    text: lib.z.string()
});
var prompts_base = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/base.js");
var chat = __webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/chat.js");
__webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/few_shot.js");
class PipelinePromptTemplate extends prompts_base.d {
    static lc_name() {
        return "PipelinePromptTemplate";
    }
    constructor(input){
        super({
            ...input,
            inputVariables: []
        });
        Object.defineProperty(this, "pipelinePrompts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "finalPrompt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.pipelinePrompts = input.pipelinePrompts;
        this.finalPrompt = input.finalPrompt;
        this.inputVariables = this.computeInputValues();
    }
    computeInputValues() {
        const intermediateValues = this.pipelinePrompts.map((pipelinePrompt)=>pipelinePrompt.name);
        const inputValues = this.pipelinePrompts.map((pipelinePrompt)=>pipelinePrompt.prompt.inputVariables.filter((inputValue)=>!intermediateValues.includes(inputValue))).flat();
        return [
            ...new Set(inputValues)
        ];
    }
    static extractRequiredInputValues(allValues, requiredValueNames) {
        return requiredValueNames.reduce((requiredValues, valueName)=>{
            requiredValues[valueName] = allValues[valueName];
            return requiredValues;
        }, {});
    }
    async formatPipelinePrompts(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this.pipelinePrompts){
            const pipelinePromptInputValues = PipelinePromptTemplate.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);
            if (pipelinePrompt instanceof chat.ks) allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);
            else allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);
        }
        return PipelinePromptTemplate.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);
    }
    async formatPromptValue(values) {
        return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));
    }
    async format(values) {
        return this.finalPrompt.format(await this.formatPipelinePrompts(values));
    }
    async partial(values) {
        const promptDict = {
            ...this
        };
        promptDict.inputVariables = this.inputVariables.filter((iv)=>!(iv in values));
        promptDict.partialVariables = {
            ...this.partialVariables ?? {},
            ...values
        };
        return new PipelinePromptTemplate(promptDict);
    }
    serialize() {
        throw new Error("Not implemented.");
    }
    _getPromptType() {
        return "pipeline";
    }
}
__webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/prompt.js");
__webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/string.js");
__webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/template.js");
__webpack_require__("../../../../node_modules/@langchain/core/dist/prompts/image.js");
function isWithStructuredOutput(x) {
    return "object" == typeof x && null != x && "withStructuredOutput" in x && "function" == typeof x.withStructuredOutput;
}
function isRunnableBinding(x) {
    return "object" == typeof x && null != x && "lc_id" in x && Array.isArray(x.lc_id) && "langchain_core/runnables/RunnableBinding" === x.lc_id.join("/");
}
class StructuredPrompt extends chat.ks {
    get lc_aliases() {
        return {
            ...super.lc_aliases,
            schema: "schema_"
        };
    }
    constructor(input){
        super(input);
        Object.defineProperty(this, "schema", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lc_namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "langchain_core",
                "prompts",
                "structured"
            ]
        });
        this.schema = input.schema;
    }
    pipe(coerceable) {
        if (isWithStructuredOutput(coerceable)) return super.pipe(coerceable.withStructuredOutput(this.schema));
        if (isRunnableBinding(coerceable) && isWithStructuredOutput(coerceable.bound)) return super.pipe(coerceable.bound.withStructuredOutput(this.schema).bind(coerceable.kwargs ?? {}).withConfig(coerceable.config));
        throw new Error('Structured prompts need to be piped to a language model that supports the "withStructuredOutput()" method.');
    }
    static fromMessagesAndSchema(promptMessages, schema) {
        return StructuredPrompt.fromMessages(promptMessages, {
            schema
        });
    }
}
createLogger('Action');
createLogger('NavigatorAgent');
createLogger('PlannerAgent');
lib.z.object({
    observation: lib.z.string(),
    challenges: lib.z.string(),
    done: lib.z.boolean(),
    next_steps: lib.z.string(),
    reasoning: lib.z.string(),
    web_task: lib.z.boolean()
});
createLogger('ValidatorAgent');
lib.z.object({
    is_valid: lib.z.boolean(),
    reason: lib.z.string(),
    answer: lib.z.string()
});
createLogger('agent/prompts/base');
const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
function addErrorMessage(res, key, errorMessage, refs) {
    if (!refs?.errorMessages) return;
    if (errorMessage) res.errorMessage = {
        ...res.errorMessage,
        [key]: errorMessage
    };
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
}
function parseAnyDef() {
    return {};
}
function parseArrayDef(def, refs) {
    const res = {
        type: "array"
    };
    if (def.type?._def && def.type?._def?.typeName !== lib.pA.ZodAny) res.items = parseDef(def.type._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items"
        ]
    });
    if (def.minLength) setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    if (def.maxLength) setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    if (def.exactLength) {
        setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
        setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
}
function parseBigintDef(def, refs) {
    const res = {
        type: "integer",
        format: "int64"
    };
    if (!def.checks) return res;
    for (const check of def.checks)switch(check.kind){
        case "min":
            if ("jsonSchema7" === refs.target) check.inclusive ? setResponseValueAndErrors(res, "minimum", check.value, check.message, refs) : setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
            else {
                if (!check.inclusive) res.exclusiveMinimum = true;
                setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            }
            break;
        case "max":
            if ("jsonSchema7" === refs.target) check.inclusive ? setResponseValueAndErrors(res, "maximum", check.value, check.message, refs) : setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
            else {
                if (!check.inclusive) res.exclusiveMaximum = true;
                setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            }
            break;
        case "multipleOf":
            setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
            break;
    }
    return res;
}
function parseBooleanDef() {
    return {
        type: "boolean"
    };
}
function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}
const parseCatchDef = (def, refs)=>parseDef(def.innerType._def, refs);
function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) return {
        anyOf: strategy.map((item, i)=>parseDateDef(def, refs, item))
    };
    switch(strategy){
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return integerDateParser(def, refs);
    }
}
const integerDateParser = (def, refs)=>{
    const res = {
        type: "integer",
        format: "unix-time"
    };
    if ("openApi3" === refs.target) return res;
    for (const check of def.checks)switch(check.kind){
        case "min":
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            break;
        case "max":
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            break;
    }
    return res;
};
function parseDefaultDef(_def, refs) {
    return {
        ...parseDef(_def.innerType._def, refs),
        default: _def.defaultValue()
    };
}
function parseEffectsDef(_def, refs) {
    return "input" === refs.effectStrategy ? parseDef(_def.schema._def, refs) : {};
}
function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values)
    };
}
const isJsonSchema7AllOfType = (type)=>{
    if ("type" in type && "string" === type.type) return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "0"
            ]
        }),
        parseDef(def.right._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "1"
            ]
        })
    ].filter((x)=>!!x);
    let unevaluatedProperties = "jsonSchema2019-09" === refs.target ? {
        unevaluatedProperties: false
    } : void 0;
    const mergedAllOf = [];
    allOf.forEach((schema)=>{
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
            if (void 0 === schema.unevaluatedProperties) unevaluatedProperties = void 0;
        } else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema && false === schema.additionalProperties) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            } else unevaluatedProperties = void 0;
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length ? {
        allOf: mergedAllOf,
        ...unevaluatedProperties
    } : void 0;
}
function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if ("bigint" !== parsedType && "number" !== parsedType && "boolean" !== parsedType && "string" !== parsedType) return {
        type: Array.isArray(def.value) ? "array" : "object"
    };
    if ("openApi3" === refs.target) return {
        type: "bigint" === parsedType ? "integer" : parsedType,
        enum: [
            def.value
        ]
    };
    return {
        type: "bigint" === parsedType ? "integer" : parsedType,
        const: def.value
    };
}
let emojiRegex;
const zodPatterns = {
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    emoji: ()=>{
        if (void 0 === emojiRegex) emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        return emojiRegex;
    },
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
    const res = {
        type: "string"
    };
    if (def.checks) for (const check of def.checks)switch(check.kind){
        case "min":
            setResponseValueAndErrors(res, "minLength", "number" == typeof res.minLength ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            break;
        case "max":
            setResponseValueAndErrors(res, "maxLength", "number" == typeof res.maxLength ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
        case "email":
            switch(refs.emailStrategy){
                case "format:email":
                    addFormat(res, "email", check.message, refs);
                    break;
                case "format:idn-email":
                    addFormat(res, "idn-email", check.message, refs);
                    break;
                case "pattern:zod":
                    addPattern(res, zodPatterns.email, check.message, refs);
                    break;
            }
            break;
        case "url":
            addFormat(res, "uri", check.message, refs);
            break;
        case "uuid":
            addFormat(res, "uuid", check.message, refs);
            break;
        case "regex":
            addPattern(res, check.regex, check.message, refs);
            break;
        case "cuid":
            addPattern(res, zodPatterns.cuid, check.message, refs);
            break;
        case "cuid2":
            addPattern(res, zodPatterns.cuid2, check.message, refs);
            break;
        case "startsWith":
            addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
            break;
        case "endsWith":
            addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
            break;
        case "datetime":
            addFormat(res, "date-time", check.message, refs);
            break;
        case "date":
            addFormat(res, "date", check.message, refs);
            break;
        case "time":
            addFormat(res, "time", check.message, refs);
            break;
        case "duration":
            addFormat(res, "duration", check.message, refs);
            break;
        case "length":
            setResponseValueAndErrors(res, "minLength", "number" == typeof res.minLength ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            setResponseValueAndErrors(res, "maxLength", "number" == typeof res.maxLength ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
        case "includes":
            addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
            break;
        case "ip":
            if ("v6" !== check.version) addFormat(res, "ipv4", check.message, refs);
            if ("v4" !== check.version) addFormat(res, "ipv6", check.message, refs);
            break;
        case "base64url":
            addPattern(res, zodPatterns.base64url, check.message, refs);
            break;
        case "jwt":
            addPattern(res, zodPatterns.jwt, check.message, refs);
            break;
        case "cidr":
            if ("v6" !== check.version) addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
            if ("v4" !== check.version) addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
            break;
        case "emoji":
            addPattern(res, zodPatterns.emoji(), check.message, refs);
            break;
        case "ulid":
            addPattern(res, zodPatterns.ulid, check.message, refs);
            break;
        case "base64":
            switch(refs.base64Strategy){
                case "format:binary":
                    addFormat(res, "binary", check.message, refs);
                    break;
                case "contentEncoding:base64":
                    setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                    break;
                case "pattern:zod":
                    addPattern(res, zodPatterns.base64, check.message, refs);
                    break;
            }
            break;
        case "nanoid":
            addPattern(res, zodPatterns.nanoid, check.message, refs);
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
            break;
        default:
            ((_)=>{})(0);
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return "escape" === refs.patternStrategy ? escapeNonAlphaNumeric(literal) : literal;
}
const ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for(let i = 0; i < source.length; i++){
        if (!ALPHA_NUMERIC.has(source[i])) result += "\\";
        result += source[i];
    }
    return result;
}
function addFormat(schema, value, message, refs) {
    if (schema.format || schema.anyOf?.some((x)=>x.format)) {
        if (!schema.anyOf) schema.anyOf = [];
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format,
                ...schema.errorMessage && refs.errorMessages && {
                    errorMessage: {
                        format: schema.errorMessage.format
                    }
                }
            });
            delete schema.format;
            if (schema.errorMessage) {
                delete schema.errorMessage.format;
                if (0 === Object.keys(schema.errorMessage).length) delete schema.errorMessage;
            }
        }
        schema.anyOf.push({
            format: value,
            ...message && refs.errorMessages && {
                errorMessage: {
                    format: message
                }
            }
        });
    } else setResponseValueAndErrors(schema, "format", value, message, refs);
}
function addPattern(schema, regex, message, refs) {
    if (schema.pattern || schema.allOf?.some((x)=>x.pattern)) {
        if (!schema.allOf) schema.allOf = [];
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern,
                ...schema.errorMessage && refs.errorMessages && {
                    errorMessage: {
                        pattern: schema.errorMessage.pattern
                    }
                }
            });
            delete schema.pattern;
            if (schema.errorMessage) {
                delete schema.errorMessage.pattern;
                if (0 === Object.keys(schema.errorMessage).length) delete schema.errorMessage;
            }
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags(regex, refs),
            ...message && refs.errorMessages && {
                errorMessage: {
                    pattern: message
                }
            }
        });
    } else setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
}
function stringifyRegExpWithFlags(regex, refs) {
    if (!refs.applyRegexFlags || !regex.flags) return regex.source;
    const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s")
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for(let i = 0; i < source.length; i++){
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    } else if ("-" === source[i + 1] && source[i + 2]?.match(/[a-z]/)) {
                        pattern += source[i];
                        inCharRange = true;
                    } else pattern += `${source[i]}${source[i].toUpperCase()}`;
                    continue;
                }
            } else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if ("^" === source[i]) {
                pattern += `(^|(?<=[\r\n]))`;
                continue;
            }
            if ("$" === source[i]) {
                pattern += `($|(?=[\r\n]))`;
                continue;
            }
        }
        if (flags.s && "." === source[i]) {
            pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
            continue;
        }
        pattern += source[i];
        if ("\\" === source[i]) isEscaped = true;
        else if (inCharGroup && "]" === source[i]) inCharGroup = false;
        else if (!inCharGroup && "[" === source[i]) inCharGroup = true;
    }
    try {
        new RegExp(pattern);
    } catch  {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex.source;
    }
    return pattern;
}
function parseRecordDef(def, refs) {
    if ("openAi" === refs.target) console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    if ("openApi3" === refs.target && def.keyType?._def.typeName === lib.pA.ZodEnum) return {
        type: "object",
        required: def.keyType._def.values,
        properties: def.keyType._def.values.reduce((acc, key)=>({
                ...acc,
                [key]: parseDef(def.valueType._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "properties",
                        key
                    ]
                }) ?? {}
            }), {}),
        additionalProperties: false
    };
    const schema = {
        type: "object",
        additionalProperties: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        }) ?? {}
    };
    if ("openApi3" === refs.target) return schema;
    if (def.keyType?._def.typeName === lib.pA.ZodString && def.keyType._def.checks?.length) {
        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    }
    if (def.keyType?._def.typeName === lib.pA.ZodEnum) return {
        ...schema,
        propertyNames: {
            enum: def.keyType._def.values
        }
    };
    if (def.keyType?._def.typeName === lib.pA.ZodBranded && def.keyType._def.type._def.typeName === lib.pA.ZodString && def.keyType._def.type._def.checks?.length) {
        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    }
    return schema;
}
function parseMapDef(def, refs) {
    if ("record" === refs.mapStrategy) return parseRecordDef(def, refs);
    const keys = parseDef(def.keyType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "0"
        ]
    }) || {};
    const values = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "1"
        ]
    }) || {};
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [
                keys,
                values
            ],
            minItems: 2,
            maxItems: 2
        }
    };
}
function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key)=>"number" != typeof object[object[key]]);
    const actualValues = actualKeys.map((key)=>object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values)=>typeof values)));
    return {
        type: 1 === parsedTypes.length ? "string" === parsedTypes[0] ? "string" : "number" : [
            "string",
            "number"
        ],
        enum: actualValues
    };
}
function parseNeverDef() {
    return {
        not: {}
    };
}
function parseNullDef(refs) {
    return "openApi3" === refs.target ? {
        enum: [
            "null"
        ],
        nullable: true
    } : {
        type: "null"
    };
}
const primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};
function parseUnionDef(def, refs) {
    if ("openApi3" === refs.target) return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x)=>x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types, x)=>{
            const type = primitiveMappings[x._def.typeName];
            return type && !types.includes(type) ? [
                ...types,
                type
            ] : types;
        }, []);
        return {
            type: types.length > 1 ? types : types[0]
        };
    }
    if (options.every((x)=>"ZodLiteral" === x._def.typeName && !x.description)) {
        const types = options.reduce((acc, x)=>{
            const type = typeof x._def.value;
            switch(type){
                case "string":
                case "number":
                case "boolean":
                    return [
                        ...acc,
                        type
                    ];
                case "bigint":
                    return [
                        ...acc,
                        "integer"
                    ];
                case "object":
                    if (null === x._def.value) return [
                        ...acc,
                        "null"
                    ];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            const uniqueTypes = types.filter((x, i, a)=>a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x)=>acc.includes(x._def.value) ? acc : [
                        ...acc,
                        x._def.value
                    ], [])
            };
        }
    } else if (options.every((x)=>"ZodEnum" === x._def.typeName)) return {
        type: "string",
        enum: options.reduce((acc, x)=>[
                ...acc,
                ...x._def.values.filter((x)=>!acc.includes(x))
            ], [])
    };
    return asAnyOf(def, refs);
}
const asAnyOf = (def, refs)=>{
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i)=>parseDef(x._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "anyOf",
                `${i}`
            ]
        })).filter((x)=>!!x && (!refs.strictUnions || "object" == typeof x && Object.keys(x).length > 0));
    return anyOf.length ? {
        anyOf
    } : void 0;
};
function parseNullableDef(def, refs) {
    if ([
        "ZodString",
        "ZodNumber",
        "ZodBigInt",
        "ZodBoolean",
        "ZodNull"
    ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        if ("openApi3" === refs.target) return {
            type: primitiveMappings[def.innerType._def.typeName],
            nullable: true
        };
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null"
            ]
        };
    }
    if ("openApi3" === refs.target) {
        const base = parseDef(def.innerType._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath
            ]
        });
        if (base && "$ref" in base) return {
            allOf: [
                base
            ],
            nullable: true
        };
        return base && {
            ...base,
            nullable: true
        };
    }
    const base = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "0"
        ]
    });
    return base && {
        anyOf: [
            base,
            {
                type: "null"
            }
        ]
    };
}
function parseNumberDef(def, refs) {
    const res = {
        type: "number"
    };
    if (!def.checks) return res;
    for (const check of def.checks)switch(check.kind){
        case "int":
            res.type = "integer";
            addErrorMessage(res, "type", check.message, refs);
            break;
        case "min":
            if ("jsonSchema7" === refs.target) check.inclusive ? setResponseValueAndErrors(res, "minimum", check.value, check.message, refs) : setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
            else {
                if (!check.inclusive) res.exclusiveMinimum = true;
                setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            }
            break;
        case "max":
            if ("jsonSchema7" === refs.target) check.inclusive ? setResponseValueAndErrors(res, "maximum", check.value, check.message, refs) : setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
            else {
                if (!check.inclusive) res.exclusiveMaximum = true;
                setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            }
            break;
        case "multipleOf":
            setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
            break;
    }
    return res;
}
function decideAdditionalProperties(def, refs) {
    if ("strict" === refs.removeAdditionalStrategy) return "ZodNever" === def.catchall._def.typeName ? "strict" !== def.unknownKeys : parseDef(def.catchall._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "additionalProperties"
        ]
    }) ?? true;
    return "ZodNever" === def.catchall._def.typeName ? "passthrough" === def.unknownKeys : parseDef(def.catchall._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "additionalProperties"
        ]
    }) ?? true;
}
function parseObjectDef(def, refs) {
    const forceOptionalIntoNullable = "openAi" === refs.target;
    const result = {
        type: "object",
        ...Object.entries(def.shape()).reduce((acc, [propName, propDef])=>{
            if (void 0 === propDef || void 0 === propDef._def) return acc;
            let propOptional = propDef.isOptional();
            if (propOptional && forceOptionalIntoNullable) {
                if (propDef instanceof lib.ak) propDef = propDef._def.innerType;
                if (!propDef.isNullable()) propDef = propDef.nullable();
                propOptional = false;
            }
            const parsedDef = parseDef(propDef._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "properties",
                    propName
                ],
                propertyPath: [
                    ...refs.currentPath,
                    "properties",
                    propName
                ]
            });
            if (void 0 === parsedDef) return acc;
            return {
                properties: {
                    ...acc.properties,
                    [propName]: parsedDef
                },
                required: propOptional ? acc.required : [
                    ...acc.required,
                    propName
                ]
            };
        }, {
            properties: {},
            required: []
        }),
        additionalProperties: decideAdditionalProperties(def, refs)
    };
    if (!result.required.length) delete result.required;
    return result;
}
const parseOptionalDef = (def, refs)=>{
    if (refs.currentPath.toString() === refs.propertyPath?.toString()) return parseDef(def.innerType._def, refs);
    const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "1"
        ]
    });
    return innerSchema ? {
        anyOf: [
            {
                not: {}
            },
            innerSchema
        ]
    } : {};
};
const parsePipelineDef = (def, refs)=>{
    if ("input" === refs.pipeStrategy) return parseDef(def.in._def, refs);
    if ("output" === refs.pipeStrategy) return parseDef(def.out._def, refs);
    const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            "0"
        ]
    });
    const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            a ? "1" : "0"
        ]
    });
    return {
        allOf: [
            a,
            b
        ].filter((x)=>void 0 !== x)
    };
};
function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items"
        ]
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items
    };
    if (def.minSize) setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    if (def.maxSize) setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    return schema;
}
function parseTupleDef(def, refs) {
    if (def.rest) return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x, i)=>parseDef(x._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "items",
                    `${i}`
                ]
            })).reduce((acc, x)=>void 0 === x ? acc : [
                ...acc,
                x
            ], []),
        additionalItems: parseDef(def.rest._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalItems"
            ]
        })
    };
    return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x, i)=>parseDef(x._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "items",
                    `${i}`
                ]
            })).reduce((acc, x)=>void 0 === x ? acc : [
                ...acc,
                x
            ], [])
    };
}
function parseUndefinedDef() {
    return {
        not: {}
    };
}
function parseUnknownDef() {
    return {};
}
const parseReadonlyDef = (def, refs)=>parseDef(def.innerType._def, refs);
const selectParser = (def, typeName, refs)=>{
    switch(typeName){
        case lib.pA.ZodString:
            return parseStringDef(def, refs);
        case lib.pA.ZodNumber:
            return parseNumberDef(def, refs);
        case lib.pA.ZodObject:
            return parseObjectDef(def, refs);
        case lib.pA.ZodBigInt:
            return parseBigintDef(def, refs);
        case lib.pA.ZodBoolean:
            return parseBooleanDef();
        case lib.pA.ZodDate:
            return parseDateDef(def, refs);
        case lib.pA.ZodUndefined:
            return parseUndefinedDef();
        case lib.pA.ZodNull:
            return parseNullDef(refs);
        case lib.pA.ZodArray:
            return parseArrayDef(def, refs);
        case lib.pA.ZodUnion:
        case lib.pA.ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case lib.pA.ZodIntersection:
            return parseIntersectionDef(def, refs);
        case lib.pA.ZodTuple:
            return parseTupleDef(def, refs);
        case lib.pA.ZodRecord:
            return parseRecordDef(def, refs);
        case lib.pA.ZodLiteral:
            return parseLiteralDef(def, refs);
        case lib.pA.ZodEnum:
            return parseEnumDef(def);
        case lib.pA.ZodNativeEnum:
            return parseNativeEnumDef(def);
        case lib.pA.ZodNullable:
            return parseNullableDef(def, refs);
        case lib.pA.ZodOptional:
            return parseOptionalDef(def, refs);
        case lib.pA.ZodMap:
            return parseMapDef(def, refs);
        case lib.pA.ZodSet:
            return parseSetDef(def, refs);
        case lib.pA.ZodLazy:
            return ()=>def.getter()._def;
        case lib.pA.ZodPromise:
            return parsePromiseDef(def, refs);
        case lib.pA.ZodNaN:
        case lib.pA.ZodNever:
            return parseNeverDef();
        case lib.pA.ZodEffects:
            return parseEffectsDef(def, refs);
        case lib.pA.ZodAny:
            return parseAnyDef();
        case lib.pA.ZodUnknown:
            return parseUnknownDef();
        case lib.pA.ZodDefault:
            return parseDefaultDef(def, refs);
        case lib.pA.ZodBranded:
            return parseBrandedDef(def, refs);
        case lib.pA.ZodReadonly:
            return parseReadonlyDef(def, refs);
        case lib.pA.ZodCatch:
            return parseCatchDef(def, refs);
        case lib.pA.ZodPipeline:
            return parsePipelineDef(def, refs);
        case lib.pA.ZodFunction:
        case lib.pA.ZodVoid:
        case lib.pA.ZodSymbol:
            return;
        default:
            return ((_)=>void 0)(0);
    }
};
function parseDef(def, refs, forceResolution = false) {
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) return overrideResult;
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (void 0 !== seenSchema) return seenSchema;
    }
    const newItem = {
        def,
        path: refs.currentPath,
        jsonSchema: void 0
    };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema = "function" == typeof jsonSchemaOrGetter ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema) addMeta(def, refs, jsonSchema);
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema, def, refs);
        newItem.jsonSchema = jsonSchema;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
}
const get$ref = (item, refs)=>{
    switch(refs.$refStrategy){
        case "root":
            return {
                $ref: item.path.join("/")
            };
        case "relative":
            return {
                $ref: getRelativePath(refs.currentPath, item.path)
            };
        case "none":
        case "seen":
            if (item.path.length < refs.currentPath.length && item.path.every((value, index)=>refs.currentPath[index] === value)) {
                console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                return {};
            }
            return "seen" === refs.$refStrategy ? {} : void 0;
    }
};
const getRelativePath = (pathA, pathB)=>{
    let i = 0;
    for(; i < pathA.length && i < pathB.length && pathA[i] === pathB[i]; i++);
    return [
        (pathA.length - i).toString(),
        ...pathB.slice(i)
    ].join("/");
};
const addMeta = (def, refs, jsonSchema)=>{
    if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) jsonSchema.markdownDescription = def.description;
    }
    return jsonSchema;
};
createLogger('MessageManager');
createLogger('event-manager');
createLogger('Executor');
var __webpack_exports__DOMElementNode = DOMElementNode;
var __webpack_exports__createSelectorMap = createSelectorMap;
var __webpack_exports__getBuildDomTreeScript = getBuildDomTreeScript;
var __webpack_exports__parseNode = parseNode;
var __webpack_exports__removeHighlights = removeHighlights;
var lodash_merge = __webpack_require__("../../../../node_modules/lodash.merge/index.js");
var lodash_merge_default = /*#__PURE__*/ __webpack_require__.n(lodash_merge);
const delayReject = (ms)=>new Promise((_, reject)=>setTimeout(()=>reject(false), ms));
const delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
function defineTools(tools) {
    return tools;
}
function parseProxyUrl(proxyUrl) {
    const result = {
        username: '',
        password: ''
    };
    try {
        const url = new URL(proxyUrl);
        result.username = url.username || '';
        result.password = url.password || '';
    } catch (error) {
        try {
            if (proxyUrl.includes('@')) {
                const protocolIndex = proxyUrl.indexOf('://');
                if (-1 !== protocolIndex) {
                    const authStartIndex = protocolIndex + 3;
                    const authEndIndex = proxyUrl.indexOf('@');
                    if (authEndIndex > authStartIndex) {
                        const authInfo = proxyUrl.substring(authStartIndex, authEndIndex);
                        const authParts = authInfo.split(':');
                        if (authParts.length >= 2) {
                            result.username = authParts[0];
                            result.password = authParts[1];
                        }
                    }
                }
            }
        } catch (fallbackError) {
            console.error('parse proxy url error:', fallbackError);
        }
    }
    return result;
}
function sanitizeForFilePath(s) {
    const sanitize = (s)=>s.replace(/[<>:"|?*/\\]+/g, '-').replace(/[\p{Cc}]+/gu, '-');
    const separator = s.lastIndexOf('.');
    if (-1 === separator) return sanitize(s);
    return sanitize(s.substring(0, separator)) + '.' + sanitize(s.substring(separator + 1));
}
function getDownloadSuggestion(downloadsBefore, downloadedFiles, outputDir) {
    const downloadsAfter = downloadedFiles.length;
    if (downloadsAfter <= downloadsBefore) return '';
    const latestFile = downloadedFiles[downloadsAfter - 1];
    return (null == latestFile ? void 0 : latestFile.suggestedFilename) ? `, Downloading file ${latestFile.suggestedFilename}` : '';
}
const keyInputValues = [
    'Enter',
    'Tab',
    'Escape',
    'Backspace',
    'Delete',
    'Insert',
    'F1',
    'F2',
    'F3',
    'F4',
    'F5',
    'F6',
    'F7',
    'F8',
    'F9',
    'F10',
    'F11',
    'F12',
    'ArrowLeft',
    'ArrowRight',
    'ArrowUp',
    'ArrowDown',
    'PageUp',
    'PageDown',
    'Home',
    'End',
    'ShiftLeft',
    'ShiftRight',
    'ControlLeft',
    'ControlRight',
    'AltLeft',
    'AltRight',
    'MetaLeft',
    'MetaRight',
    'CapsLock',
    'PrintScreen',
    'ScrollLock',
    'Pause',
    'ContextMenu'
];
var mime_types = __webpack_require__("../../../../node_modules/mime-types/index.js");
var isbinaryfile_lib = __webpack_require__("./node_modules/isbinaryfile/lib/index.js");
const store = new Proxy({
    globalConfig: {
        launchOptions: {
            headless: 'linux' === __WEBPACK_EXTERNAL_MODULE_node_os_74b4b876__["default"].platform() && !process.env.DISPLAY
        },
        contextOptions: {},
        enableAdBlocker: false,
        vision: false,
        outputDir: __WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__["default"].join(__WEBPACK_EXTERNAL_MODULE_node_os_74b4b876__["default"].tmpdir(), 'mcp-server-browser', sanitizeForFilePath(new Date().toISOString()))
    },
    globalBrowser: null,
    globalPage: null,
    selectorMap: null,
    downloadedFiles: [],
    logger: new __WEBPACK_EXTERNAL_MODULE__agent_infra_logger_ddae3da2__.ConsoleLogger('[mcp-browser]'),
    initialBrowserSetDownloadBehavior: false
}, {
    get (target, prop) {
        return Reflect.get(target, prop);
    },
    set (target, prop, value) {
        return Reflect.set(target, prop, value);
    }
});
const consoleLogs = [];
const resources_screenshots = new Map();
const getScreenshots = ()=>resources_screenshots;
const registerResources = (server, ctx)=>{
    const { logger } = ctx;
    server.resource('Browser console logs', 'console://logs', {
        mimeType: 'text/plain'
    }, async (uri)=>({
            contents: [
                {
                    uri: uri.href,
                    text: consoleLogs.join('\n')
                }
            ]
        }));
    server.resource('Browser Downloads', new __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_mcp_js_2c42c5d0__.ResourceTemplate('download://{name}', {
        list: void 0
    }), async (uri, { name })=>{
        const { outputDir } = store.globalConfig;
        const fileName = Array.isArray(name) ? name[0] : name;
        const downloadedPath = external_path_["default"].join(outputDir, fileName);
        logger.debug(`[Browser Downloads]: ${downloadedPath}`);
        if (!__WEBPACK_EXTERNAL_MODULE_node_fs_5ea92f0c__["default"].existsSync(downloadedPath)) return {
            contents: []
        };
        const mimeType = mime_types.lookup(fileName) || 'text/plain';
        const buffer = await __WEBPACK_EXTERNAL_MODULE_node_fs_5ea92f0c__["default"].promises.readFile(downloadedPath);
        const isBinary = await (0, isbinaryfile_lib.isBinaryFile)(downloadedPath);
        if (isBinary) return {
            contents: [
                {
                    uri: uri.href,
                    mimeType,
                    blob: buffer.toString('base64')
                }
            ]
        };
        return {
            contents: [
                {
                    uri: uri.href,
                    mimeType,
                    text: buffer.toString('utf-8')
                }
            ]
        };
    });
    server.resource('Browser Screenshots', new __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_mcp_js_2c42c5d0__.ResourceTemplate('screenshot://{name}', {
        list: ()=>{
            const screenshots = getScreenshots();
            return {
                resources: Array.from(screenshots.keys()).map((name)=>({
                        uri: `screenshot://${name}`,
                        mimeType: 'image/png',
                        name: `Screenshot: ${name}`
                    }))
            };
        }
    }), async (uri, { name })=>{
        const latestScreenshots = getScreenshots();
        const screenshots = Array.isArray(name) ? name.map((n)=>latestScreenshots.get(n)) : [
            latestScreenshots.get(name)
        ];
        return {
            contents: screenshots.filter(Boolean).map((screenshot)=>({
                    uri: uri.href,
                    mimeType: 'image/png',
                    blob: screenshot
                }))
        };
    });
};
function shareSameDomainSuffix(hostname, vhost) {
    if (hostname.endsWith(vhost)) return hostname.length === vhost.length || '.' === hostname[hostname.length - vhost.length - 1];
    return false;
}
function extractDomainWithSuffix(hostname, publicSuffix) {
    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);
    if (-1 === lastDotBeforeSuffixIndex) return hostname;
    return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
function getDomain(suffix, hostname, options) {
    if (null !== options.validHosts) {
        const validHosts = options.validHosts;
        for (const vhost of validHosts)if (/*@__INLINE__*/ shareSameDomainSuffix(hostname, vhost)) return vhost;
    }
    let numberOfLeadingDots = 0;
    if (hostname.startsWith('.')) while(numberOfLeadingDots < hostname.length && '.' === hostname[numberOfLeadingDots])numberOfLeadingDots += 1;
    if (suffix.length === hostname.length - numberOfLeadingDots) return null;
    return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);
}
function getDomainWithoutSuffix(domain, suffix) {
    return domain.slice(0, -suffix.length - 1);
}
function extract_hostname_extractHostname(url, urlIsValidHostname) {
    let start = 0;
    let end = url.length;
    let hasUpper = false;
    if (!urlIsValidHostname) {
        if (url.startsWith('data:')) return null;
        while(start < url.length && url.charCodeAt(start) <= 32)start += 1;
        while(end > start + 1 && url.charCodeAt(end - 1) <= 32)end -= 1;
        if (47 === url.charCodeAt(start) && 47 === url.charCodeAt(start + 1)) start += 2;
        else {
            const indexOfProtocol = url.indexOf(':/', start);
            if (-1 !== indexOfProtocol) {
                const protocolSize = indexOfProtocol - start;
                const c0 = url.charCodeAt(start);
                const c1 = url.charCodeAt(start + 1);
                const c2 = url.charCodeAt(start + 2);
                const c3 = url.charCodeAt(start + 3);
                const c4 = url.charCodeAt(start + 4);
                if (5 === protocolSize && 104 === c0 && 116 === c1 && 116 === c2 && 112 === c3 && 115 === c4) ;
                else if (4 === protocolSize && 104 === c0 && 116 === c1 && 116 === c2 && 112 === c3) ;
                else if (3 === protocolSize && 119 === c0 && 115 === c1 && 115 === c2) ;
                else if (2 === protocolSize && 119 === c0 && 115 === c1) ;
                else for(let i = start; i < indexOfProtocol; i += 1){
                    const lowerCaseCode = 32 | url.charCodeAt(i);
                    if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 || lowerCaseCode >= 48 && lowerCaseCode <= 57 || 46 === lowerCaseCode || 45 === lowerCaseCode || 43 === lowerCaseCode)) return null;
                }
                start = indexOfProtocol + 2;
                while(47 === url.charCodeAt(start))start += 1;
            }
        }
        let indexOfIdentifier = -1;
        let indexOfClosingBracket = -1;
        let indexOfPort = -1;
        for(let i = start; i < end; i += 1){
            const code = url.charCodeAt(i);
            if (35 === code || 47 === code || 63 === code) {
                end = i;
                break;
            }
            if (64 === code) indexOfIdentifier = i;
            else if (93 === code) indexOfClosingBracket = i;
            else if (58 === code) indexOfPort = i;
            else if (code >= 65 && code <= 90) hasUpper = true;
        }
        if (-1 !== indexOfIdentifier && indexOfIdentifier > start && indexOfIdentifier < end) start = indexOfIdentifier + 1;
        if (91 === url.charCodeAt(start)) {
            if (-1 !== indexOfClosingBracket) return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
            return null;
        }
        if (-1 !== indexOfPort && indexOfPort > start && indexOfPort < end) end = indexOfPort;
    }
    while(end > start + 1 && 46 === url.charCodeAt(end - 1))end -= 1;
    const hostname = 0 !== start || end !== url.length ? url.slice(start, end) : url;
    if (hasUpper) return hostname.toLowerCase();
    return hostname;
}
function isProbablyIpv4(hostname) {
    if (hostname.length < 7) return false;
    if (hostname.length > 15) return false;
    let numberOfDots = 0;
    for(let i = 0; i < hostname.length; i += 1){
        const code = hostname.charCodeAt(i);
        if (46 === code) numberOfDots += 1;
        else if (code < 48 || code > 57) return false;
    }
    return 3 === numberOfDots && 46 !== hostname.charCodeAt(0) && 46 !== hostname.charCodeAt(hostname.length - 1);
}
function isProbablyIpv6(hostname) {
    if (hostname.length < 3) return false;
    let start = hostname.startsWith('[') ? 1 : 0;
    let end = hostname.length;
    if (']' === hostname[end - 1]) end -= 1;
    if (end - start > 39) return false;
    let hasColon = false;
    for(; start < end; start += 1){
        const code = hostname.charCodeAt(start);
        if (58 === code) hasColon = true;
        else if (!(code >= 48 && code <= 57 || code >= 97 && code <= 102 || code >= 65 && code <= 90)) return false;
    }
    return hasColon;
}
function isIp(hostname) {
    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
}
function isValidAscii(code) {
    return code >= 97 && code <= 122 || code >= 48 && code <= 57 || code > 127;
}
function is_valid(hostname) {
    if (hostname.length > 255) return false;
    if (0 === hostname.length) return false;
    if (/*@__INLINE__*/ !isValidAscii(hostname.charCodeAt(0)) && 46 !== hostname.charCodeAt(0) && 95 !== hostname.charCodeAt(0)) return false;
    let lastDotIndex = -1;
    let lastCharCode = -1;
    const len = hostname.length;
    for(let i = 0; i < len; i += 1){
        const code = hostname.charCodeAt(i);
        if (46 === code) {
            if (i - lastDotIndex > 64 || 46 === lastCharCode || 45 === lastCharCode || 95 === lastCharCode) return false;
            lastDotIndex = i;
        } else if (!/*@__INLINE__*/ (isValidAscii(code) || 45 === code || 95 === code)) return false;
        lastCharCode = code;
    }
    return len - lastDotIndex - 1 <= 63 && 45 !== lastCharCode;
}
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true }) {
    return {
        allowIcannDomains,
        allowPrivateDomains,
        detectIp,
        extractHostname,
        mixedInputs,
        validHosts,
        validateHostname
    };
}
const DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});
function setDefaults(options) {
    if (void 0 === options) return DEFAULT_OPTIONS;
    return /*@__INLINE__*/ setDefaultsImpl(options);
}
function getSubdomain(hostname, domain) {
    if (domain.length === hostname.length) return '';
    return hostname.slice(0, -domain.length - 1);
}
function getEmptyResult() {
    return {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null
    };
}
function factory_parseImpl(url, step, suffixLookup, partialOptions, result) {
    const options = /*@__INLINE__*/ setDefaults(partialOptions);
    if ('string' != typeof url) return result;
    if (options.extractHostname) {
        if (options.mixedInputs) result.hostname = extract_hostname_extractHostname(url, is_valid(url));
        else result.hostname = extract_hostname_extractHostname(url, false);
    } else result.hostname = url;
    if (options.detectIp && null !== result.hostname) {
        result.isIp = isIp(result.hostname);
        if (result.isIp) return result;
    }
    if (options.validateHostname && options.extractHostname && null !== result.hostname && !is_valid(result.hostname)) {
        result.hostname = null;
        return result;
    }
    if (0 === step || null === result.hostname) return result;
    suffixLookup(result.hostname, options, result);
    if (2 === step || null === result.publicSuffix) return result;
    result.domain = getDomain(result.publicSuffix, result.hostname, options);
    if (3 === step || null === result.domain) return result;
    result.subdomain = getSubdomain(result.hostname, result.domain);
    if (4 === step) return result;
    result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
    return result;
}
function fast_path(hostname, options, out) {
    if (!options.allowPrivateDomains && hostname.length > 3) {
        const last = hostname.length - 1;
        const c3 = hostname.charCodeAt(last);
        const c2 = hostname.charCodeAt(last - 1);
        const c1 = hostname.charCodeAt(last - 2);
        const c0 = hostname.charCodeAt(last - 3);
        if (109 === c3 && 111 === c2 && 99 === c1 && 46 === c0) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'com';
            return true;
        }
        if (103 === c3 && 114 === c2 && 111 === c1 && 46 === c0) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'org';
            return true;
        }
        if (117 === c3 && 100 === c2 && 101 === c1 && 46 === c0) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'edu';
            return true;
        } else if (118 === c3 && 111 === c2 && 103 === c1 && 46 === c0) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'gov';
            return true;
        } else if (116 === c3 && 101 === c2 && 110 === c1 && 46 === c0) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'net';
            return true;
        } else if (101 === c3 && 100 === c2 && 46 === c1) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'de';
            return true;
        }
    }
    return false;
}
const hashes = new Uint32Array([
    6,
    0,
    0,
    9,
    5860739,
    5860978,
    5861026,
    5861029,
    5861126,
    5861352,
    5861357,
    5861403,
    5861586,
    0,
    0,
    0,
    1,
    1850179732,
    0,
    9,
    328184559,
    1866923597,
    2123501943,
    2282562397,
    2795346450,
    3130446446,
    3136607046,
    3453334789,
    4194175729,
    72,
    3156266,
    19510334,
    20989895,
    64887183,
    65021741,
    101876503,
    177080427,
    179500755,
    311298055,
    425802535,
    460682395,
    582839475,
    819014943,
    819028732,
    922117623,
    1075688039,
    1139486022,
    1156921983,
    1179004234,
    1241916785,
    1329165410,
    1335010188,
    1370787547,
    1370800824,
    1431231509,
    1498275876,
    1516508161,
    1522025464,
    1544104458,
    1554032448,
    1554653742,
    1570707647,
    1626814538,
    1675555530,
    1679919230,
    1692185483,
    1730108052,
    1789539963,
    1873769763,
    1881070667,
    1890696062,
    1893848785,
    1927992574,
    2001752368,
    2182413090,
    2391299855,
    2419619562,
    2445171142,
    2453492351,
    2496327381,
    2525245455,
    2573179642,
    2703420555,
    2709520566,
    2800127296,
    2921343336,
    2989808530,
    3000405309,
    3015527775,
    3047607849,
    3160720065,
    3382460164,
    3461355676,
    3498015045,
    3688442504,
    3738715095,
    3843717774,
    3934774481,
    4033285539,
    4085096371,
    4146774829,
    4208486561,
    3697,
    100835,
    372942,
    373596,
    399643,
    403867,
    589540,
    737224,
    1210028,
    1861414,
    2424682,
    2658901,
    2946999,
    3329363,
    3333156,
    6942202,
    9086062,
    9095117,
    9267209,
    9340158,
    9485932,
    11010102,
    11406846,
    16314893,
    17546564,
    18146303,
    18331450,
    19211200,
    20314441,
    20797457,
    25057869,
    26663359,
    28320278,
    30499151,
    30585840,
    36605120,
    36775470,
    36775473,
    36990037,
    39275208,
    41892561,
    42049478,
    42538024,
    45214788,
    47656662,
    50173535,
    53599326,
    53858455,
    54537430,
    63815836,
    69971116,
    73517283,
    73904368,
    75706244,
    78793775,
    78794171,
    79558910,
    80324123,
    84993902,
    87977581,
    87978853,
    87978860,
    93811268,
    95641381,
    95641777,
    96671837,
    100511481,
    100947456,
    108215410,
    108929491,
    110526112,
    110662188,
    112311307,
    114507832,
    116811054,
    120488259,
    122521550,
    133427701,
    134012911,
    141513861,
    141517490,
    144349377,
    144362028,
    144550088,
    144770230,
    147205859,
    147810002,
    147989623,
    149598895,
    150736276,
    150856054,
    152379730,
    156555774,
    164189124,
    164189258,
    164189262,
    164189691,
    164189842,
    164560958,
    165069166,
    165106627,
    165107021,
    165339368,
    165444557,
    165444558,
    165444615,
    165444629,
    165444745,
    165444749,
    165445368,
    165512129,
    165512527,
    165749053,
    165749188,
    165749299,
    165749435,
    165749535,
    165779060,
    167155067,
    169909265,
    169909275,
    169909419,
    169909512,
    169909517,
    169909531,
    169909608,
    169909724,
    169909733,
    169909734,
    169909738,
    169909857,
    169910036,
    169910195,
    169910226,
    169939304,
    169977029,
    169977163,
    170281136,
    170281250,
    170281253,
    170281258,
    170281275,
    170281382,
    170281390,
    170281415,
    170281447,
    170281457,
    170281473,
    170281497,
    170281511,
    170281522,
    170281525,
    170281528,
    170281579,
    170281589,
    170281687,
    170281689,
    170281699,
    170281742,
    170281776,
    170281812,
    170281852,
    170281902,
    170281972,
    170311352,
    170649202,
    170649385,
    170649596,
    171188220,
    172078401,
    172145927,
    172213761,
    172213835,
    172214443,
    172484301,
    172788260,
    172788319,
    172788689,
    172788693,
    172788754,
    172788809,
    172788827,
    173118530,
    173118924,
    173253960,
    173254504,
    173456648,
    173591948,
    173930212,
    173930286,
    174129293,
    174306499,
    174306893,
    174307245,
    174307439,
    174358551,
    174374100,
    174407806,
    174410098,
    174488250,
    174509317,
    174577099,
    174606766,
    174644617,
    174843632,
    174844030,
    174847160,
    175181758,
    175524135,
    175524873,
    176843304,
    176948764,
    178529610,
    178530165,
    178530256,
    178530299,
    178530303,
    178530355,
    178868363,
    178868576,
    178868974,
    179274397,
    179274476,
    179379459,
    179379616,
    179379849,
    179379853,
    179380220,
    179657877,
    179692651,
    179714168,
    179913714,
    180090112,
    180090244,
    180090304,
    180090314,
    180090337,
    180090372,
    180090450,
    180090510,
    180090525,
    180090526,
    180090587,
    180090702,
    180091049,
    180091118,
    180091210,
    180091228,
    180091258,
    180091259,
    180283722,
    180292996,
    180293014,
    180293036,
    180293067,
    180293093,
    180293105,
    180293124,
    180293152,
    180293156,
    180293169,
    180293179,
    180293199,
    180293253,
    180293290,
    180293294,
    180293300,
    180293302,
    180293304,
    180293317,
    180293344,
    180293346,
    180293381,
    180293447,
    180293487,
    180293501,
    180293503,
    180293522,
    180293535,
    180293716,
    180293796,
    180293819,
    180293997,
    180294000,
    180294004,
    180294009,
    180428032,
    180902137,
    180969265,
    180969566,
    180969653,
    180969723,
    181105061,
    181105190,
    181105676,
    181240259,
    181240353,
    181240367,
    181240371,
    181240391,
    181240392,
    181240393,
    181240398,
    181240404,
    181240451,
    181240474,
    181240479,
    181240483,
    181240490,
    181240509,
    181240515,
    181240844,
    181240853,
    181240956,
    181241149,
    181241165,
    181241168,
    181244839,
    181278273,
    181375748,
    181548621,
    181548644,
    181548727,
    181548873,
    181549108,
    181549176,
    181949900,
    181950639,
    182056031,
    182385920,
    182419943,
    182893167,
    182893283,
    182893394,
    182893788,
    183163149,
    183163151,
    183163155,
    183163168,
    183163169,
    183163171,
    183163181,
    183163182,
    183163183,
    183163186,
    183163188,
    183163233,
    183163248,
    183163251,
    183163252,
    183163254,
    183163270,
    183163303,
    183163314,
    183163317,
    183163334,
    183163335,
    183163336,
    183163340,
    183163345,
    183163347,
    183163350,
    183163362,
    183163363,
    183163365,
    183163366,
    183163367,
    183163371,
    183163375,
    183163376,
    183163378,
    183163380,
    183163383,
    183163630,
    183163631,
    183163644,
    183163649,
    183163651,
    183163653,
    183163655,
    183163664,
    183163668,
    183163669,
    183163678,
    183163679,
    183163682,
    183163687,
    183163713,
    183163715,
    183163728,
    183163731,
    183163735,
    183163742,
    183163777,
    183163779,
    183163780,
    183163781,
    183163783,
    183163796,
    183163797,
    183163801,
    183163843,
    183163845,
    183163847,
    183163859,
    183163864,
    183163865,
    183163874,
    183163895,
    183163897,
    183163913,
    183163922,
    183163933,
    183163960,
    183163961,
    183163963,
    183163977,
    183163978,
    183163979,
    183163981,
    183163988,
    183163989,
    183163991,
    183163992,
    183163994,
    183163995,
    183163998,
    183164008,
    183164010,
    183164012,
    183164021,
    183164025,
    183164026,
    183164027,
    183164029,
    183164041,
    183164044,
    183164045,
    183164047,
    183164050,
    183164051,
    183164057,
    183164060,
    183164061,
    183164093,
    184080938,
    184081253,
    184081673,
    184081677,
    184081778,
    184246330,
    184246511,
    184486318,
    184486865,
    184487263,
    184828195,
    184828212,
    184844696,
    184844824,
    184848486,
    184848491,
    184849029,
    184849387,
    184859173,
    184869208,
    184869819,
    184994607,
    185163947,
    185216284,
    185289081,
    185292632,
    185295605,
    185501943,
    185502073,
    185502077,
    185772974,
    186723357,
    186723671,
    186723801,
    186753074,
    186763265,
    186771866,
    186840059,
    186858006,
    186875993,
    186950941,
    186953244,
    186994101,
    186994720,
    187011432,
    187022814,
    187064894,
    187067400,
    187076090,
    187078647,
    187088813,
    187161171,
    187188812,
    187203075,
    187219343,
    187222314,
    187251332,
    187328908,
    187332203,
    187378741,
    187385256,
    187386889,
    187403121,
    187403860,
    187404132,
    187409119,
    187410536,
    187415116,
    187415841,
    187417183,
    187453423,
    187455618,
    187483569,
    187506658,
    187521457,
    187531575,
    187554851,
    187557872,
    187932036,
    187932044,
    187932595,
    187932730,
    187932752,
    187932756,
    187932794,
    187932985,
    187932989,
    189797875,
    189851312,
    190236828,
    190304994,
    190305388,
    190575460,
    190575594,
    190879986,
    190880380,
    191458643,
    191459037,
    193856736,
    193857103,
    193857114,
    193857243,
    193991787,
    194363750,
    194498585,
    194498630,
    194498988,
    194499056,
    194499063,
    194532263,
    194532626,
    194532630,
    194532693,
    194532760,
    194532936,
    194533115,
    194802308,
    194802313,
    194802316,
    194802351,
    194802671,
    194802818,
    194802832,
    194802974,
    194803141,
    194803143,
    194803161,
    194803162,
    194803220,
    194803226,
    194803230,
    194803290,
    194836546,
    194870589,
    194870610,
    194871004,
    195040013,
    195040230,
    195040360,
    195077902,
    195078025,
    195078028,
    195078034,
    195078035,
    195078038,
    195078058,
    195078062,
    195078071,
    195078081,
    195078095,
    195078112,
    195078119,
    195078120,
    195078149,
    195078150,
    195078156,
    195078185,
    195078215,
    195078217,
    195078250,
    195078251,
    195078272,
    195078273,
    195078277,
    195078283,
    195078287,
    195078298,
    195078299,
    195078300,
    195078368,
    195078372,
    195078375,
    195078394,
    195078464,
    195078474,
    195078493,
    195078531,
    195078554,
    195078559,
    195078687,
    195078710,
    195078753,
    195078828,
    195078837,
    195078892,
    195078895,
    195078900,
    195078906,
    195078959,
    195078960,
    195078974,
    195078995,
    195078997,
    195079007,
    195145607,
    195146051,
    195817892,
    195817910,
    195818040,
    196653590,
    197775763,
    198219289,
    198248729,
    198354195,
    198354632,
    200387773,
    202063369,
    203326381,
    203326382,
    203326695,
    203326709,
    203326825,
    203326829,
    203327047,
    203327192,
    203360584,
    203427712,
    203428110,
    203563443,
    203563837,
    203664976,
    203665374,
    203762913,
    203901612,
    203969343,
    204069808,
    204070876,
    206121592,
    207568995,
    208227118,
    218659706,
    219797064,
    231775478,
    232791016,
    232866163,
    232870916,
    237059472,
    238230825,
    238671321,
    241611072,
    245880244,
    249954601,
    256262487,
    257210252,
    257542887,
    259829097,
    260353797,
    260353928,
    260353938,
    260354380,
    260381156,
    260390354,
    271387034,
    274691435,
    279382168,
    280527902,
    280532777,
    280535076,
    280542659,
    281931451,
    292827804,
    295209043,
    296292341,
    297619746,
    305011770,
    306510696,
    313583000,
    314643431,
    320313766,
    320318114,
    321023689,
    321141002,
    321447655,
    325454853,
    326762411,
    337081594,
    338040061,
    339830659,
    340010259,
    341833935,
    342149828,
    342665371,
    356194258,
    359223603,
    359276554,
    360327984,
    368215882,
    370146306,
    370150662,
    373255328,
    373394720,
    374785091,
    376173808,
    377307531,
    377336144,
    377652210,
    381874529,
    381884647,
    382049883,
    382486912,
    382598847,
    389909922,
    392084057,
    393290800,
    395076177,
    395140257,
    402724451,
    403769719,
    404122044,
    410188633,
    413977571,
    418962805,
    419080649,
    423458772,
    430711818,
    430784915,
    431116435,
    431157415,
    431370962,
    431390595,
    431489022,
    431585240,
    431586828,
    431608121,
    433686700,
    442888655,
    442922019,
    445176561,
    449218512,
    449424719,
    451217894,
    451870618,
    459172225,
    459395692,
    464626711,
    464765206,
    464834904,
    469098393,
    471052880,
    478642118,
    480635114,
    480636362,
    480638119,
    480638181,
    480638612,
    480653244,
    480658155,
    480658807,
    484603510,
    484645735,
    486805732,
    490264076,
    490274093,
    493445761,
    511578298,
    513731936,
    514111995,
    514955151,
    515474792,
    515491843,
    515593995,
    518161197,
    520595267,
    522631343,
    523234636,
    525872321,
    527144416,
    531170133,
    531427447,
    533682535,
    533847771,
    534396735,
    545433338,
    547443445,
    550462929,
    551440509,
    557981738,
    559064708,
    560636591,
    572640614,
    572652435,
    572800203,
    572833146,
    572867160,
    575127842,
    575742406,
    575835832,
    576106402,
    576590271,
    577168455,
    582462766,
    583917065,
    583936789,
    584490345,
    587768078,
    588145733,
    596395114,
    596517435,
    602054693,
    609523853,
    627471386,
    630686153,
    632559259,
    635121653,
    635859009,
    637007260,
    641121432,
    643488605,
    643663853,
    648304671,
    650538190,
    656171171,
    656243914,
    656640963,
    665693626,
    667797222,
    678076451,
    684522993,
    684536293,
    689172736,
    689202009,
    693611235,
    694324728,
    695649196,
    703142796,
    706540885,
    707132367,
    715533184,
    722903474,
    725879070,
    728415570,
    731964179,
    733989474,
    744440632,
    745674128,
    752520493,
    752687122,
    752687226,
    752699150,
    752938578,
    753314817,
    762792020,
    766278458,
    771168358,
    772916985,
    785945688,
    787032422,
    793080342,
    794341423,
    794638681,
    799598398,
    803443550,
    803504423,
    803576910,
    803750530,
    804899040,
    810638083,
    813049915,
    813882670,
    813882809,
    821390609,
    822184173,
    824372117,
    826639012,
    826993974,
    827624512,
    831815016,
    834750300,
    834856638,
    834963202,
    835666250,
    838463501,
    843454848,
    845393562,
    845537310,
    846032279,
    853098265,
    855980394,
    858467853,
    869651422,
    878524814,
    881613818,
    885943745,
    896206971,
    896253025,
    900375831,
    900562876,
    904696072,
    907903147,
    911040096,
    912288153,
    912452591,
    913046780,
    914761571,
    915088911,
    915769822,
    915838470,
    919008564,
    919376364,
    928343570,
    933141848,
    935240483,
    936096500,
    939243980,
    939281294,
    939375524,
    939697158,
    939922440,
    940027871,
    942743627,
    943328481,
    943363810,
    947022624,
    950098348,
    954017396,
    958817278,
    959069811,
    961909457,
    961915153,
    962363178,
    962549619,
    962816118,
    963013768,
    968961134,
    973306633,
    973587946,
    973591516,
    973595243,
    973613934,
    973618563,
    976871270,
    977251657,
    983929219,
    983931665,
    983936021,
    984542401,
    985854160,
    994961720,
    1002154839,
    1005485664,
    1005660307,
    1005931709,
    1008280710,
    1009678005,
    1015938248,
    1018008327,
    1024510565,
    1027688850,
    1033879086,
    1034357170,
    1038843968,
    1039500800,
    1043537387,
    1043742405,
    1044060157,
    1045601283,
    1046273911,
    1046743273,
    1046756254,
    1048099261,
    1052311686,
    1052441930,
    1052883806,
    1055187548,
    1056740120,
    1058016469,
    1059921109,
    1068743400,
    1072264613,
    1080832696,
    1083646554,
    1084662717,
    1086818213,
    1087030220,
    1088313455,
    1101657937,
    1101658065,
    1102136407,
    1102691201,
    1104888372,
    1107574816,
    1107604513,
    1107608406,
    1115517588,
    1116603570,
    1116886791,
    1121068214,
    1121069468,
    1123274870,
    1123277038,
    1123281470,
    1123286137,
    1123300855,
    1135543458,
    1135544712,
    1135545955,
    1135553917,
    1135559494,
    1135563376,
    1141006631,
    1141018311,
    1142918810,
    1143019669,
    1145288372,
    1146787097,
    1149112251,
    1151589762,
    1152383075,
    1153556935,
    1153560693,
    1153560855,
    1153576209,
    1153582928,
    1155609853,
    1158010336,
    1158014282,
    1158019276,
    1158022529,
    1158025585,
    1158030151,
    1158040127,
    1158040853,
    1158043091,
    1160141196,
    1160246728,
    1160253683,
    1160271099,
    1160271446,
    1160272445,
    1160277399,
    1161223806,
    1161235355,
    1162489113,
    1166908086,
    1166937977,
    1166949933,
    1166952503,
    1166953757,
    1166959964,
    1169030529,
    1169037994,
    1169039382,
    1169046802,
    1169046815,
    1169048548,
    1169054036,
    1169994302,
    1171270813,
    1172775704,
    1174752677,
    1174762471,
    1175721241,
    1175725254,
    1175726508,
    1175727467,
    1175727495,
    1175735444,
    1175735449,
    1175736592,
    1175738385,
    1175738578,
    1175738760,
    1175746250,
    1175746252,
    1175749986,
    1175793566,
    1181427747,
    1181429001,
    1181435208,
    1181446765,
    1181453654,
    1181460959,
    1185692184,
    1189090107,
    1193567716,
    1194400508,
    1204258276,
    1204470469,
    1207765705,
    1207825797,
    1208230324,
    1208517393,
    1208911775,
    1211364607,
    1212671635,
    1214258492,
    1217924538,
    1220965831,
    1229000062,
    1229783327,
    1232816452,
    1237771172,
    1237773393,
    1237773841,
    1245899123,
    1247245722,
    1257366451,
    1260762188,
    1261854970,
    1265324777,
    1265669119,
    1273073240,
    1280280379,
    1280768035,
    1291368159,
    1295085673,
    1296518360,
    1297048848,
    1300364681,
    1303650868,
    1304687455,
    1304781392,
    1304918086,
    1305056028,
    1306968125,
    1306972554,
    1306973586,
    1307665177,
    1308558601,
    1308559744,
    1308574194,
    1308583254,
    1308584508,
    1308585495,
    1310785148,
    1310799239,
    1310800921,
    1310801269,
    1310803416,
    1310807041,
    1310808370,
    1311349087,
    1313021694,
    1313023237,
    1313031514,
    1313033243,
    1313033533,
    1314270973,
    1314287001,
    1314293208,
    1321085506,
    1324313259,
    1324313985,
    1324320704,
    1324322270,
    1324332261,
    1324636022,
    1325293061,
    1325300526,
    1325303158,
    1325308368,
    1325309334,
    1325309339,
    1325310241,
    1325310486,
    1325311328,
    1325311482,
    1326707500,
    1328209699,
    1328777903,
    1328778629,
    1328785348,
    1328786906,
    1328789635,
    1328794451,
    1328797153,
    1329963165,
    1329987910,
    1330666198,
    1330807345,
    1330903052,
    1331009222,
    1331010221,
    1331013633,
    1331015175,
    1331019352,
    1331025251,
    1331026645,
    1331028446,
    1331143849,
    1335892543,
    1336436046,
    1336436772,
    1336437775,
    1336438057,
    1336439236,
    1336443338,
    1336449024,
    1336456660,
    1336460266,
    1336462620,
    1336463768,
    1336469142,
    1341018428,
    1341081128,
    1341091249,
    1341179896,
    1342001696,
    1344411053,
    1344426134,
    1344436952,
    1344437939,
    1344444146,
    1346529166,
    1349466130,
    1350170659,
    1350170661,
    1350356518,
    1350356534,
    1350620578,
    1351056251,
    1351154191,
    1351382419,
    1351445663,
    1354447091,
    1354448055,
    1354464484,
    1354467042,
    1354475004,
    1354584300,
    1355466970,
    1355483586,
    1355607656,
    1355929695,
    1355947655,
    1356150953,
    1356150969,
    1356150973,
    1356457867,
    1356471002,
    1356757572,
    1357692080,
    1357876668,
    1357880232,
    1360043731,
    1360220638,
    1362168625,
    1362262729,
    1362271868,
    1362285703,
    1362326863,
    1362506071,
    1362656266,
    1365811994,
    1367692098,
    1367811071,
    1368820926,
    1369663049,
    1377739598,
    1378565283,
    1379014609,
    1383613953,
    1383613964,
    1383629111,
    1383647122,
    1385857457,
    1385879444,
    1388074128,
    1388078600,
    1388084119,
    1388086017,
    1388094003,
    1388104573,
    1388109527,
    1388111766,
    1390304957,
    1390318095,
    1390319238,
    1390327192,
    1390328435,
    1390329689,
    1391292472,
    1391295130,
    1391298115,
    1391299402,
    1391302044,
    1391307254,
    1391308253,
    1392560940,
    1396553940,
    1397006395,
    1397007527,
    1397007872,
    1397007885,
    1397015305,
    1397016949,
    1397022431,
    1400354688,
    1400355947,
    1400356673,
    1400364702,
    1400366245,
    1401334766,
    1401741660,
    1407044461,
    1407049415,
    1407053336,
    1407060753,
    1407067683,
    1409840426,
    1410939834,
    1414623055,
    1417953492,
    1417953925,
    1417969521,
    1417971248,
    1418042854,
    1418666866,
    1422407147,
    1422418384,
    1422432926,
    1422433613,
    1422434165,
    1422435892,
    1423090882,
    1425971467,
    1426162994,
    1426865884,
    1426871783,
    1426872814,
    1426880658,
    1426881913,
    1426884152,
    1428612014,
    1429098926,
    1429105132,
    1429112250,
    1430623854,
    1433558874,
    1433568865,
    1433577620,
    1433578879,
    1435862377,
    1444705448,
    1444706435,
    1444707945,
    1444708598,
    1444713016,
    1444718265,
    1444720166,
    1444723003,
    1444725453,
    1444731199,
    1444731564,
    1444731950,
    1444732047,
    1444732342,
    1444732347,
    1444738453,
    1448052138,
    1448052864,
    1448054123,
    1448067662,
    1448078965,
    1449172589,
    1452091461,
    1453961462,
    1457037634,
    1457145422,
    1457156469,
    1457178704,
    1459376581,
    1459377857,
    1459377868,
    1459384567,
    1459385707,
    1459403577,
    1459405260,
    1459408531,
    1463053013,
    1463840740,
    1463842504,
    1463849459,
    1463849797,
    1463867222,
    1463868221,
    1463873175,
    1464819582,
    1464821125,
    1464829402,
    1464830128,
    1464831131,
    1465838987,
    1466068861,
    1466074694,
    1466091096,
    1466403701,
    1467047928,
    1467061763,
    1467063453,
    1467065948,
    1467070902,
    1468307140,
    1468314970,
    1468321435,
    1469284474,
    1469285761,
    1469294772,
    1469295775,
    1471526086,
    1474720970,
    1474751199,
    1474796155,
    1474852365,
    1474856386,
    1474857640,
    1474858627,
    1474866589,
    1474867476,
    1474871748,
    1474880870,
    1482183211,
    1482187228,
    1482389973,
    1486003341,
    1486005836,
    1486010790,
    1486021608,
    1486029338,
    1486036499,
    1486036510,
    1491300687,
    1492905126,
    1495099017,
    1496999162,
    1497335658,
    1497338257,
    1497341434,
    1497353781,
    1497360500,
    1497361503,
    1503214457,
    1504022303,
    1504024292,
    1504032122,
    1504033105,
    1504038587,
    1509379857,
    1510741574,
    1514359714,
    1514604870,
    1517410020,
    1517415502,
    1517416485,
    1517424315,
    1517426048,
    1519466742,
    1519486936,
    1521633706,
    1524564715,
    1526518672,
    1534242148,
    1535379077,
    1535411852,
    1535416972,
    1535418272,
    1535419013,
    1535426999,
    1535427585,
    1535429447,
    1535437817,
    1535442771,
    1535445010,
    1538631370,
    1539876488,
    1539883905,
    1539891891,
    1539902461,
    1539907415,
    1539909654,
    1540853566,
    1540863813,
    1540865371,
    1540871834,
    1540872816,
    1540972285,
    1544565822,
    1547523228,
    1548000883,
    1548203684,
    1548662272,
    1548668010,
    1548668993,
    1548676831,
    1548677846,
    1548686756,
    1550655859,
    1551291701,
    1552780862,
    1554083280,
    1554160502,
    1556617220,
    1556618479,
    1556619205,
    1556627226,
    1556629025,
    1571587981,
    1572843623,
    1577978899,
    1578737375,
    1579027766,
    1580891870,
    1580902117,
    1580903020,
    1580910138,
    1580910864,
    1581061599,
    1584242651,
    1584252576,
    1584258687,
    1584260414,
    1584261397,
    1594150134,
    1594318433,
    1594644051,
    1595762332,
    1596503336,
    1599871881,
    1600554193,
    1600562964,
    1600967980,
    1600968967,
    1600970477,
    1600988233,
    1600993979,
    1600994866,
    1600997301,
    1601541268,
    1602995891,
    1603061457,
    1604314670,
    1604316655,
    1604330442,
    1604341489,
    1604342648,
    1605183784,
    1605406132,
    1605908391,
    1607689728,
    1607689741,
    1607690628,
    1607701062,
    1607701276,
    1607705078,
    1607710365,
    1607715640,
    1607716607,
    1607716627,
    1608344260,
    1610313759,
    1610666926,
    1611239998,
    1611396088,
    1614382839,
    1614530679,
    1615167003,
    1615172374,
    1615640392,
    1615647347,
    1615658840,
    1615665110,
    1615666109,
    1615671063,
    1620094847,
    1620095619,
    1620095929,
    1620105028,
    1620113841,
    1620119323,
    1620795340,
    1621082362,
    1621083649,
    1621092660,
    1622329964,
    1622331641,
    1622337218,
    1622353628,
    1623408910,
    1624559739,
    1624569664,
    1624577502,
    1624577906,
    1624578485,
    1626556599,
    1628470609,
    1630022199,
    1632310642,
    1633163415,
    1635568907,
    1635591150,
    1635593749,
    1635643420,
    1635994183,
    1635994320,
    1641006393,
    1645672758,
    1645785364,
    1645803376,
    1645808858,
    1645809841,
    1646891621,
    1646892908,
    1646907799,
    1646910247,
    1646917618,
    1646918617,
    1648006829,
    1648007716,
    1648013185,
    1648013984,
    1648016015,
    1648021910,
    1648025704,
    1648032728,
    1648033439,
    1648033715,
    1648035901,
    1648039922,
    1648043240,
    1649454738,
    1649581121,
    1652486802,
    1652497372,
    1652504566,
    1652932064,
    1652936599,
    1653583645,
    1653598182,
    1653599929,
    1653606136,
    1653607123,
    1654697756,
    1654712103,
    1654713134,
    1654716280,
    1654721234,
    1654722233,
    1656168200,
    1659162648,
    1659176739,
    1659180924,
    1659185878,
    1659186877,
    1659695250,
    1660874915,
    1664393911,
    1666510724,
    1668155429,
    1669474757,
    1673661122,
    1673662353,
    1673671436,
    1673686839,
    1673856704,
    1674136053,
    1674769898,
    1674770881,
    1674776363,
    1674793871,
    1675780006,
    1676641114,
    1677004461,
    1677008482,
    1677010668,
    1677010688,
    1677011655,
    1677022217,
    1677030942,
    1677037554,
    1679194024,
    1679234542,
    1679234666,
    1679237897,
    1679241007,
    1679252114,
    1679258763,
    1679261552,
    1679266928,
    1681499983,
    1681500998,
    1681504918,
    1681509234,
    1681510306,
    1681510964,
    1681520272,
    1681524681,
    1681526010,
    1681526993,
    1682221833,
    1682359277,
    1685960411,
    1685962398,
    1685964612,
    1685965520,
    1685965569,
    1685965582,
    1685965890,
    1685967499,
    1685968865,
    1685974082,
    1685987547,
    1685988215,
    1685988552,
    1685991645,
    1686112357,
    1686592668,
    1686670946,
    1687209729,
    1687209740,
    1687216901,
    1687224887,
    1687235705,
    1687240659,
    1687242898,
    1690419670,
    1690419852,
    1690423356,
    1690429255,
    1690430286,
    1690438386,
    1690439385,
    1690439477,
    1691674376,
    1691689779,
    1691700349,
    1691705303,
    1691707542,
    1691739899,
    1692242488,
    1693900733,
    1693913871,
    1693915014,
    1693915019,
    1693922968,
    1693924211,
    1693925465,
    1696137279,
    1696148081,
    1696153563,
    1696514991,
    1697110779,
    1697112784,
    1697112842,
    1697116346,
    1697119048,
    1697126337,
    1697127463,
    1697127903,
    1697134366,
    1697135348,
    1699859798,
    1705948764,
    1706596362,
    1707661217,
    1709380801,
    1709397036,
    1709401602,
    1709403991,
    1709403994,
    1709715630,
    1709719753,
    1710553669,
    1710842194,
    1711349139,
    1711911296,
    1712862856,
    1712864099,
    1712865353,
    1712874413,
    1712889750,
    1715042583,
    1716067791,
    1716074254,
    1716075236,
    1716090026,
    1716093784,
    1716101073,
    1716987897,
    1717046504,
    1717344945,
    1717458342,
    1717567159,
    1717665490,
    1720424110,
    1720435157,
    1720448732,
    1720448944,
    1720449947,
    1720450929,
    1722611952,
    1723770733,
    1723771620,
    1723777366,
    1723796376,
    1723797619,
    1723869014,
    1724144999,
    1724360630,
    1724887843,
    1724888746,
    1724891334,
    1724900049,
    1724902970,
    1724913588,
    1724914591,
    1724915573,
    1727744610,
    1733044570,
    1737465416,
    1740104597,
    1740108386,
    1741479646,
    1741618915,
    1741621154,
    1741622153,
    1741631292,
    1741636935,
    1741709977,
    1742216984,
    1743089654,
    1744959211,
    1744968590,
    1744969829,
    1744971556,
    1744977659,
    1744987840,
    1745343269,
    1745488513,
    1746392299,
    1747200908,
    1747202151,
    1747210105,
    1747211248,
    1747212978,
    1747215938,
    1747219291,
    1747533677,
    1747671543,
    1747762259,
    1748301224,
    1748301648,
    1748302211,
    1748318651,
    1748321229,
    1748327140,
    1748327340,
    1748328118,
    1748329946,
    1749416322,
    1749419816,
    1749422630,
    1749422974,
    1749423815,
    1749423848,
    1749423862,
    1749423980,
    1749432545,
    1749435316,
    1749435457,
    1749435956,
    1749437829,
    1749437986,
    1749440303,
    1749441388,
    1749442296,
    1749442361,
    1749443256,
    1749443576,
    1749444398,
    1749445477,
    1749445739,
    1749750164,
    1749955965,
    1752768365,
    1753028168,
    1753430927,
    1753880966,
    1753882221,
    1753900232,
    1753906931,
    1756680747,
    1759105063,
    1762715404,
    1763952265,
    1763967858,
    1763978172,
    1763979159,
    1765274516,
    1768132013,
    1774870841,
    1775278057,
    1776446407,
    1778765218,
    1779479261,
    1779706923,
    1779707649,
    1779709525,
    1779713177,
    1779714057,
    1779714368,
    1779715934,
    1779715971,
    1779725925,
    1779730307,
    1779731494,
    1780768183,
    1781938118,
    1781938242,
    1781939241,
    1781948380,
    1781954023,
    1781961852,
    1781965719,
    1783657515,
    1785147288,
    1785152492,
    1785564290,
    1786402886,
    1786403885,
    1786408839,
    1786413016,
    1786418915,
    1786422601,
    1793085197,
    1793091404,
    1793103209,
    1793109842,
    1794311882,
    1796513490,
    1798682988,
    1799934413,
    1800873944,
    1804734874,
    1804986274,
    1805201900,
    1805201909,
    1805381533,
    1805390218,
    1805394927,
    1805396070,
    1805397817,
    1805404024,
    1805410294,
    1808346875,
    1809278593,
    1809846425,
    1809852765,
    1809854826,
    1809860706,
    1809868668,
    1809869655,
    1809909084,
    1810126394,
    1810162729,
    1811189710,
    1812804641,
    1813167465,
    1818860644,
    1819164253,
    1824377544,
    1826567786,
    1826567942,
    1826568769,
    1826574251,
    1826586852,
    1826591759,
    1826593533,
    1826594804,
    1826595685,
    1826597041,
    1826838298,
    1830073720,
    1832102940,
    1835526804,
    1835527882,
    1835530317,
    1835531888,
    1835536950,
    1835540435,
    1835541852,
    1835548479,
    1835548755,
    1835552425,
    1835554706,
    1835556216,
    1836706536,
    1838062951,
    1839007628,
    1839021100,
    1839022775,
    1839033593,
    1839038547,
    1839040786,
    1839994953,
    1840001842,
    1840013399,
    1840019350,
    1840019827,
    1840020860,
    1843076481,
    1845608978,
    1846070315,
    1848013570,
    1854921046,
    1859450748,
    1859510931,
    1859511204,
    1860240647,
    1860312281,
    1860334137,
    1861101595,
    1863024310,
    1866891339,
    1866893066,
    1866896736,
    1866908847,
    1866910185,
    1866914026,
    1867191437,
    1867861644,
    1867861768,
    1867865679,
    1867867083,
    1867872142,
    1867873124,
    1867876289,
    1867885376,
    1867885466,
    1867887914,
    1867888607,
    1867892691,
    1867898961,
    1867899162,
    1873521117,
    1875950626,
    1878219696,
    1883713830,
    1883718737,
    1883722494,
    1883726489,
    1883992567,
    1884025074,
    1889208808,
    1889317056,
    1890185274,
    1890552293,
    1891315242,
    1893129355,
    1894534152,
    1894535395,
    1894543357,
    1894548934,
    1895822736,
    1896748195,
    1896864381,
    1896883495,
    1896884690,
    1896893413,
    1897086584,
    1897144569,
    1897150382,
    1897161336,
    1898308423,
    1899713189,
    1903920486,
    1903920882,
    1906518923,
    1906815088,
    1907758428,
    1907908343,
    1907910446,
    1907911172,
    1907924055,
    1907926218,
    1907937265,
    1910568778,
    1912588116,
    1912664290,
    1912773142,
    1919704439,
    1919708663,
    1925589573,
    1928014104,
    1931786446,
    1933270769,
    1933847987,
    1934282690,
    1935832225,
    1937137824,
    1940180687,
    1941545223,
    1944881831,
    1944883085,
    1944889292,
    1944901097,
    1944907730,
    1944915291,
    1947690884,
    1949378607,
    1949381140,
    1949385828,
    1949388221,
    1949404634,
    1953208595,
    1957126749,
    1965980590,
    1966393263,
    1967560433,
    1968030901,
    1968344522,
    1968345101,
    1968345505,
    1968353343,
    1968354820,
    1969952988,
    1969953274,
    1970271924,
    1982830318,
    1982831301,
    1982836783,
    1982854539,
    1982856313,
    1982857328,
    1982862253,
    1982863214,
    1983945412,
    1983946415,
    1983946627,
    1983953134,
    1983957025,
    1983968650,
    1983971249,
    1983972408,
    1983977373,
    1985096774,
    1985106740,
    1985116048,
    1985122769,
    1987352594,
    1989155232,
    1991785536,
    1991792841,
    1991799730,
    1991811287,
    1991817238,
    1991817715,
    1991818748,
    1994019132,
    1994026062,
    1994028952,
    1994613365,
    2000627256,
    2002587178,
    2002703477,
    2004055936,
    2004062657,
    2004080420,
    2007546240,
    2007547499,
    2007556254,
    2007557797,
    2009780252,
    2013938002,
    2016158046,
    2016458632,
    2016459875,
    2016461129,
    2016470189,
    2016476340,
    2016482461,
    2016485526,
    2019785049,
    2023148389,
    2023153871,
    2023155598,
    2023156002,
    2023157760,
    2023171627,
    2023174160,
    2023812622,
    2029256230,
    2029286951,
    2029296544,
    2037064184,
    2042215210,
    2042272668,
    2042423451,
    2043073993,
    2044012869,
    2046744295,
    2047386704,
    2047490213,
    2047625030,
    2047828609,
    2051192703,
    2052284669,
    2056364987,
    2056365175,
    2056459861,
    2057257910,
    2058376024,
    2058382302,
    2058436464,
    2058440319,
    2058445367,
    2058448694,
    2058452545,
    2058552215,
    2058569521,
    2058573621,
    2058924197,
    2058929805,
    2058958371,
    2058984507,
    2058988863,
    2059003240,
    2059051015,
    2059075746,
    2059422408,
    2059824807,
    2061714098,
    2062014471,
    2063260135,
    2063415690,
    2063627333,
    2063814283,
    2064238717,
    2064313581,
    2064484772,
    2064499575,
    2064635107,
    2064635452,
    2064635773,
    2064639428,
    2064639883,
    2064648773,
    2064654772,
    2064655646,
    2065476844,
    2065542420,
    2065542544,
    2065543022,
    2065727011,
    2066567940,
    2066734284,
    2066828553,
    2066833534,
    2067202738,
    2067233317,
    2068031208,
    2068725531,
    2068831008,
    2068854498,
    2068854512,
    2068858196,
    2068859575,
    2068860177,
    2068862627,
    2068863232,
    2068869021,
    2068950273,
    2068994789,
    2068994807,
    2069062998,
    2069102686,
    2069161595,
    2069263945,
    2069338842,
    2069365704,
    2069468800,
    2069558220,
    2069561350,
    2069566268,
    2069591394,
    2069593072,
    2069595618,
    2069600040,
    2069600946,
    2069600957,
    2069604100,
    2069765192,
    2069904166,
    2069904305,
    2071035931,
    2071149679,
    2071643658,
    2073289171,
    2073308845,
    2073310709,
    2073312474,
    2073322881,
    2073335784,
    2073440452,
    2073448514,
    2073457247,
    2073500084,
    2073509625,
    2073523923,
    2073533208,
    2073640292,
    2073794194,
    2073803151,
    2073803461,
    2073808229,
    2073811616,
    2073811996,
    2073815760,
    2073826308,
    2073826688,
    2073827152,
    2073830759,
    2073831593,
    2073831601,
    2074299520,
    2075044848,
    2075423284,
    2075693433,
    2078935992,
    2078936931,
    2078937889,
    2078937913,
    2078938163,
    2078938295,
    2078944407,
    2078944555,
    2078944613,
    2078944933,
    2081181239,
    2082063743,
    2082285629,
    2082430948,
    2084946688,
    2086083080,
    2087431076,
    2087431077,
    2087431079,
    2087431080,
    2087431081,
    2087431082,
    2087431085,
    2087431086,
    2087431087,
    2087431088,
    2087431089,
    2087431090,
    2087431091,
    2087431092,
    2087431093,
    2087431094,
    2087431096,
    2087431097,
    2087431098,
    2087431099,
    2087431100,
    2087431102,
    2087431103,
    2087617590,
    2087617591,
    2087617592,
    2087617593,
    2087617594,
    2087617595,
    2087617596,
    2087617597,
    2087617598,
    2087617599,
    2087617632,
    2087617633,
    2087617634,
    2087617635,
    2087617636,
    2087617637,
    2087617638,
    2087617639,
    2087617640,
    2087617641,
    2087617642,
    2087617643,
    2087617644,
    2087617645,
    2087617647,
    2087617652,
    2087617654,
    2087617655,
    2087617656,
    2087617657,
    2087617658,
    2087617659,
    2087617660,
    2087617661,
    2087617662,
    2087617663,
    2087629931,
    2087822490,
    2088302297,
    2088726760,
    2088953542,
    2090213881,
    2090218574,
    2090297888,
    2090298020,
    2090439875,
    2090439900,
    2091225604,
    2092577468,
    2092702023,
    2092715579,
    2092766986,
    2092957042,
    2093991393,
    2093995617,
    2093995632,
    2097113374,
    2098599777,
    2098599792,
    2099138174,
    2102249573,
    2102285158,
    2102285168,
    2102285285,
    2102285374,
    2102286572,
    2102291553,
    2102297313,
    2102301463,
    2102304381,
    2102311282,
    2102312281,
    2102313468,
    2102315379,
    2102317235,
    2102322718,
    2103529616,
    2105684477,
    2105873178,
    2106751208,
    2106757636,
    2106766355,
    2106769656,
    2106775467,
    2106775926,
    2106776925,
    2106781879,
    2118750891,
    2119037299,
    2119037310,
    2119041270,
    2119043865,
    2119381911,
    2119891962,
    2120136928,
    2120142410,
    2120143393,
    2120151231,
    2120152708,
    2121629990,
    2122433548,
    2123414271,
    2123472843,
    2123472936,
    2123472941,
    2123472990,
    2123479292,
    2123481132,
    2123481326,
    2123481391,
    2123481939,
    2123481960,
    2123482409,
    2123482928,
    2123482935,
    2123485221,
    2123485512,
    2123485548,
    2123486092,
    2123487587,
    2123487602,
    2123487868,
    2123488061,
    2123488218,
    2123489049,
    2123491458,
    2123491494,
    2123491502,
    2123491940,
    2123491944,
    2123491950,
    2123491964,
    2123492067,
    2123492380,
    2123492410,
    2123492613,
    2123492943,
    2123493403,
    2123494323,
    2123494721,
    2123494806,
    2123495205,
    2123495222,
    2123495263,
    2123495538,
    2123495599,
    2123495615,
    2123495829,
    2123496707,
    2123496945,
    2123497027,
    2123497539,
    2123498152,
    2123498482,
    2123498621,
    2123498738,
    2123499337,
    2123499387,
    2123499393,
    2123499675,
    2123499817,
    2123499823,
    2123500085,
    2123500670,
    2123501043,
    2123501651,
    2123501946,
    2123502012,
    2123502614,
    2123502618,
    2123502909,
    2123502931,
    2123502972,
    2123503489,
    2123503580,
    2123503633,
    2123503639,
    2123503645,
    2123503683,
    2123503690,
    2123503871,
    2123503914,
    2123503925,
    2123506021,
    2123508761,
    2123508887,
    2123508888,
    2123509104,
    2123509367,
    2123510210,
    2126830924,
    2126831627,
    2126831911,
    2126831915,
    2126834731,
    2126838118,
    2126839865,
    2126841008,
    2126851442,
    2126854146,
    2126854761,
    2127933481,
    2127939688,
    2127940675,
    2127945958,
    2127950989,
    2127966582,
    2130163562,
    2130164545,
    2130170027,
    2130187535,
    2130190580,
    2131286378,
    2132327224,
    2132331087,
    2132359596,
    2133546426,
    2134655216,
    2135730753,
    2135744303,
    2135751022,
    2135766376,
    2135766538,
    2136033383,
    2136198665,
    2140379406,
    2140382005,
    2140404240,
    2140405499,
    2140406225,
    2141369520,
    2141378580,
    2141384318,
    2142607534,
    2142608862,
    2142616598,
    2143588731,
    2143590729,
    2143592861,
    2143597618,
    2143609175,
    2143615126,
    2143616636,
    2144000095,
    2144838611,
    2144844042,
    2144846897,
    2144858266,
    2144868884,
    2144870143,
    2144870869,
    2157945278,
    2158338411,
    2160318468,
    2160324206,
    2160325189,
    2160333019,
    2160343200,
    2161569257,
    2161578129,
    2161578140,
    2161592231,
    2161595735,
    2165898261,
    2166038855,
    2166996811,
    2167003274,
    2167004256,
    2167015877,
    2167018798,
    2167213797,
    2167993101,
    2169327252,
    2170481633,
    2170487115,
    2170488842,
    2170504623,
    2170507412,
    2176528068,
    2179101309,
    2180545870,
    2191744103,
    2191744212,
    2191821366,
    2191883015,
    2192566334,
    2193960351,
    2195897610,
    2195898849,
    2195906687,
    2195916612,
    2195922100,
    2196631346,
    2205406696,
    2211506222,
    2216825796,
    2219145843,
    2221394610,
    2225058301,
    2225061335,
    2225064134,
    2225071439,
    2225073075,
    2225080536,
    2226037368,
    2226044042,
    2226051203,
    2226052893,
    2226055388,
    2226060342,
    2226419862,
    2229788675,
    2230793522,
    2230840997,
    2231615745,
    2231617728,
    2231623210,
    2231628742,
    2231632031,
    2231633170,
    2231633764,
    2231638049,
    2231729235,
    2231751291,
    2231760201,
    2231761216,
    2231769054,
    2231770037,
    2231775519,
    2233884981,
    2235097422,
    2235100587,
    2235101313,
    2235108032,
    2235109598,
    2235116887,
    2235119589,
    2236869449,
    2241796550,
    2241797549,
    2241806680,
    2241812579,
    2242828527,
    2246244298,
    2246245281,
    2246250763,
    2246260079,
    2246271316,
    2247223374,
    2247249937,
    2247251096,
    2248592412,
    2250708942,
    2250715407,
    2250719552,
    2250724971,
    2250725805,
    2250733692,
    2250734937,
    2250735952,
    2258665553,
    2258878642,
    2264886749,
    2266447633,
    2267607000,
    2274782645,
    2282544968,
    2285662351,
    2290599544,
    2292158595,
    2293175691,
    2293351636,
    2296071446,
    2299255515,
    2301040846,
    2306079466,
    2307580553,
    2313504811,
    2318220358,
    2320224028,
    2325476095,
    2337176745,
    2339504386,
    2344847762,
    2345345412,
    2345556981,
    2346482211,
    2346482871,
    2351498341,
    2352240646,
    2352738840,
    2358991500,
    2361087993,
    2364634824,
    2371011349,
    2373457221,
    2376425283,
    2379512524,
    2379580075,
    2390286898,
    2390518325,
    2390736011,
    2392516839,
    2392521063,
    2400874900,
    2400879124,
    2402335630,
    2404974948,
    2405102721,
    2405117283,
    2405120727,
    2414810349,
    2415093005,
    2415923742,
    2415925541,
    2415935547,
    2415976346,
    2418152088,
    2422623072,
    2422625395,
    2422631927,
    2422634373,
    2422636295,
    2422636392,
    2425962056,
    2425963043,
    2425969250,
    2425969487,
    2425971892,
    2425985030,
    2428197348,
    2428202830,
    2428203813,
    2428211643,
    2428212914,
    2428213376,
    2428240545,
    2430223084,
    2433759338,
    2433759634,
    2433760321,
    2433765803,
    2433783311,
    2433785126,
    2433786356,
    2433788522,
    2435993901,
    2436000108,
    2436001095,
    2436011657,
    2436026994,
    2439339076,
    2439340079,
    2439340291,
    2439346798,
    2439350689,
    2439362314,
    2439364913,
    2439366072,
    2439371037,
    2439876345,
    2440431898,
    2440444045,
    2440449369,
    2444112661,
    2447928023,
    2452264162,
    2454797153,
    2458316286,
    2459819944,
    2462285242,
    2462802458,
    2463186757,
    2466741694,
    2466758807,
    2467213089,
    2467545358,
    2467601561,
    2467655846,
    2467686484,
    2467740953,
    2473985870,
    2474042431,
    2474150919,
    2474285829,
    2474577412,
    2474661520,
    2475343068,
    2475470210,
    2475772433,
    2475877012,
    2475877016,
    2475892298,
    2476213365,
    2476552306,
    2479517659,
    2489453909,
    2489531547,
    2498555779,
    2501597440,
    2507278661,
    2510852110,
    2511694664,
    2512156190,
    2540805343,
    2542362598,
    2543008264,
    2547140668,
    2553182506,
    2558063998,
    2558416820,
    2560726248,
    2564751176,
    2566787042,
    2569608194,
    2572602371,
    2577853220,
    2579803386,
    2583084289,
    2586020617,
    2600402029,
    2604613571,
    2614694552,
    2616608417,
    2623678483,
    2624091113,
    2626979216,
    2627765050,
    2629831661,
    2630340943,
    2630577386,
    2637047575,
    2637160117,
    2637393619,
    2637589507,
    2639283063,
    2642320383,
    2657728452,
    2661288721,
    2663538084,
    2673250796,
    2673678071,
    2673953045,
    2683622002,
    2686768508,
    2689921282,
    2691751732,
    2691869931,
    2692015714,
    2693065457,
    2693628719,
    2694158948,
    2699054734,
    2699567323,
    2701589506,
    2708247797,
    2710218932,
    2712973569,
    2713114330,
    2714570818,
    2714658156,
    2715859111,
    2716538256,
    2717691085,
    2718235570,
    2719851426,
    2722275573,
    2728431851,
    2731033959,
    2733567145,
    2745064373,
    2747735009,
    2748168364,
    2748310006,
    2753354596,
    2761147374,
    2762813598,
    2767767034,
    2769808878,
    2775691349,
    2789347571,
    2792452218,
    2793624174,
    2794767436,
    2795183554,
    2795185357,
    2795205893,
    2798224110,
    2803597621,
    2804113804,
    2807804736,
    2809486328,
    2812191981,
    2813025413,
    2815428841,
    2815585428,
    2816618421,
    2819662823,
    2822221150,
    2824682484,
    2828575765,
    2828866516,
    2829935276,
    2834927579,
    2836892761,
    2839658405,
    2844621372,
    2844815106,
    2845489684,
    2845638303,
    2857120519,
    2857193006,
    2859698097,
    2860702321,
    2870435535,
    2874906565,
    2880233005,
    2885526550,
    2889073982,
    2893961579,
    2896360091,
    2896815948,
    2898520762,
    2898642745,
    2908250170,
    2908376536,
    2911135641,
    2915014315,
    2918403731,
    2918486269,
    2919235927,
    2920587887,
    2922468503,
    2922493886,
    2923084706,
    2929584080,
    2931398379,
    2931402541,
    2934893225,
    2937779198,
    2941551192,
    2942859576,
    2948690168,
    2948867989,
    2949433359,
    2951266128,
    2954570766,
    2956489777,
    2960184498,
    2960188722,
    2960612931,
    2962892549,
    2963032843,
    2966548328,
    2976545290,
    2976620947,
    2978924197,
    2982913903,
    2986096991,
    2987284613,
    2988637881,
    2993692642,
    2996709992,
    2999106536,
    3000568496,
    3005531064,
    3005732955,
    3007175865,
    3007286028,
    3008753857,
    3010444860,
    3010880247,
    3019938621,
    3020499579,
    3022866914,
    3023311759,
    3024482653,
    3024795687,
    3024807531,
    3027071777,
    3029820267,
    3032088673,
    3032839979,
    3033043261,
    3033965900,
    3036878933,
    3037343835,
    3038234864,
    3051293097,
    3052701732,
    3055037923,
    3056484673,
    3060407188,
    3061523114,
    3071254387,
    3071254500,
    3071254881,
    3073058130,
    3074871971,
    3074935051,
    3075008146,
    3075048985,
    3075285442,
    3075422693,
    3075548305,
    3075766008,
    3075860343,
    3075962648,
    3076097045,
    3077391764,
    3079190285,
    3085252246,
    3091553195,
    3103424085,
    3107541791,
    3107727924,
    3107749241,
    3107778469,
    3107783354,
    3107787446,
    3107790299,
    3107948057,
    3107956419,
    3107974264,
    3107984588,
    3107991466,
    3108296169,
    3111583245,
    3113459538,
    3116256345,
    3116975703,
    3117043431,
    3121647752,
    3123411243,
    3123445549,
    3123737595,
    3127243644,
    3131616468,
    3134139083,
    3134716611,
    3141709512,
    3148676509,
    3154082174,
    3155375542,
    3160028447,
    3163162577,
    3163167462,
    3163515572,
    3163650864,
    3172095015,
    3178395499,
    3179705353,
    3183658699,
    3187099641,
    3187299343,
    3189362935,
    3189614929,
    3189845278,
    3191231848,
    3191324353,
    3196795314,
    3196799538,
    3197664642,
    3200115829,
    3202732235,
    3206363778,
    3207294280,
    3218691622,
    3224832477,
    3226582088,
    3231960701,
    3231960825,
    3238444781,
    3240506687,
    3241127686,
    3245505639,
    3246685420,
    3255250502,
    3255475289,
    3255493270,
    3258010725,
    3259268259,
    3259708744,
    3272088211,
    3277477189,
    3287497511,
    3289363789,
    3294281816,
    3300709686,
    3302430666,
    3307080284,
    3310372188,
    3310580422,
    3313110325,
    3317570505,
    3323504524,
    3331794938,
    3332552236,
    3344936763,
    3351242611,
    3354164541,
    3356161036,
    3357443896,
    3358280978,
    3360549707,
    3361435146,
    3362509089,
    3362630778,
    3366341181,
    3366920760,
    3368509209,
    3372160500,
    3373297021,
    3374596217,
    3375285141,
    3377755895,
    3379029866,
    3380241983,
    3380595728,
    3381834713,
    3385946526,
    3386125251,
    3388057612,
    3393544563,
    3404840083,
    3405857857,
    3407191084,
    3408814815,
    3408819560,
    3409018494,
    3409457570,
    3410577155,
    3411051814,
    3411102162,
    3413983999,
    3416635233,
    3418887913,
    3424150275,
    3426036948,
    3426656604,
    3429124000,
    3430316367,
    3430320824,
    3430870942,
    3431771155,
    3432731814,
    3434192147,
    3440930072,
    3441289467,
    3448289841,
    3448536520,
    3452859864,
    3455445539,
    3455973701,
    3456106851,
    3456282588,
    3457601666,
    3463597433,
    3467469261,
    3473077716,
    3481649290,
    3487446962,
    3488816292,
    3495434909,
    3503723552,
    3503962589,
    3503975251,
    3504086267,
    3504111353,
    3504116046,
    3504274912,
    3506277065,
    3508805241,
    3509081590,
    3511319965,
    3513566261,
    3515728076,
    3515960057,
    3516630755,
    3523519258,
    3526432473,
    3530287752,
    3530798581,
    3531066474,
    3531601080,
    3532265658,
    3532567787,
    3533680386,
    3538145547,
    3540002868,
    3540019679,
    3541120058,
    3551826674,
    3554146688,
    3557238629,
    3557288966,
    3560409651,
    3560721423,
    3560755308,
    3560772904,
    3560776799,
    3560843986,
    3563273081,
    3564677062,
    3564681286,
    3567399383,
    3582031081,
    3584271853,
    3584286131,
    3585048866,
    3585049834,
    3585528102,
    3593775985,
    3599378282,
    3602300234,
    3607509617,
    3611661676,
    3611790203,
    3621964687,
    3621965124,
    3621966081,
    3621966083,
    3621968414,
    3621969916,
    3621970585,
    3621975893,
    3622095083,
    3622538650,
    3627671724,
    3631197772,
    3636965307,
    3639447013,
    3650032210,
    3667545339,
    3668394990,
    3668555001,
    3668632957,
    3671699945,
    3674122558,
    3682693088,
    3690182854,
    3691035506,
    3691048605,
    3691317036,
    3693068020,
    3697923226,
    3699114476,
    3702342894,
    3706900355,
    3708334595,
    3709045244,
    3712703179,
    3712728440,
    3712733478,
    3718845099,
    3718930524,
    3720827503,
    3728968422,
    3729352785,
    3730027878,
    3734185373,
    3735541918,
    3737224996,
    3738382782,
    3738387349,
    3738389800,
    3738389990,
    3738390006,
    3738390241,
    3738390427,
    3738394220,
    3738394620,
    3738394722,
    3738394744,
    3738394859,
    3738396519,
    3738397033,
    3738399064,
    3738400460,
    3738887202,
    3738887334,
    3739466542,
    3743223168,
    3743289449,
    3744330913,
    3745299015,
    3748385635,
    3749221030,
    3756564018,
    3766265917,
    3766587032,
    3767014136,
    3767872686,
    3768672199,
    3771941409,
    3772113601,
    3772128853,
    3772772804,
    3776028623,
    3776032376,
    3777321837,
    3777702607,
    3777706691,
    3777840696,
    3778052019,
    3778877784,
    3788596678,
    3788641118,
    3789096147,
    3790949066,
    3792555306,
    3792675197,
    3794434962,
    3795445637,
    3799396589,
    3802359444,
    3802425981,
    3802900168,
    3803509878,
    3803533553,
    3803824710,
    3817195077,
    3825134626,
    3831783888,
    3836226283,
    3837130236,
    3839963077,
    3842564401,
    3842605521,
    3845461162,
    3845489549,
    3848928610,
    3854658802,
    3856336918,
    3857323999,
    3858008723,
    3862352064,
    3867966833,
    3870049918,
    3871085378,
    3871829833,
    3872291932,
    3872427595,
    3873740388,
    3875975886,
    3876231871,
    3878080222,
    3881750832,
    3882302039,
    3886373040,
    3890622701,
    3890644440,
    3890892359,
    3896043913,
    3896689307,
    3899279503,
    3900747045,
    3906847659,
    3911916015,
    3927826024,
    3935292304,
    3943337509,
    3944324480,
    3944448839,
    3945529821,
    3947301018,
    3949488650,
    3950038675,
    3952494101,
    3960241116,
    3960376152,
    3961917741,
    3963099658,
    3963421060,
    3963723254,
    3967007952,
    3967259205,
    3969124422,
    3970612783,
    3970678261,
    3973713485,
    3975040093,
    3975243357,
    3975693785,
    3987058095,
    3989825156,
    3989847268,
    3990634986,
    3990704705,
    3992681822,
    3994071046,
    3995478227,
    3998971354,
    3999298006,
    4000670401,
    4000993351,
    4001099777,
    4001277861,
    4001735503,
    4002465742,
    4003357293,
    4005356768,
    4007925342,
    4011050686,
    4011066530,
    4011075332,
    4011273939,
    4011552428,
    4011788459,
    4012217148,
    4012217259,
    4024186918,
    4027830515,
    4028975169,
    4029110469,
    4029583348,
    4030423947,
    4031498693,
    4031499367,
    4031499504,
    4031509172,
    4031928713,
    4032208645,
    4032479130,
    4033316487,
    4036743247,
    4038287798,
    4038545865,
    4040900190,
    4042024153,
    4059950647,
    4061045790,
    4064482362,
    4064482494,
    4064686007,
    4068398139,
    4074270800,
    4074270919,
    4074308286,
    4075674315,
    4075712516,
    4075885548,
    4078878227,
    4080178633,
    4081049105,
    4089654486,
    4090206590,
    4090679933,
    4091412422,
    4095259202,
    4095274203,
    4097043581,
    4097047544,
    4097047888,
    4097050487,
    4097053538,
    4097079538,
    4097094723,
    4097094855,
    4097218811,
    4097289420,
    4097298261,
    4097355529,
    4097358800,
    4097358806,
    4097359478,
    4097365147,
    4097365569,
    4097368351,
    4097368475,
    4097373732,
    4097381131,
    4097390898,
    4097493023,
    4097494448,
    4097500420,
    4097504860,
    4097508952,
    4097518447,
    4097523657,
    4097528230,
    4097528249,
    4097565588,
    4097595928,
    4097769515,
    4097769660,
    4097770040,
    4097900631,
    4097993352,
    4097993363,
    4098078311,
    4098093255,
    4098096816,
    4098101881,
    4098102013,
    4098120408,
    4099257624,
    4099391059,
    4100119818,
    4101141701,
    4101990706,
    4102099355,
    4102141580,
    4102295291,
    4103385373,
    4104416776,
    4108421678,
    4108481771,
    4113654278,
    4119925923,
    4120143040,
    4120573143,
    4120685305,
    4120832270,
    4121323786,
    4122797449,
    4123137490,
    4123141719,
    4123166778,
    4123237466,
    4124517918,
    4124852870,
    4126190390,
    4126265264,
    4126330058,
    4126584791,
    4128561486,
    4130538182,
    4130665595,
    4135804702,
    4138805004,
    4138959002,
    4142649353,
    4143010615,
    4143011353,
    4149276818,
    4149741566,
    4155964946,
    4160851306,
    4165043845,
    4165602674,
    4166101816,
    4168666626,
    4168671212,
    4169534192,
    4169538416,
    4175499442,
    4178182706,
    4179726175,
    4180321577,
    4180398911,
    4180437564,
    4180584501,
    4180592595,
    4180655876,
    4182610142,
    4190427894,
    4190436241,
    4190438903,
    4190464587,
    4190536489,
    4191350062,
    4197904504,
    4208748285,
    4213114634,
    4213114766,
    4213115878,
    4213133169,
    4213139443,
    4216213600,
    4229539334,
    4230260404,
    4236039784,
    4239211903,
    4244301284,
    4244359264,
    4244636840,
    4244650461,
    4244697370,
    4246504751,
    4248927363,
    4249781266,
    4250093591,
    4255547342,
    4269915810,
    4271230391,
    4273205904,
    4280822506,
    4281987205,
    4281991429,
    4288642117,
    4290818353,
    4290862694,
    4290938088,
    4291163255,
    4291519114,
    4292375442,
    1685,
    113029,
    2431109,
    9085905,
    10454523,
    11833936,
    15005411,
    29039073,
    29369909,
    32348563,
    32392946,
    34831997,
    35241656,
    35407085,
    38660731,
    41719852,
    42040525,
    44148994,
    49751269,
    54657448,
    54829135,
    56701348,
    61297674,
    64616140,
    64789207,
    64792746,
    65243007,
    69912355,
    73497087,
    75564691,
    84754216,
    85474843,
    88950783,
    95227810,
    97869711,
    98556036,
    99860970,
    111529024,
    118457586,
    119013459,
    124940101,
    129204800,
    129504899,
    132934253,
    133576354,
    140643360,
    141325108,
    142928709,
    144351849,
    147399388,
    148485881,
    153516070,
    162751717,
    164324729,
    165338893,
    166383271,
    169804649,
    169909381,
    170281316,
    170281555,
    170281599,
    170281951,
    172221532,
    172281601,
    173287589,
    173930363,
    176844018,
    177079695,
    177546706,
    179139641,
    179569944,
    179956098,
    180259371,
    181198501,
    181205574,
    181240422,
    181950714,
    182150488,
    183129361,
    183468910,
    183469260,
    186043176,
    187501046,
    187763081,
    189174183,
    190912115,
    193357074,
    193420201,
    193885172,
    194024818,
    194130004,
    195040605,
    195184107,
    195615400,
    195788148,
    196491587,
    201802654,
    202716248,
    203969128,
    204000291,
    204003102,
    205844479,
    207663471,
    208540214,
    211702237,
    213315812,
    216283771,
    216404638,
    221220686,
    225036633,
    233832515,
    235585683,
    236122625,
    238349947,
    244953360,
    244983020,
    253603556,
    270508724,
    274628826,
    279497384,
    282260013,
    282734069,
    286117940,
    288337735,
    294222691,
    294944592,
    297796540,
    299806932,
    301175958,
    305396028,
    309814229,
    316711416,
    319659866,
    321667918,
    322393118,
    323472705,
    329290740,
    336073493,
    344556873,
    345150446,
    345725228,
    346582968,
    348036069,
    348240977,
    349085323,
    352942917,
    361618841,
    362641227,
    363650316,
    368392429,
    371447569,
    379018060,
    379803748,
    381683792,
    384388494,
    390037588,
    392534911,
    393050977,
    393824765,
    398079720,
    401473592,
    404580880,
    408076405,
    409551689,
    412923104,
    413989960,
    417762611,
    418643706,
    419980117,
    420076057,
    423460135,
    424671062,
    425273951,
    430774757,
    431128362,
    431420666,
    431463230,
    433024678,
    433601547,
    433960232,
    434424313,
    440846816,
    440990792,
    445424682,
    448347366,
    453082265,
    459993498,
    467355959,
    468677861,
    470584767,
    478194174,
    481007914,
    483933287,
    492579864,
    492820046,
    495294245,
    500922416,
    501132892,
    502571724,
    503870109,
    505520155,
    505540840,
    505547348,
    507674743,
    507704542,
    508155006,
    508732896,
    508756709,
    518314331,
    524499536,
    527090713,
    528698966,
    532828844,
    533082472,
    536472645,
    536606854,
    536706420,
    543383677,
    544035780,
    545100578,
    547829195,
    548068662,
    550157112,
    554422931,
    557980541,
    558904957,
    559619560,
    566123574,
    569085212,
    569128746,
    575078226,
    579214441,
    582810837,
    583362052,
    583453417,
    594063106,
    598128236,
    601157755,
    601161740,
    601948346,
    602413319,
    603986209,
    605582466,
    609198625,
    610045978,
    617827459,
    620396524,
    626039263,
    626988485,
    629099694,
    630452394,
    635400744,
    640415961,
    643558590,
    645257576,
    652659119,
    656273907,
    665354414,
    666296511,
    667333922,
    668403785,
    669929645,
    682364285,
    689215333,
    699075989,
    704136516,
    706383966,
    708808466,
    710978465,
    712995495,
    717519098,
    722655660,
    722956329,
    725449644,
    727209749,
    729977159,
    734622016,
    735035205,
    737142807,
    737152212,
    737166334,
    737644692,
    737837074,
    739516787,
    739566545,
    739985822,
    741816033,
    742252614,
    742260586,
    745092996,
    747930588,
    750219296,
    750508933,
    752522257,
    753857751,
    754000708,
    757807602,
    758478444,
    761228031,
    762067870,
    762641736,
    764248075,
    764320946,
    764825188,
    766296725,
    766355544,
    766543587,
    766643209,
    766774330,
    767540529,
    772363084,
    774299734,
    777688891,
    787564577,
    789530990,
    792068311,
    792844833,
    796533587,
    800010738,
    800087019,
    809563086,
    810061706,
    810813298,
    811092091,
    817847511,
    819009519,
    826260124,
    833658992,
    834470340,
    839856739,
    842147301,
    847675799,
    861294299,
    862950715,
    867021650,
    867036335,
    867732810,
    869064225,
    870151875,
    874296659,
    875096251,
    875944810,
    876149555,
    879009267,
    884498580,
    887482102,
    893652881,
    894264732,
    896104248,
    896979123,
    897240751,
    902139830,
    911653942,
    912249299,
    919599881,
    927052135,
    933697266,
    933717702,
    933742623,
    939098524,
    939114841,
    948752149,
    955130439,
    955354780,
    955942299,
    956480228,
    958121442,
    961145400,
    966830075,
    968732370,
    970076747,
    972273212,
    976368569,
    976381303,
    978919739,
    981829565,
    984418838,
    997412732,
    1001458257,
    1001637783,
    1001651627,
    1005191377,
    1008948875,
    1010556097,
    1016009727,
    1016348317,
    1019849895,
    1023879932,
    1024317101,
    1027786481,
    1027856392,
    1032266307,
    1033049924,
    1035709107,
    1041294385,
    1043437244,
    1049779946,
    1051535617,
    1053737172,
    1054370922,
    1056150770,
    1056645919,
    1056720884,
    1063952736,
    1064188994,
    1064732809,
    1064857294,
    1065290596,
    1080478458,
    1081536009,
    1086069586,
    1088535269,
    1090938281,
    1094421058,
    1095718313,
    1096687866,
    1100372480,
    1101019943,
    1101043104,
    1102004406,
    1104733017,
    1110237878,
    1112959177,
    1113096701,
    1114972095,
    1118952562,
    1125668821,
    1130216203,
    1132104794,
    1132534664,
    1132579070,
    1132598106,
    1136018325,
    1137104375,
    1139265319,
    1145147923,
    1145899518,
    1146014840,
    1146523166,
    1149204820,
    1151262913,
    1152056864,
    1154446700,
    1154536335,
    1154536715,
    1154542665,
    1155367440,
    1155994599,
    1158265339,
    1158326174,
    1161218045,
    1164964007,
    1166033123,
    1166422202,
    1167024992,
    1167025137,
    1171269392,
    1174582808,
    1174756828,
    1179491634,
    1181469438,
    1186977866,
    1187653498,
    1188208310,
    1189560180,
    1191923730,
    1192723278,
    1195304992,
    1198195980,
    1199133859,
    1199554249,
    1199600208,
    1202045876,
    1204911535,
    1208429990,
    1210779948,
    1210807525,
    1221782335,
    1221920801,
    1236932222,
    1238449939,
    1246474378,
    1257256866,
    1257395124,
    1257876060,
    1257878939,
    1258281930,
    1258346504,
    1259689738,
    1260820433,
    1260836076,
    1261324364,
    1268763191,
    1269301612,
    1271531819,
    1273274467,
    1276658942,
    1282928227,
    1283757717,
    1296032318,
    1296235125,
    1301946320,
    1305140481,
    1308857550,
    1310807544,
    1310899277,
    1312056732,
    1312163653,
    1316036626,
    1316125796,
    1324285266,
    1324310094,
    1324331646,
    1324337571,
    1324579984,
    1325750278,
    1326569216,
    1333842476,
    1349684561,
    1351415139,
    1351558342,
    1351862653,
    1351880550,
    1354386923,
    1356250756,
    1356331589,
    1357629674,
    1362733356,
    1363404812,
    1364008114,
    1364487272,
    1365133140,
    1365599531,
    1365623138,
    1366730785,
    1366987615,
    1372705460,
    1372794328,
    1373871548,
    1375834117,
    1377641421,
    1378095694,
    1378253217,
    1383623210,
    1391288061,
    1391291390,
    1391293134,
    1391299074,
    1391300548,
    1391306067,
    1393577155,
    1394469288,
    1394469303,
    1394469473,
    1394469866,
    1394470005,
    1394470066,
    1396870772,
    1399867662,
    1413067533,
    1423547895,
    1430902259,
    1431096661,
    1433581041,
    1435770227,
    1436788950,
    1441443055,
    1441473969,
    1443172426,
    1444705872,
    1444722875,
    1444727957,
    1445594238,
    1447082963,
    1448082324,
    1455246557,
    1457519039,
    1458493639,
    1459794391,
    1460930084,
    1465058743,
    1465974914,
    1465976327,
    1465976425,
    1465976436,
    1465976550,
    1465976625,
    1465976632,
    1465976747,
    1465976986,
    1465976991,
    1465977196,
    1465977261,
    1465977274,
    1465977303,
    1465977323,
    1474444421,
    1478092049,
    1478716185,
    1481566528,
    1482522967,
    1489772937,
    1492902674,
    1494181387,
    1503721626,
    1504535254,
    1509029106,
    1510450262,
    1511907991,
    1515598870,
    1519441587,
    1520424549,
    1522685369,
    1525831150,
    1526085253,
    1527459723,
    1529619411,
    1532042759,
    1533712942,
    1535986906,
    1537663939,
    1539580287,
    1539902893,
    1541073018,
    1541496652,
    1542773859,
    1549199388,
    1549209224,
    1549210203,
    1553692884,
    1555806428,
    1561102750,
    1568416773,
    1570440897,
    1570561776,
    1573188605,
    1576134740,
    1582406800,
    1585380899,
    1587251606,
    1592687509,
    1594093747,
    1601662530,
    1602151715,
    1602222565,
    1602416912,
    1604313702,
    1610069144,
    1610724928,
    1613430619,
    1616149762,
    1616623247,
    1616826805,
    1622345684,
    1624120544,
    1630208269,
    1631446240,
    1634840328,
    1635306209,
    1637735434,
    1639041637,
    1640826914,
    1643893360,
    1645239134,
    1645714411,
    1646967505,
    1647700483,
    1648026812,
    1648459154,
    1652482428,
    1654623339,
    1659538076,
    1660752253,
    1661285202,
    1662950537,
    1664993389,
    1675032552,
    1676328914,
    1681382184,
    1683407715,
    1684605451,
    1684964181,
    1686375531,
    1686572406,
    1687228988,
    1687238599,
    1687241697,
    1688907428,
    1693905970,
    1694678234,
    1696017211,
    1697022103,
    1698247372,
    1700196518,
    1700874190,
    1702743585,
    1704831752,
    1705191422,
    1705572464,
    1705775316,
    1705920264,
    1708553688,
    1709604401,
    1711224201,
    1713051167,
    1715999558,
    1716087943,
    1716947524,
    1721557559,
    1722492001,
    1724478613,
    1728197301,
    1730461660,
    1732377833,
    1740500925,
    1740503023,
    1747349646,
    1747349737,
    1747349747,
    1747349811,
    1747350242,
    1747350353,
    1747350383,
    1747350483,
    1747350570,
    1754249179,
    1757625214,
    1758838683,
    1759487629,
    1759488516,
    1759498393,
    1759499821,
    1759502442,
    1759502966,
    1759512274,
    1759512283,
    1759513528,
    1759514495,
    1759514515,
    1759516437,
    1759524172,
    1759589336,
    1760335250,
    1762975960,
    1762992044,
    1763004314,
    1771261987,
    1772061961,
    1772164204,
    1772475101,
    1775305704,
    1778177081,
    1782043531,
    1788148481,
    1789421301,
    1793905730,
    1800839994,
    1801140929,
    1801396125,
    1804673412,
    1806579373,
    1813955111,
    1814430790,
    1816595094,
    1817436421,
    1822787251,
    1828043124,
    1839996532,
    1839996844,
    1841030555,
    1842560365,
    1844006530,
    1844448916,
    1844480213,
    1846724376,
    1856607747,
    1860761623,
    1861064328,
    1863000850,
    1867708596,
    1869007419,
    1872936175,
    1873771601,
    1873773882,
    1873774456,
    1873776479,
    1874142716,
    1875798230,
    1880233189,
    1882601503,
    1885862630,
    1890372289,
    1891031342,
    1891205640,
    1891938925,
    1892631265,
    1896919160,
    1896919227,
    1896919294,
    1897898461,
    1899147627,
    1900573373,
    1901379444,
    1902628941,
    1906789934,
    1906790006,
    1906790139,
    1906795057,
    1906796594,
    1906797455,
    1906801573,
    1906801694,
    1906806837,
    1906810233,
    1906810485,
    1906811690,
    1906812875,
    1906817274,
    1906818921,
    1906820915,
    1906820924,
    1906823423,
    1906823469,
    1906857590,
    1906857691,
    1906857989,
    1918700844,
    1921631441,
    1925206882,
    1927020241,
    1928994000,
    1936188797,
    1939994885,
    1941474619,
    1944071536,
    1945201987,
    1946130305,
    1946324244,
    1947055740,
    1949193282,
    1951127334,
    1960661844,
    1964294607,
    1971670426,
    1973838680,
    1975660003,
    1977074332,
    1977076352,
    1979063800,
    1987660949,
    1991785763,
    1992080509,
    1995174355,
    1995890751,
    2001507875,
    2004488903,
    2015900220,
    2018783243,
    2021213332,
    2023260368,
    2025018361,
    2025037989,
    2025039155,
    2026455612,
    2026543248,
    2027114414,
    2027551630,
    2034028822,
    2034497157,
    2034927376,
    2035815698,
    2037403782,
    2037552632,
    2038238057,
    2038463378,
    2038609522,
    2040354520,
    2040943501,
    2041028464,
    2047340057,
    2047377876,
    2047791608,
    2047824538,
    2050823774,
    2050838609,
    2051525062,
    2051827668,
    2052255777,
    2052901511,
    2053206810,
    2053240934,
    2053478875,
    2053493456,
    2053853373,
    2054449324,
    2055229681,
    2055578022,
    2056180496,
    2057710300,
    2058751811,
    2059048621,
    2061275137,
    2064241908,
    2066721635,
    2067699997,
    2071301924,
    2075934693,
    2077460241,
    2077463931,
    2082273412,
    2082279457,
    2082340026,
    2082350395,
    2082490504,
    2083899515,
    2084905908,
    2087506861,
    2087568425,
    2087595516,
    2092046651,
    2092301721,
    2092419132,
    2097381010,
    2097529923,
    2100199727,
    2103470828,
    2105481502,
    2107063121,
    2107436658,
    2113664954,
    2116750738,
    2117068897,
    2119040128,
    2122563214,
    2122618177,
    2124668692,
    2133443920,
    2133514276,
    2133540902,
    2134191641,
    2134715695,
    2138049165,
    2138494997,
    2142609419,
    2142633914,
    2144770101,
    2146688546,
    2151094932,
    2151644274,
    2153187194,
    2163712208,
    2163898589,
    2168105062,
    2176727539,
    2177318798,
    2178944930,
    2179027416,
    2184528600,
    2185606643,
    2186571792,
    2187374596,
    2190645414,
    2190660247,
    2190897184,
    2194211966,
    2195314033,
    2195413098,
    2195424198,
    2203121973,
    2211529485,
    2216861598,
    2219976143,
    2224936471,
    2229428098,
    2233205867,
    2235535537,
    2238302643,
    2239584661,
    2243922068,
    2246095470,
    2249578444,
    2251500542,
    2253395698,
    2256423319,
    2257131811,
    2258848076,
    2259012151,
    2265403416,
    2277922362,
    2278366865,
    2281444864,
    2283990470,
    2284221844,
    2290521795,
    2298483014,
    2298859942,
    2303709693,
    2305684069,
    2306183534,
    2310688315,
    2313038876,
    2315634657,
    2319104481,
    2326416557,
    2327685947,
    2330979339,
    2331542577,
    2334488740,
    2339348712,
    2340566443,
    2343955873,
    2343987387,
    2344081298,
    2354634240,
    2357782940,
    2360233424,
    2365749167,
    2372460029,
    2372478071,
    2380959235,
    2384339112,
    2385564998,
    2387086868,
    2391410598,
    2392072803,
    2393811335,
    2399346319,
    2401643245,
    2401782259,
    2403261116,
    2406918497,
    2407789481,
    2409182571,
    2417084170,
    2417165267,
    2417652035,
    2419411749,
    2419417423,
    2422324904,
    2423117096,
    2424431334,
    2424771770,
    2432634086,
    2433143557,
    2435584133,
    2436015021,
    2441679501,
    2441854846,
    2444838503,
    2451094457,
    2453483137,
    2453497460,
    2454448917,
    2456215407,
    2459247176,
    2463271525,
    2463506842,
    2467234433,
    2469945372,
    2473920266,
    2476783882,
    2485004952,
    2486666796,
    2489018185,
    2489169796,
    2490847830,
    2492077342,
    2492970238,
    2497220049,
    2503042985,
    2515254157,
    2518379243,
    2518777282,
    2525588137,
    2525608018,
    2528358668,
    2531896313,
    2539686262,
    2551310943,
    2554772601,
    2556085817,
    2558131228,
    2564231467,
    2568929373,
    2569358076,
    2571159128,
    2572746788,
    2575905107,
    2579846032,
    2582295686,
    2585286228,
    2585297154,
    2587884409,
    2590263013,
    2592032772,
    2597156358,
    2600208325,
    2602467246,
    2614031703,
    2617427457,
    2622453927,
    2622601193,
    2622997773,
    2635726130,
    2636739119,
    2637611531,
    2637745410,
    2637827916,
    2639832942,
    2644708943,
    2646831691,
    2652889161,
    2656916375,
    2658971428,
    2660417858,
    2667387895,
    2669967601,
    2671812960,
    2675377616,
    2677517890,
    2677527742,
    2680331975,
    2682569422,
    2688047810,
    2692646873,
    2694622232,
    2697812844,
    2707358863,
    2707431632,
    2708098424,
    2708256980,
    2721005193,
    2721996537,
    2727613517,
    2729386864,
    2732129495,
    2738025026,
    2739504392,
    2743561936,
    2745053658,
    2748129339,
    2755346949,
    2756835810,
    2762308724,
    2762732310,
    2772048233,
    2773342582,
    2774237802,
    2777215669,
    2779765943,
    2780442125,
    2780900117,
    2784038323,
    2786612080,
    2787145966,
    2787151566,
    2791623281,
    2792656912,
    2793843165,
    2794535853,
    2794558276,
    2794571602,
    2794589073,
    2794607684,
    2794781905,
    2794812897,
    2794904579,
    2795201682,
    2795215251,
    2795316793,
    2795413889,
    2795489178,
    2795518714,
    2795546979,
    2795547152,
    2795551511,
    2795554576,
    2795555553,
    2795567189,
    2795581043,
    2795588603,
    2796767057,
    2797512177,
    2799152382,
    2799526810,
    2799947922,
    2802973072,
    2804403738,
    2804874542,
    2805637755,
    2805753744,
    2809447657,
    2812187177,
    2812916202,
    2815541885,
    2820491263,
    2822394574,
    2829422945,
    2831048350,
    2832237259,
    2834623189,
    2837348717,
    2839958087,
    2840525902,
    2841159353,
    2842490055,
    2843506215,
    2844781614,
    2846385194,
    2846982791,
    2849248490,
    2849860412,
    2850213786,
    2852028874,
    2852573181,
    2854701866,
    2854943229,
    2855519660,
    2857974075,
    2859686627,
    2873369054,
    2873382924,
    2877054650,
    2878248977,
    2878625875,
    2880150758,
    2882016813,
    2883677644,
    2889508141,
    2894321712,
    2896549226,
    2900972274,
    2905747927,
    2907164383,
    2909422460,
    2910191497,
    2912050734,
    2914081458,
    2914744694,
    2914938714,
    2915009556,
    2917041430,
    2918571873,
    2924790692,
    2931708704,
    2932164581,
    2932643151,
    2933052029,
    2935350303,
    2939956665,
    2941858877,
    2943539162,
    2944512053,
    2944562948,
    2945364171,
    2947166646,
    2950332665,
    2953041500,
    2955690868,
    2958695479,
    2959025464,
    2963193938,
    2963907974,
    2964323647,
    2965610869,
    2969439522,
    2972958854,
    2976917923,
    2978201778,
    2982085395,
    2985605450,
    2996423818,
    2999691650,
    3008190733,
    3008855969,
    3016122305,
    3017646001,
    3023766416,
    3029366772,
    3031325313,
    3032047068,
    3036119914,
    3036992672,
    3039024727,
    3042813479,
    3050467218,
    3051886594,
    3053067553,
    3053287882,
    3065938060,
    3067331584,
    3067801157,
    3067842181,
    3068762275,
    3074108603,
    3077857486,
    3080857101,
    3087935921,
    3088190003,
    3091255985,
    3095401268,
    3096813247,
    3098725318,
    3105671535,
    3111527444,
    3115079967,
    3117883740,
    3118052513,
    3118932015,
    3119183299,
    3121944857,
    3123256667,
    3124496054,
    3126706525,
    3129135980,
    3130292716,
    3136193853,
    3143250549,
    3145203874,
    3146277579,
    3146688000,
    3150523560,
    3151212508,
    3154412692,
    3156177950,
    3159557566,
    3164499075,
    3164706839,
    3168577861,
    3171832589,
    3173559921,
    3174529089,
    3176196996,
    3176871024,
    3180784320,
    3181226348,
    3185392090,
    3187205025,
    3189849017,
    3190997898,
    3192015124,
    3206103617,
    3212240200,
    3229338204,
    3231038915,
    3236684869,
    3240062262,
    3241501460,
    3243217472,
    3244361100,
    3245554401,
    3249410406,
    3254464708,
    3257959952,
    3274402918,
    3276160836,
    3276181105,
    3276196901,
    3278107133,
    3289739448,
    3290502878,
    3291450742,
    3293286977,
    3293297241,
    3296419295,
    3299472058,
    3299767442,
    3301223392,
    3301309499,
    3301391192,
    3304599725,
    3306064327,
    3313552392,
    3328014532,
    3331885553,
    3332277580,
    3333914252,
    3337182013,
    3337858974,
    3341471161,
    3342158460,
    3346063476,
    3347209717,
    3350345047,
    3350816321,
    3351869587,
    3352060268,
    3355691995,
    3356175586,
    3357239148,
    3362723114,
    3366755503,
    3367073048,
    3367944003,
    3372319994,
    3375346812,
    3376868662,
    3382258705,
    3385088233,
    3389287501,
    3391503522,
    3392485763,
    3403435361,
    3403782237,
    3406109171,
    3406111906,
    3407122639,
    3411575670,
    3423045385,
    3424242744,
    3426100153,
    3426523263,
    3430187119,
    3431675506,
    3431798787,
    3431896672,
    3432167999,
    3432725491,
    3433958809,
    3443103158,
    3445734210,
    3450482982,
    3453219838,
    3455171543,
    3458629656,
    3460835389,
    3471910127,
    3474158466,
    3478804050,
    3479897537,
    3480605972,
    3480868929,
    3481097537,
    3485240025,
    3491815953,
    3492209950,
    3494777461,
    3500328283,
    3503665706,
    3503925212,
    3506796962,
    3514565086,
    3519718992,
    3519725933,
    3524188747,
    3529349528,
    3542452078,
    3550700124,
    3550989552,
    3551573749,
    3553175952,
    3553442167,
    3554781799,
    3556847596,
    3557221487,
    3557691349,
    3558264087,
    3560824248,
    3563344816,
    3565186253,
    3565418379,
    3566074326,
    3569886279,
    3570187564,
    3576593305,
    3584104748,
    3586564634,
    3588013803,
    3590119076,
    3591676857,
    3594126223,
    3605649145,
    3607964178,
    3610130320,
    3611466472,
    3618863110,
    3629119210,
    3629792790,
    3635135986,
    3635459541,
    3636074310,
    3638424639,
    3640911628,
    3642130958,
    3642225062,
    3647798063,
    3656108419,
    3657615451,
    3659534155,
    3659534172,
    3659611370,
    3659667263,
    3660545348,
    3660867367,
    3662104715,
    3671487562,
    3674207720,
    3678946749,
    3680027665,
    3684023399,
    3686510836,
    3686613485,
    3686646984,
    3691543485,
    3691543777,
    3694814128,
    3695175653,
    3697285380,
    3698130051,
    3700803863,
    3704722354,
    3717443225,
    3718851041,
    3722297297,
    3724304421,
    3727475379,
    3727535579,
    3735375385,
    3735382080,
    3740438523,
    3740440657,
    3748157778,
    3751843037,
    3759175702,
    3760229117,
    3767579376,
    3767636566,
    3774416951,
    3774620406,
    3775107448,
    3777554302,
    3784459817,
    3789217359,
    3790213466,
    3791430232,
    3792756850,
    3797275201,
    3797334865,
    3797547975,
    3797752814,
    3798120765,
    3799727891,
    3800284920,
    3804066593,
    3807736858,
    3811590943,
    3812650457,
    3814583456,
    3816238011,
    3818244185,
    3821631768,
    3824973847,
    3830752599,
    3831121452,
    3831131041,
    3837373870,
    3839962587,
    3842157165,
    3849728326,
    3849729892,
    3849734551,
    3849787726,
    3849792721,
    3849819373,
    3853184002,
    3854490492,
    3856121458,
    3857014848,
    3860607422,
    3861431943,
    3861926244,
    3867504094,
    3869648625,
    3871255217,
    3879613384,
    3888702999,
    3893630517,
    3895969787,
    3897018811,
    3898712433,
    3902486573,
    3904611129,
    3909678524,
    3911290870,
    3914258422,
    3919568627,
    3924938673,
    3928836058,
    3929271846,
    3932881151,
    3932899585,
    3934007962,
    3950379841,
    3960912026,
    3973890763,
    3976040035,
    3977971580,
    3981048153,
    3981060932,
    3981985710,
    3988202550,
    3991078309,
    3992022849,
    3992259208,
    3993609185,
    4010941807,
    4012569891,
    4013412307,
    4021161495,
    4025854722,
    4027536004,
    4030686503,
    4033312623,
    4037300319,
    4043405137,
    4048222256,
    4048420974,
    4048962899,
    4049948378,
    4051811237,
    4052267313,
    4062598208,
    4064836207,
    4066383490,
    4070580503,
    4073707968,
    4080427569,
    4104807039,
    4115427659,
    4116271014,
    4117626035,
    4127381498,
    4128299636,
    4132054341,
    4132795027,
    4133480683,
    4136878052,
    4138537192,
    4138587115,
    4148483014,
    4149626272,
    4149641566,
    4149809179,
    4152090640,
    4152153727,
    4154732349,
    4156628388,
    4157060403,
    4159166567,
    4161006924,
    4161031359,
    4166727800,
    4167095051,
    4168702437,
    4168921085,
    4175490343,
    4178043127,
    4179607399,
    4182917435,
    4196816243,
    4201195770,
    4201710836,
    4204344500,
    4207814302,
    4216249688,
    4218603456,
    4220181346,
    4230252988,
    4230808631,
    4236867197,
    4243509465,
    4245730359,
    4250048329,
    4251017064,
    4254397175,
    4261049438,
    4265986719,
    4266150865,
    4270257086,
    4272517612,
    4285995571,
    4287463560,
    4287809158,
    4287924367,
    4293141634,
    4293320049,
    7,
    171252454,
    314658260,
    1911007288,
    2310391087,
    2705648135,
    3085052283,
    4199583372,
    0,
    0,
    44,
    66987915,
    193433406,
    366428436,
    366991379,
    487687151,
    631419393,
    649399193,
    716916462,
    900018457,
    911616432,
    914855142,
    981141093,
    981156754,
    1135523977,
    1213136917,
    1357549542,
    1437166305,
    1491010671,
    1491010869,
    1881252413,
    2035443912,
    2412701058,
    2447973967,
    2572472237,
    2572499572,
    2572504631,
    2734871983,
    2856570282,
    2856570297,
    2873757688,
    2905936018,
    3109459404,
    3147193074,
    3229893628,
    3497603669,
    3613204738,
    3628727675,
    4020469118,
    4072506013,
    4072506079,
    4072506170,
    4072506203,
    4072506236,
    4072506360,
    1985,
    3609572,
    4707302,
    4731941,
    7066741,
    12732264,
    12733869,
    12874473,
    12898727,
    15239865,
    15443925,
    15464989,
    17770158,
    18806137,
    22641470,
    34805542,
    37254453,
    38352510,
    47103897,
    47124528,
    47160482,
    47264668,
    47270558,
    47521880,
    47670735,
    47682584,
    48206184,
    54052064,
    55399270,
    55790429,
    57861540,
    64629239,
    65951659,
    73540622,
    74816563,
    79005572,
    79010572,
    79432449,
    79977826,
    80960607,
    90941114,
    91781471,
    93732497,
    101061895,
    101792620,
    105281118,
    114635485,
    121111459,
    126395821,
    127613999,
    134819976,
    135124399,
    135156325,
    135512978,
    139443164,
    140195744,
    146403274,
    147165318,
    147311351,
    147680945,
    154712981,
    156193153,
    157683252,
    162021680,
    165184869,
    165682351,
    167795310,
    169177047,
    169285407,
    170248114,
    175536255,
    176298648,
    181584625,
    186190871,
    188366635,
    190461039,
    190805290,
    190817793,
    191644192,
    193330267,
    200367649,
    204872798,
    208246903,
    213994908,
    222038678,
    222914983,
    226753977,
    227658815,
    230657663,
    231976681,
    232418677,
    234224516,
    235125560,
    235385397,
    235630461,
    235880887,
    236100347,
    237106084,
    237695302,
    243768879,
    244905302,
    245221564,
    245221621,
    245248688,
    246957980,
    247379872,
    247404538,
    247547714,
    249186148,
    249832804,
    250298968,
    252007821,
    252166643,
    254498243,
    256250975,
    256734086,
    257675257,
    258276240,
    260078806,
    269653037,
    270614174,
    270803459,
    279865482,
    290747254,
    296104342,
    296106331,
    296214241,
    297365588,
    297388265,
    297388314,
    297395043,
    297872731,
    297875338,
    305678573,
    310113063,
    317059542,
    318726251,
    320983337,
    321380700,
    329390871,
    340233049,
    343985311,
    368331859,
    368339983,
    374202536,
    374729119,
    377042975,
    377218502,
    377330983,
    379160277,
    387137528,
    390536878,
    397426025,
    410462833,
    410898354,
    411028646,
    415359567,
    418289923,
    418809394,
    420699727,
    422768411,
    423087664,
    434374676,
    434499530,
    439966930,
    443910462,
    444881445,
    446735168,
    470802373,
    473022090,
    475752042,
    480190019,
    481797890,
    482141996,
    493334140,
    493996949,
    494002753,
    494111972,
    496668263,
    497004637,
    505642028,
    513006918,
    520166698,
    522732652,
    524323805,
    524791178,
    525296785,
    532366388,
    537994409,
    538156652,
    539123093,
    539125333,
    540384923,
    545724556,
    546598380,
    552815312,
    564847266,
    572585472,
    572589595,
    572660745,
    572917514,
    572938118,
    581295982,
    583116728,
    584477771,
    585356786,
    585510953,
    586974440,
    588341431,
    590260151,
    593171510,
    600861600,
    602587622,
    608185550,
    608501000,
    611172806,
    617227910,
    620862123,
    625412750,
    626878575,
    627192073,
    628675473,
    636454657,
    644892435,
    645708934,
    646772532,
    650376939,
    653264074,
    653865504,
    654835286,
    655274400,
    657684596,
    657843927,
    665654464,
    665772443,
    667917050,
    667982163,
    668803663,
    678409190,
    685972429,
    687873546,
    699223116,
    722349553,
    723381066,
    723506578,
    725289629,
    728910939,
    728916446,
    729301272,
    730375222,
    731520837,
    731524865,
    731524893,
    733458327,
    734942836,
    742063133,
    744425628,
    745118723,
    750501894,
    753379261,
    753585532,
    755936840,
    755999442,
    757164322,
    757742871,
    758908039,
    758927262,
    766978617,
    767310694,
    767319597,
    768502512,
    775086059,
    775783015,
    776818569,
    777129529,
    782249017,
    782470551,
    782586541,
    783225086,
    783819749,
    787058931,
    793173186,
    793643539,
    793791572,
    794069868,
    797737785,
    801549019,
    805476735,
    809560577,
    810471911,
    810660018,
    813069363,
    813965189,
    814609400,
    819689086,
    822265343,
    827811881,
    828807618,
    840895172,
    842670706,
    845178939,
    849626506,
    857304293,
    867054787,
    875581912,
    878480613,
    878489001,
    888652626,
    892902192,
    904040802,
    904780949,
    904781069,
    904781208,
    904781211,
    904781269,
    904781270,
    904781407,
    904781445,
    904781469,
    904781569,
    904781597,
    904781741,
    904781750,
    904781797,
    904781798,
    907680375,
    909542970,
    913350787,
    915552624,
    943105427,
    944616168,
    945567936,
    946059164,
    946112067,
    950116031,
    950459761,
    950797941,
    950991772,
    952407653,
    954708706,
    954904735,
    956279390,
    959296218,
    959317553,
    960000436,
    960088334,
    964474682,
    965248297,
    965252181,
    968600148,
    969495568,
    969714387,
    969714391,
    969714751,
    975014436,
    976847064,
    977515724,
    978655375,
    985441466,
    985451059,
    988676432,
    989199112,
    995754553,
    995754557,
    998100773,
    998582596,
    1001682227,
    1002897238,
    1005026102,
    1007267340,
    1018029509,
    1019292109,
    1021170671,
    1021615491,
    1027478448,
    1027904949,
    1028176876,
    1028524011,
    1033544761,
    1037073656,
    1039464298,
    1041396131,
    1043364491,
    1051084878,
    1053049944,
    1055328538,
    1055480209,
    1058862972,
    1066609925,
    1068948457,
    1071874351,
    1072134738,
    1082834847,
    1084511341,
    1087693738,
    1089012798,
    1089634494,
    1093384439,
    1093825560,
    1094815391,
    1098082937,
    1102471353,
    1113642022,
    1113846049,
    1121249692,
    1127953536,
    1132317159,
    1132485954,
    1132585385,
    1132689597,
    1132723356,
    1132858392,
    1133501028,
    1133636064,
    1134046361,
    1134351151,
    1134824033,
    1135467502,
    1135737574,
    1135775689,
    1136782059,
    1136883336,
    1137085890,
    1137173922,
    1138138823,
    1138714596,
    1139072942,
    1139153897,
    1139221159,
    1139981182,
    1140405028,
    1140510661,
    1141246959,
    1141280718,
    1141381995,
    1141584549,
    1141719585,
    1141874653,
    1142159541,
    1142193300,
    1142260818,
    1142366610,
    1144440814,
    1144457023,
    1144667374,
    1144802410,
    1144975561,
    1145579956,
    1145625081,
    1147135141,
    1147314976,
    1148184718,
    1148522564,
    1149131059,
    1150514349,
    1150729533,
    1151393172,
    1151494449,
    1153073825,
    1154465661,
    1155177503,
    1156094385,
    1156940664,
    1158572559,
    1160038984,
    1160487168,
    1161167906,
    1161578459,
    1161965872,
    1162013821,
    1163255421,
    1163472226,
    1163645377,
    1163777146,
    1163979700,
    1164916562,
    1165010690,
    1165068597,
    1165937726,
    1165940993,
    1166410608,
    1167096330,
    1167193469,
    1167260731,
    1167598577,
    1169823858,
    1170720439,
    1171147706,
    1171150005,
    1180230175,
    1180849387,
    1188216287,
    1188228500,
    1188701654,
    1190334387,
    1190352716,
    1190641324,
    1202600586,
    1206718941,
    1209302133,
    1214814043,
    1216095517,
    1220486075,
    1223892937,
    1224444732,
    1225577971,
    1229986049,
    1243738793,
    1247471306,
    1252266596,
    1252792940,
    1253960230,
    1254127330,
    1255848785,
    1255859538,
    1257563663,
    1257583343,
    1258195056,
    1258213434,
    1262993336,
    1263908042,
    1265512654,
    1267283463,
    1278475387,
    1281229947,
    1281889125,
    1284797630,
    1288585218,
    1290240457,
    1290513099,
    1293031053,
    1295516865,
    1297095740,
    1297597617,
    1298827289,
    1298832842,
    1299380998,
    1300818337,
    1304310342,
    1304455504,
    1310534169,
    1316956180,
    1336232039,
    1337809090,
    1340075459,
    1343684265,
    1347737800,
    1348149256,
    1354685816,
    1355025196,
    1357282216,
    1357301365,
    1363667295,
    1364395531,
    1364732891,
    1373278040,
    1373514813,
    1373685873,
    1375205051,
    1375419602,
    1376146087,
    1380234474,
    1380513046,
    1381723825,
    1382632688,
    1382645602,
    1382709874,
    1386126578,
    1388184353,
    1389190819,
    1389902309,
    1389912616,
    1390104485,
    1390958270,
    1391687090,
    1391699393,
    1393151104,
    1395748391,
    1395924208,
    1397018707,
    1397022500,
    1397827261,
    1398423514,
    1400330808,
    1401462671,
    1410284129,
    1411428439,
    1412479074,
    1412717811,
    1412831927,
    1420822802,
    1423109435,
    1423890423,
    1424552007,
    1425040900,
    1428131728,
    1431817030,
    1431897749,
    1433480127,
    1433483767,
    1434457973,
    1451286836,
    1451565010,
    1452211848,
    1452224159,
    1455851258,
    1458060161,
    1458176029,
    1458620255,
    1463365872,
    1466302404,
    1472319400,
    1475303091,
    1484355552,
    1486115226,
    1486401243,
    1489893113,
    1490054949,
    1492145100,
    1494001659,
    1494630697,
    1494690535,
    1494695213,
    1494714660,
    1494714786,
    1494714930,
    1494889015,
    1494990523,
    1494992680,
    1494997876,
    1495466906,
    1500014997,
    1502962162,
    1504548128,
    1505655813,
    1508029184,
    1508045454,
    1509815249,
    1518807662,
    1524160328,
    1529373691,
    1536802563,
    1538089784,
    1539586715,
    1544812783,
    1547140470,
    1552392687,
    1552405115,
    1552405169,
    1553111822,
    1553462237,
    1554120313,
    1554158027,
    1555241094,
    1555436471,
    1555595989,
    1556675361,
    1557492455,
    1557696008,
    1558835738,
    1558865070,
    1559582938,
    1559928005,
    1561078602,
    1565016185,
    1565113430,
    1565407826,
    1568314306,
    1568314316,
    1568317266,
    1568696751,
    1568699472,
    1568940804,
    1569248185,
    1570879860,
    1573625992,
    1573800670,
    1576869802,
    1581247153,
    1581398717,
    1581675892,
    1581718434,
    1583510121,
    1583803496,
    1588886160,
    1595292826,
    1602148307,
    1605015374,
    1609481646,
    1612153257,
    1618209596,
    1618218864,
    1618873873,
    1619384363,
    1624861042,
    1630153983,
    1638526919,
    1639454708,
    1640524262,
    1641042489,
    1641812886,
    1647303548,
    1648240296,
    1650468220,
    1650500409,
    1651513056,
    1658862087,
    1658979753,
    1661301475,
    1667470132,
    1667473335,
    1667728240,
    1667806132,
    1677105623,
    1680875001,
    1680882207,
    1681660610,
    1685495090,
    1685495093,
    1685495270,
    1685495398,
    1688394353,
    1688567575,
    1688665455,
    1688778883,
    1690751126,
    1691125863,
    1693300755,
    1694472929,
    1703388735,
    1709297356,
    1709313729,
    1712511978,
    1715661089,
    1717927392,
    1718114956,
    1721373840,
    1722360575,
    1724823399,
    1726408681,
    1726606395,
    1726645504,
    1732927910,
    1736066754,
    1736347741,
    1740486766,
    1742215384,
    1745377406,
    1758824175,
    1758930481,
    1758975612,
    1759122505,
    1759143730,
    1759143733,
    1759227293,
    1759313682,
    1759313685,
    1759412017,
    1759432510,
    1759498975,
    1759505228,
    1759507354,
    1759515800,
    1759642661,
    1759864276,
    1759893786,
    1760159824,
    1763810143,
    1766750547,
    1769211545,
    1769618102,
    1772590156,
    1775156822,
    1780760274,
    1783870720,
    1784406502,
    1786353732,
    1793007575,
    1811810046,
    1815656403,
    1816569647,
    1816866992,
    1822574126,
    1822868024,
    1822868031,
    1823268852,
    1823275309,
    1823288115,
    1823390804,
    1823768300,
    1833535991,
    1842420860,
    1844031908,
    1844296341,
    1844524436,
    1844853963,
    1845272265,
    1845433501,
    1850725233,
    1851761689,
    1851765614,
    1852766386,
    1853687691,
    1854177922,
    1861204803,
    1863593250,
    1872674263,
    1872992134,
    1873841021,
    1877281407,
    1877305076,
    1881597618,
    1884316146,
    1886743174,
    1887188539,
    1892879921,
    1905997196,
    1912353097,
    1916296381,
    1919640688,
    1919643810,
    1924325687,
    1935798204,
    1935801369,
    1935813711,
    1935815187,
    1935818499,
    1941710024,
    1944260378,
    1945210145,
    1951157591,
    1955955663,
    1957378415,
    1957388660,
    1957444069,
    1958153525,
    1958153878,
    1962799016,
    1964448624,
    1967235715,
    1967514117,
    1968334692,
    1970709900,
    1974828022,
    1977445003,
    1980811473,
    1981302481,
    1984866213,
    1986874949,
    1987285901,
    1987558613,
    1988913069,
    1998855379,
    2023930736,
    2026542768,
    2029442974,
    2029502301,
    2031253491,
    2041190670,
    2044176332,
    2044519717,
    2044521677,
    2044845895,
    2044862336,
    2050748464,
    2055299797,
    2059226128,
    2060744697,
    2060874008,
    2061631935,
    2062602594,
    2062613436,
    2062713055,
    2062721365,
    2062782118,
    2064194523,
    2064289093,
    2064667157,
    2064835977,
    2065546931,
    2065580690,
    2065783508,
    2066019598,
    2067177842,
    2067640249,
    2068518016,
    2068619301,
    2069026672,
    2069773511,
    2070805664,
    2073324624,
    2075547993,
    2076314666,
    2076760108,
    2076927096,
    2078661044,
    2080078919,
    2080126248,
    2080270176,
    2080768362,
    2080948565,
    2081049148,
    2081811414,
    2082081519,
    2083365940,
    2084275182,
    2089789238,
    2090043919,
    2090165361,
    2090287045,
    2092471497,
    2092773191,
    2093281591,
    2093290649,
    2093484170,
    2095261287,
    2096596043,
    2096775591,
    2100685312,
    2102866955,
    2108433077,
    2109903284,
    2110249550,
    2112026046,
    2112754908,
    2114424326,
    2115251185,
    2116737470,
    2118764990,
    2119510407,
    2120903194,
    2121183749,
    2121530494,
    2121539444,
    2122085862,
    2123968241,
    2123974461,
    2124038667,
    2126585211,
    2127702833,
    2127711196,
    2129393172,
    2140172366,
    2141043403,
    2144163444,
    2144352359,
    2146552134,
    2146559400,
    2146579609,
    2146771534,
    2146787712,
    2147192784,
    2149214372,
    2150227387,
    2151276842,
    2152677197,
    2158829447,
    2159124528,
    2159550475,
    2161337980,
    2161361535,
    2163722410,
    2163917836,
    2165826914,
    2169168320,
    2170868227,
    2173022808,
    2174751247,
    2179048400,
    2184998274,
    2196541409,
    2200622033,
    2203412941,
    2206322353,
    2208794483,
    2219653172,
    2219657520,
    2225010953,
    2226828879,
    2238722895,
    2238722920,
    2238723506,
    2241976578,
    2245936247,
    2248375230,
    2249276550,
    2249625301,
    2254065144,
    2254179087,
    2254183431,
    2254275149,
    2254449430,
    2254449877,
    2255178054,
    2264880989,
    2270863210,
    2290294367,
    2304704334,
    2304866355,
    2305219189,
    2310350875,
    2310486036,
    2312897274,
    2314773060,
    2315564905,
    2319231065,
    2319463533,
    2325240383,
    2327016339,
    2330482855,
    2337919027,
    2340169455,
    2359883328,
    2361871491,
    2366081778,
    2369823335,
    2369831600,
    2371523459,
    2372759050,
    2374977123,
    2376431395,
    2378889732,
    2382890223,
    2383755454,
    2386589953,
    2387052696,
    2389856295,
    2391789782,
    2398718314,
    2399324290,
    2400888860,
    2401211408,
    2404756392,
    2406557074,
    2407241140,
    2409418646,
    2411497922,
    2411691127,
    2413846222,
    2413908037,
    2414944572,
    2415208709,
    2417936111,
    2419639306,
    2423159152,
    2423360684,
    2425978408,
    2428076111,
    2437572023,
    2440527060,
    2444775143,
    2449407487,
    2457428534,
    2469735934,
    2475146676,
    2475744613,
    2476033552,
    2476112212,
    2476147614,
    2477393954,
    2478803388,
    2479415778,
    2482075359,
    2485317413,
    2485370363,
    2488499588,
    2488699734,
    2491415998,
    2492607180,
    2493496209,
    2497515972,
    2499072481,
    2499532790,
    2504383993,
    2504870149,
    2505121421,
    2505147736,
    2513647314,
    2513693640,
    2513701512,
    2513706827,
    2521253655,
    2521398855,
    2526527953,
    2526528078,
    2527291586,
    2527292245,
    2527666001,
    2528098475,
    2536669081,
    2536933437,
    2537106090,
    2538335365,
    2541170503,
    2541170604,
    2541177518,
    2545965593,
    2546249066,
    2546819122,
    2548278991,
    2548782015,
    2549421379,
    2557808039,
    2557863700,
    2558865115,
    2568950385,
    2569073380,
    2569341502,
    2569405925,
    2570837952,
    2575053435,
    2575619554,
    2575627585,
    2579451785,
    2581687876,
    2582936524,
    2586547509,
    2590439971,
    2600983050,
    2602643559,
    2605946857,
    2608238576,
    2608504686,
    2611889973,
    2612202111,
    2619739935,
    2621175072,
    2627204334,
    2627570013,
    2627677159,
    2631480810,
    2631901285,
    2635187702,
    2637430468,
    2638897207,
    2639751704,
    2642390316,
    2644459471,
    2644532855,
    2644906311,
    2645171587,
    2647433605,
    2647443463,
    2649904288,
    2651288351,
    2652440186,
    2655263134,
    2660229222,
    2660362019,
    2662714632,
    2671981072,
    2673085999,
    2676359415,
    2678218950,
    2680015310,
    2683201101,
    2683726243,
    2687071289,
    2687546085,
    2689958531,
    2690565794,
    2691049537,
    2696922944,
    2702278755,
    2705586928,
    2707450736,
    2708750293,
    2710694053,
    2710777678,
    2717039465,
    2719746264,
    2719953243,
    2722365346,
    2724396360,
    2730361077,
    2732178535,
    2732249147,
    2732255792,
    2732453216,
    2732465831,
    2733162785,
    2733179003,
    2740913336,
    2743326046,
    2745816408,
    2746770100,
    2768031559,
    2768594053,
    2769743066,
    2770453396,
    2777301260,
    2777413063,
    2779047561,
    2779131760,
    2781151044,
    2788878449,
    2791114477,
    2792266216,
    2795123222,
    2795130739,
    2795148393,
    2803000277,
    2803220098,
    2820015673,
    2824852881,
    2825063248,
    2825297984,
    2826183623,
    2826618777,
    2828159974,
    2830840737,
    2840364717,
    2844137461,
    2844192015,
    2844331414,
    2844474265,
    2845536368,
    2847702680,
    2847708560,
    2849875839,
    2854691117,
    2857021867,
    2857111846,
    2857167445,
    2857291628,
    2857718467,
    2857718874,
    2859609075,
    2860369035,
    2860944275,
    2861234828,
    2861431296,
    2861773187,
    2862323803,
    2862729831,
    2862789186,
    2862818280,
    2865000297,
    2865536587,
    2872917161,
    2879220442,
    2885591219,
    2886256228,
    2886266660,
    2886337850,
    2886340600,
    2886347487,
    2886358758,
    2886559394,
    2888553420,
    2893735969,
    2893987517,
    2894277589,
    2895201770,
    2895970159,
    2903889952,
    2904798808,
    2907566289,
    2911967032,
    2913775681,
    2917443420,
    2921648360,
    2921994283,
    2925162127,
    2925540459,
    2931480722,
    2936112276,
    2938485423,
    2939997155,
    2941295122,
    2942568797,
    2944555176,
    2950549599,
    2952067971,
    2952072562,
    2955690120,
    2961421753,
    2962144430,
    2962519996,
    2962841785,
    2964270344,
    2964373735,
    2965548040,
    2966852375,
    2970298080,
    2974400461,
    2975755381,
    2981996158,
    2987922608,
    2991195167,
    2991625994,
    2993771546,
    2995901561,
    3000958971,
    3001281849,
    3001388716,
    3004478994,
    3004479027,
    3004479111,
    3004479159,
    3004479171,
    3004479184,
    3004479190,
    3004479239,
    3004479240,
    3004479258,
    3004479289,
    3004479305,
    3004479323,
    3004479334,
    3004479373,
    3004479389,
    3004479390,
    3004479401,
    3004479425,
    3004479785,
    3004479787,
    3004479818,
    3004479829,
    3004479837,
    3004479976,
    3004479994,
    3004480114,
    3005847375,
    3006723884,
    3006726944,
    3006727797,
    3006731179,
    3006737252,
    3006744684,
    3006811183,
    3012299493,
    3014399025,
    3019017018,
    3019072181,
    3019996757,
    3020108825,
    3020133371,
    3020188532,
    3023885513,
    3024558034,
    3024589567,
    3024626538,
    3033483503,
    3034109278,
    3035739007,
    3035887950,
    3044634578,
    3044797796,
    3044821749,
    3045244983,
    3045788419,
    3045876876,
    3046124074,
    3046256428,
    3050244615,
    3050333064,
    3050334784,
    3056297406,
    3062281966,
    3063798750,
    3063849681,
    3073445035,
    3073797863,
    3073848296,
    3086119708,
    3087786680,
    3089398889,
    3089451715,
    3089454054,
    3089461994,
    3089735415,
    3094552970,
    3097888413,
    3098875466,
    3099276787,
    3104375123,
    3104503715,
    3105798493,
    3107144912,
    3107146953,
    3110631110,
    3110681545,
    3111601102,
    3111601746,
    3111606786,
    3114815727,
    3119543502,
    3119594433,
    3120807553,
    3120857998,
    3122897068,
    3125786613,
    3128821880,
    3133975234,
    3135838657,
    3136281421,
    3145164732,
    3147940006,
    3154068140,
    3154152867,
    3157412719,
    3157501664,
    3159380027,
    3160589879,
    3161016478,
    3161897203,
    3174437714,
    3180245112,
    3180300610,
    3182786585,
    3183126568,
    3183293814,
    3183325319,
    3184294753,
    3188347051,
    3191217062,
    3196370198,
    3197567695,
    3198643172,
    3198783739,
    3198824989,
    3198841920,
    3198930383,
    3199640352,
    3200095506,
    3203439089,
    3203573947,
    3203579445,
    3208441350,
    3209729826,
    3210506925,
    3210514725,
    3210570457,
    3214383466,
    3214394316,
    3214653823,
    3215790970,
    3217760577,
    3218901480,
    3218928718,
    3218996674,
    3218997101,
    3219339071,
    3219427268,
    3220535722,
    3220543483,
    3221757640,
    3223098753,
    3224727829,
    3232284385,
    3232339054,
    3234508143,
    3234559072,
    3235473148,
    3237969392,
    3243142044,
    3247991594,
    3253953941,
    3269910681,
    3270985722,
    3273573836,
    3273628995,
    3275986591,
    3277061645,
    3277112578,
    3277868236,
    3277980164,
    3278129999,
    3278154322,
    3280832255,
    3280992609,
    3283017533,
    3286262047,
    3290414111,
    3301409832,
    3301494567,
    3302526185,
    3302610918,
    3305712858,
    3305866028,
    3305950755,
    3309540327,
    3309590022,
    3309595898,
    3309596203,
    3309660560,
    3309660597,
    3309937069,
    3312550946,
    3312639405,
    3317007142,
    3317095593,
    3324397363,
    3331028046,
    3331525682,
    3331580349,
    3331802213,
    3332642035,
    3332696700,
    3333929978,
    3334870005,
    3334920442,
    3335058344,
    3335315569,
    3343940221,
    3345496201,
    3350023967,
    3353092349,
    3358586999,
    3365687143,
    3366763202,
    3368167300,
    3371155980,
    3372842751,
    3373802982,
    3374003367,
    3374007861,
    3374013921,
    3374033257,
    3374071862,
    3374072315,
    3374075119,
    3374222601,
    3374506623,
    3377952754,
    3382868701,
    3384928690,
    3388197033,
    3390931348,
    3391051206,
    3391063809,
    3391068622,
    3391334282,
    3391402631,
    3391423133,
    3391432603,
    3392425741,
    3394879910,
    3395277647,
    3399311251,
    3402270417,
    3404440519,
    3414226886,
    3414277321,
    3415566709,
    3417045783,
    3417060092,
    3418683074,
    3418733517,
    3424453774,
    3431921225,
    3437307073,
    3437430868,
    3437705452,
    3444401619,
    3445590826,
    3447374472,
    3456431399,
    3458638240,
    3461359920,
    3463272868,
    3468986640,
    3469121667,
    3471246134,
    3474393156,
    3474446194,
    3476056250,
    3478543821,
    3486841411,
    3486906847,
    3489097968,
    3491201265,
    3495569706,
    3496705474,
    3497897502,
    3497994843,
    3498252682,
    3502149957,
    3504414102,
    3504826781,
    3506839508,
    3506948350,
    3508950458,
    3509210745,
    3509498189,
    3511959565,
    3512025010,
    3512493029,
    3514111400,
    3517669498,
    3518790968,
    3521920341,
    3523035738,
    3523862571,
    3524226140,
    3530307622,
    3530358057,
    3536335853,
    3536792162,
    3538712404,
    3541452460,
    3541507619,
    3542648636,
    3544416242,
    3550676375,
    3551025439,
    3553383951,
    3556498831,
    3561501051,
    3561585780,
    3565016796,
    3565023071,
    3565174365,
    3565227623,
    3565288856,
    3566089568,
    3572109810,
    3575114019,
    3577841990,
    3586425916,
    3589694483,
    3591020567,
    3592221649,
    3594125448,
    3595182758,
    3596128381,
    3602035250,
    3602533630,
    3602552275,
    3604829927,
    3607233834,
    3607322789,
    3607604079,
    3608554389,
    3610981370,
    3617629034,
    3619761411,
    3623812162,
    3629877419,
    3636237811,
    3636292476,
    3639577654,
    3639632313,
    3645953597,
    3647523178,
    3649784978,
    3653883892,
    3660676457,
    3664234276,
    3674197367,
    3675513627,
    3681233287,
    3684650455,
    3688377898,
    3689406359,
    3692544695,
    3693437133,
    3694959415,
    3703294733,
    3704443907,
    3704956777,
    3706490306,
    3709178884,
    3709268355,
    3709272958,
    3717182590,
    3718660896,
    3719413702,
    3721853564,
    3731122282,
    3734934472,
    3736397122,
    3736397691,
    3738359136,
    3744502996,
    3744505315,
    3744515994,
    3744516038,
    3745225898,
    3745403285,
    3749377655,
    3751498613,
    3752631559,
    3753565240,
    3756319792,
    3758308501,
    3758308691,
    3761682835,
    3762386667,
    3762488637,
    3763193356,
    3763904751,
    3764062969,
    3764739038,
    3769398133,
    3770065529,
    3774076759,
    3779092995,
    3780318738,
    3781089827,
    3783201212,
    3785420602,
    3786786081,
    3788364543,
    3791375542,
    3791430201,
    3791912060,
    3792007260,
    3792147146,
    3793208754,
    3794029235,
    3805317549,
    3808957225,
    3809652473,
    3811984999,
    3812594538,
    3819295903,
    3819351056,
    3821104144,
    3821104746,
    3829518367,
    3832811824,
    3833121835,
    3833171090,
    3833706374,
    3838812042,
    3843969806,
    3844552031,
    3850681433,
    3851222744,
    3851541567,
    3851602009,
    3851679807,
    3853676291,
    3855415829,
    3856249405,
    3859110665,
    3859972063,
    3862928629,
    3865386916,
    3865396334,
    3873108359,
    3873163016,
    3876524049,
    3883472548,
    3885986978,
    3888196487,
    3895773227,
    3898366596,
    3900605466,
    3900796753,
    3906034907,
    3907036333,
    3914330405,
    3916906002,
    3922403377,
    3925982068,
    3933039724,
    3936549300,
    3939824482,
    3940957272,
    3941201834,
    3941535714,
    3943160335,
    3943296300,
    3950173236,
    3955179593,
    3959867562,
    3960938237,
    3961299015,
    3961303520,
    3961836502,
    3962329360,
    3963273426,
    3966271140,
    3969493837,
    3970184201,
    3971378905,
    3972349404,
    3972404563,
    3974206923,
    3977375686,
    3977639927,
    3981851856,
    3984175284,
    3984369770,
    3984383153,
    3984388901,
    3984577838,
    3986753035,
    3987449768,
    3988320676,
    3989122328,
    3989124781,
    3989300792,
    3991957101,
    3991978776,
    3992246021,
    3993156440,
    3995285601,
    4002046206,
    4002059123,
    4002298131,
    4007368305,
    4009075902,
    4012314248,
    4014272956,
    4018800601,
    4021398623,
    4022152923,
    4023242992,
    4034787018,
    4034837957,
    4040007159,
    4040507273,
    4040558214,
    4042630615,
    4042667369,
    4044815570,
    4044899805,
    4046325025,
    4051504220,
    4051593171,
    4059166898,
    4059387372,
    4060969098,
    4060986772,
    4062588735,
    4063625944,
    4063736412,
    4064813411,
    4074640059,
    4077930265,
    4080197122,
    4081731399,
    4081736449,
    4081740860,
    4081761692,
    4082508192,
    4082648933,
    4085037592,
    4085499470,
    4085741867,
    4086206754,
    4087477773,
    4087973382,
    4087974431,
    4087975312,
    4087977920,
    4087977986,
    4087982672,
    4087983230,
    4087984585,
    4087984590,
    4087984656,
    4087988411,
    4087993231,
    4087993234,
    4087993291,
    4087993428,
    4088004545,
    4089941093,
    4090379779,
    4094838531,
    4095533224,
    4098180267,
    4104794847,
    4104808845,
    4105491350,
    4105500480,
    4109580593,
    4111598640,
    4115797781,
    4116207257,
    4116258198,
    4116322118,
    4116406345,
    4116912946,
    4122262153,
    4126221625,
    4127308650,
    4128209898,
    4128210099,
    4128224738,
    4128228031,
    4128452341,
    4131804567,
    4131859224,
    4137741343,
    4141029933,
    4142953920,
    4145022541,
    4149201544,
    4150566897,
    4151710650,
    4152474623,
    4155185738,
    4156445644,
    4157556469,
    4157644922,
    4159136925,
    4159401066,
    4159780211,
    4159864444,
    4164601660,
    4166043368,
    4168091484,
    4169450331,
    4170161097,
    4170579962,
    4170925049,
    4171014006,
    4171016671,
    4171029715,
    4172482250,
    4175353143,
    4176008925,
    4178981053,
    4184703759,
    4186748423,
    4188894668,
    4189635776,
    4190045706,
    4190142208,
    4195146068,
    4196943735,
    4199824850,
    4203521301,
    4206809827,
    4206944958,
    4207535653,
    4208164707,
    4211585807,
    4215346074,
    4215356593,
    4218114605,
    4218115138,
    4218132009,
    4219656584,
    4219999876,
    4220379359,
    4221957810,
    4222018626,
    4225873997,
    4227433758,
    4228171984,
    4228217908,
    4228360888,
    4228368741,
    4228368760,
    4231583294,
    4231662792,
    4232149414,
    4232629512,
    4234942237,
    4235762280,
    4240864861,
    4241320459,
    4241740950,
    4242647335,
    4243702915,
    4245105172,
    4246629902,
    4248741847,
    4252833472,
    4252840599,
    4254781707,
    4254799704,
    4255058051,
    4260594638,
    4261873154,
    4261894730,
    4262104449,
    4262374147,
    4262375371,
    4262499171,
    4264253465,
    4265048576,
    4267292711,
    4271528787,
    4272039260,
    4272350188,
    4272417877,
    4276136562,
    4288066094,
    390,
    6205003,
    47871540,
    54631547,
    68945260,
    76317054,
    90122581,
    107533418,
    134757519,
    149084067,
    159782934,
    165071847,
    169736776,
    205527546,
    224032181,
    244603010,
    255553804,
    262051769,
    263431316,
    289494951,
    371032970,
    373243562,
    374621869,
    387545720,
    415171499,
    415171548,
    415171976,
    418990556,
    418990602,
    435420269,
    461226423,
    483976516,
    501379566,
    531625563,
    553327069,
    557914884,
    590191545,
    595217502,
    656131164,
    668816409,
    678957092,
    680578927,
    714686602,
    715141614,
    717942499,
    720974524,
    720974736,
    720975995,
    725617684,
    744932012,
    793535325,
    806495002,
    817571047,
    823641433,
    857348365,
    859756734,
    862586280,
    862607507,
    862637170,
    862767957,
    863187547,
    863261727,
    871542102,
    874127079,
    874448701,
    877175745,
    893771636,
    914435801,
    931438088,
    937200556,
    985925171,
    999743180,
    1015486168,
    1026348750,
    1029964103,
    1030875558,
    1083568115,
    1106088318,
    1206251138,
    1219433535,
    1220725895,
    1220852235,
    1220852260,
    1220852796,
    1220852957,
    1230410191,
    1236957398,
    1240508317,
    1242746690,
    1260212779,
    1282239389,
    1338160975,
    1340954405,
    1351436722,
    1361325259,
    1374669131,
    1374800320,
    1389479998,
    1389489864,
    1401511709,
    1421711922,
    1442213995,
    1451199708,
    1452449030,
    1467196671,
    1467386990,
    1490648152,
    1514073041,
    1515784934,
    1515785058,
    1523142552,
    1553174585,
    1554493328,
    1629584534,
    1641166031,
    1651813653,
    1651813852,
    1651813873,
    1651813877,
    1651814134,
    1661678914,
    1679178836,
    1704277516,
    1705410866,
    1705908110,
    1716909455,
    1772526810,
    1780819577,
    1792953560,
    1818263278,
    1821800212,
    1833750850,
    1834601376,
    1834613468,
    1866278547,
    1867401367,
    1877316119,
    1936236019,
    1945296852,
    1997464432,
    2013078789,
    2055461758,
    2058918178,
    2080694907,
    2086814061,
    2089989988,
    2123843096,
    2170766397,
    2172738430,
    2174442073,
    2177527468,
    2178512614,
    2233637259,
    2246941078,
    2268386306,
    2274845447,
    2274845649,
    2279046513,
    2293400491,
    2299670458,
    2300280964,
    2300527715,
    2305877279,
    2307152224,
    2316307169,
    2322963439,
    2335588857,
    2337430377,
    2359562546,
    2360555826,
    2389375265,
    2396889473,
    2405952063,
    2419834458,
    2423179189,
    2436862648,
    2436862650,
    2436862651,
    2436862652,
    2436862653,
    2436862654,
    2436862655,
    2439178127,
    2460729245,
    2517521888,
    2517875246,
    2585317679,
    2631335866,
    2712012329,
    2717013248,
    2718435811,
    2726590321,
    2726667654,
    2726667661,
    2726667752,
    2726667756,
    2726667834,
    2726667995,
    2726668398,
    2726870506,
    2726991293,
    2737177336,
    2757711981,
    2787445139,
    2796817467,
    2812190333,
    2816464305,
    2817592022,
    2824075537,
    2826795200,
    2827908591,
    2830699603,
    2830965258,
    2841353452,
    2872823135,
    2876785673,
    2876785759,
    2901134565,
    2913059937,
    2938670220,
    2939089089,
    2943360116,
    2945389039,
    3005172573,
    3015670621,
    3022308183,
    3050185270,
    3050185436,
    3056015384,
    3056015484,
    3079506072,
    3079929644,
    3116612793,
    3131379081,
    3149479373,
    3164097381,
    3176028223,
    3176996220,
    3183078197,
    3227651590,
    3234391576,
    3234432745,
    3278041418,
    3278041727,
    3278041816,
    3319967633,
    3330642108,
    3334769994,
    3354637514,
    3375261606,
    3375312977,
    3410061515,
    3410068256,
    3417365519,
    3423153883,
    3461071037,
    3473412940,
    3486684134,
    3504293483,
    3517650814,
    3547292615,
    3571189672,
    3593285841,
    3612407497,
    3666061454,
    3666061458,
    3666061568,
    3666061577,
    3666061585,
    3666061591,
    3666061602,
    3666061610,
    3666061613,
    3666061619,
    3666061666,
    3666061672,
    3666061702,
    3666061706,
    3666061732,
    3666061760,
    3666061781,
    3666061864,
    3666061891,
    3666061895,
    3666061896,
    3666061902,
    3666061903,
    3666061913,
    3666062029,
    3666062293,
    3666062299,
    3666062326,
    3666062331,
    3666062345,
    3666062357,
    3666062361,
    3666062379,
    3666062386,
    3666062390,
    3666062391,
    3666062394,
    3666062408,
    3666062418,
    3666062422,
    3666062427,
    3666062453,
    3666062517,
    3666062569,
    3666062581,
    3666062582,
    3666062586,
    3666062587,
    3666099519,
    3667007182,
    3676644409,
    3676644411,
    3676644421,
    3676644429,
    3676644442,
    3676644586,
    3676644600,
    3676644610,
    3676644643,
    3676644706,
    3676644759,
    3676644775,
    3676644800,
    3676644806,
    3676644819,
    3676644874,
    3676644887,
    3676644888,
    3676644905,
    3676644939,
    3676644953,
    3676644982,
    3676645005,
    3676645006,
    3676645021,
    3676645049,
    3676645073,
    3691777760,
    3697941178,
    3708654452,
    3739453678,
    3749170769,
    3808938955,
    3809042458,
    3809042834,
    3820675046,
    3829710462,
    3829710568,
    3845152461,
    3847111189,
    3848170841,
    3848172796,
    3861225221,
    3871154340,
    3872238039,
    3877533355,
    3916589493,
    3952274701,
    3956209759,
    3956209883,
    3967179311,
    4020468984,
    4088042711,
    4088042763,
    4088043471,
    4098608917,
    4098609219,
    4098704176,
    4098704230,
    4098775844,
    4098776178,
    4098815877,
    4098816211,
    4126370696,
    4128194716,
    4152440610,
    4155818428,
    4160641621,
    4179162156,
    4189349925,
    4224941776,
    4233200080,
    4233407375,
    4248600132,
    4259920717,
    4268151753,
    4268562148,
    0,
    0,
    0,
    32,
    32645503,
    343511425,
    1030334438,
    1035444912,
    1035444966,
    1126785125,
    1126785220,
    1126785554,
    1126785661,
    1160516735,
    1286944368,
    1843974304,
    2016993734,
    2016993895,
    2496101809,
    2496102290,
    2496102373,
    2501069285,
    2501069363,
    2501069943,
    2506938014,
    2613448893,
    2668096359,
    2767610756,
    2943255975,
    3483670337,
    3483670475,
    3483670694,
    3483670995,
    3641922754,
    4206482405,
    4233599295,
    4,
    989615076,
    1348282182,
    2372695675,
    2793429742,
    474,
    2315777,
    2516160,
    11643297,
    13203897,
    21231554,
    35967653,
    38712935,
    47792331,
    72865995,
    74144458,
    82734700,
    83460346,
    105527502,
    113271207,
    133175084,
    133306274,
    134752460,
    139681591,
    140540365,
    149081424,
    153628834,
    159784149,
    160693466,
    187981691,
    192478478,
    196554557,
    201714711,
    248032557,
    257089230,
    271126044,
    284628322,
    288401789,
    293512087,
    299470436,
    301921344,
    303087651,
    310748895,
    315932160,
    317229038,
    318673258,
    321508235,
    328967865,
    331740776,
    333043316,
    343618051,
    344116268,
    349554276,
    368842915,
    373240553,
    380288946,
    385653806,
    387546555,
    391603917,
    397299232,
    399675396,
    407552584,
    411195000,
    444280280,
    457925677,
    459126046,
    465045723,
    466546683,
    476300545,
    492825035,
    496262010,
    508940895,
    516076913,
    528158848,
    556967719,
    576308682,
    587182649,
    599016891,
    599034260,
    599035482,
    617473653,
    629010449,
    643159709,
    649306413,
    657763177,
    658030821,
    663498697,
    666920016,
    684079208,
    718967674,
    721611088,
    730892591,
    745170160,
    748876721,
    748886222,
    752803028,
    756281027,
    761348098,
    764441186,
    767592699,
    768148470,
    771634050,
    771637032,
    797075449,
    798164153,
    806496217,
    807477757,
    814547322,
    823640218,
    828791723,
    830209933,
    830328663,
    830812219,
    831086733,
    843422410,
    848961657,
    865242478,
    871543061,
    884068409,
    884552461,
    885566443,
    898403917,
    903718636,
    931459402,
    935392831,
    935834596,
    953760609,
    956026316,
    973201175,
    985556812,
    990107236,
    1002251210,
    1006286666,
    1015491227,
    1017212284,
    1017751931,
    1021423441,
    1026349709,
    1027559288,
    1039189287,
    1040655967,
    1048681185,
    1049173028,
    1069937338,
    1071441344,
    1072691903,
    1128950639,
    1139782538,
    1139843834,
    1141008431,
    1156523661,
    1160815779,
    1194239092,
    1197936283,
    1211577197,
    1211637010,
    1222641289,
    1240507358,
    1250860863,
    1264600767,
    1288872441,
    1321698432,
    1329660539,
    1338155660,
    1339210968,
    1373285759,
    1382125974,
    1390628516,
    1399578255,
    1399657308,
    1403708559,
    1408484449,
    1421977812,
    1432456391,
    1433498959,
    1468959011,
    1474134153,
    1481167509,
    1481892069,
    1485735468,
    1512063165,
    1514478145,
    1519263375,
    1522675342,
    1541305645,
    1542981532,
    1545890970,
    1547575222,
    1553720283,
    1557499238,
    1632730660,
    1635518266,
    1640297675,
    1644040136,
    1645084619,
    1672625515,
    1675268949,
    1675573659,
    1679183895,
    1701744405,
    1704282831,
    1705918154,
    1709094170,
    1740118996,
    1745197398,
    1746168006,
    1763490076,
    1764138250,
    1778504542,
    1804707890,
    1807895638,
    1812124962,
    1825087480,
    1826407997,
    1827997201,
    1834433178,
    1836295865,
    1836721468,
    1842831596,
    1855831597,
    1871287494,
    1874044309,
    1894472089,
    1911094612,
    1944286571,
    1945301911,
    1964668429,
    1992457158,
    2001245397,
    2005254865,
    2009607860,
    2045076089,
    2048724462,
    2072914399,
    2073220142,
    2080693816,
    2086817070,
    2091822363,
    2106898657,
    2116894487,
    2120589916,
    2132854800,
    2138833857,
    2149555928,
    2149786502,
    2159131792,
    2166792548,
    2193556503,
    2203826663,
    2222814745,
    2233632200,
    2234478015,
    2266871804,
    2270958851,
    2280109123,
    2300684501,
    2320975486,
    2363964101,
    2368015199,
    2368150205,
    2378859099,
    2402357659,
    2406246052,
    2420231640,
    2421832104,
    2429899162,
    2437980806,
    2442099500,
    2445444524,
    2450316872,
    2477231344,
    2480056360,
    2497381376,
    2511017726,
    2535682339,
    2548872209,
    2564758885,
    2577440767,
    2580206998,
    2581034625,
    2634443356,
    2647576485,
    2655498207,
    2659744440,
    2664398480,
    2665288759,
    2683912382,
    2685363948,
    2697995386,
    2705244823,
    2707054618,
    2722204667,
    2731911143,
    2746095604,
    2750223108,
    2751457001,
    2757038073,
    2757714990,
    2757832374,
    2763102979,
    2764615893,
    2768173321,
    2769632227,
    2788021838,
    2789621599,
    2804556717,
    2805563472,
    2808290141,
    2812672828,
    2813866328,
    2817995155,
    2823576784,
    2832963785,
    2833300206,
    2839929991,
    2842899363,
    2855442276,
    2856513455,
    2861724882,
    2873826097,
    2875201553,
    2889802328,
    2894057006,
    2902844704,
    2920776771,
    2938675535,
    2940382413,
    2940687092,
    2942499160,
    2944606430,
    2976147113,
    2999699036,
    3012594373,
    3014878073,
    3018472732,
    3021947486,
    3024482894,
    3027886950,
    3033143700,
    3041972547,
    3043054392,
    3061104959,
    3068421535,
    3068451149,
    3073259213,
    3076287128,
    3092740204,
    3097180103,
    3100000510,
    3103387337,
    3126517186,
    3134714387,
    3141033517,
    3153726305,
    3161099645,
    3164570023,
    3168616586,
    3171093691,
    3174505760,
    3178721795,
    3185964212,
    3199657339,
    3213212569,
    3227558031,
    3234959359,
    3242752110,
    3245911312,
    3250117513,
    3255207552,
    3263028169,
    3267416959,
    3271443733,
    3276067803,
    3303582289,
    3303582897,
    3303582994,
    3303614961,
    3327283712,
    3336973745,
    3344426237,
    3345667381,
    3346748653,
    3355942409,
    3358811093,
    3365430328,
    3371744816,
    3378392276,
    3393399711,
    3418876414,
    3451234301,
    3462047339,
    3466186248,
    3487461167,
    3489942689,
    3497005689,
    3511023565,
    3528253833,
    3567612396,
    3577832733,
    3577832874,
    3579570991,
    3581968529,
    3587382024,
    3594263141,
    3597175734,
    3609198260,
    3620670314,
    3644061745,
    3686687805,
    3699471696,
    3704450806,
    3719669200,
    3724302375,
    3732631655,
    3737867596,
    3737869333,
    3737882439,
    3743824089,
    3748450386,
    3755463030,
    3762725071,
    3780090414,
    3786960458,
    3789613664,
    3804622433,
    3826380201,
    3829814476,
    3834232417,
    3836376093,
    3843018675,
    3847110230,
    3849573984,
    3888536498,
    3895950835,
    3925391633,
    3927045026,
    3929681833,
    3930866393,
    3974478460,
    3989861270,
    3990612749,
    3994206764,
    3994206767,
    4003176468,
    4005639964,
    4013705057,
    4020891302,
    4040130402,
    4048452106,
    4055956024,
    4064081091,
    4069710253,
    4076793042,
    4078153021,
    4081704564,
    4090215578,
    4095557691,
    4103392506,
    4105790268,
    4130682685,
    4131077260,
    4150503708,
    4155492542,
    4165042016,
    4180101814,
    4186885299,
    4188349987,
    4190709408,
    4193373567,
    4197651626,
    4198443983,
    4202984206,
    4210375752,
    4212069506,
    4216891535,
    4228991204,
    4251429164,
    4263509307,
    4279717352,
    4282015733,
    0,
    1,
    1974066450,
    0,
    3,
    898804372,
    2420122849,
    3776296586,
    0,
    201,
    14034108,
    23188555,
    46966025,
    63548133,
    69988957,
    176179919,
    181602757,
    199230788,
    231162178,
    234878220,
    241015393,
    282017655,
    286917352,
    298380305,
    303225044,
    333040682,
    436746473,
    437068413,
    449019336,
    449464240,
    451920903,
    472319354,
    495318858,
    500388520,
    512606097,
    527005648,
    531402563,
    554651161,
    561857715,
    570474602,
    588675343,
    615779940,
    680838102,
    688229624,
    722503086,
    733631603,
    759879349,
    760863762,
    768579191,
    769161927,
    777931472,
    804592434,
    820388681,
    834351359,
    838060561,
    871806992,
    907959623,
    917609192,
    921095799,
    922653385,
    936253712,
    951807472,
    976944213,
    1057868108,
    1061438860,
    1097991931,
    1099387701,
    1118780323,
    1129127307,
    1134058690,
    1149298066,
    1173449599,
    1188365042,
    1221482277,
    1242510922,
    1244344576,
    1249042959,
    1256956692,
    1322375458,
    1340682260,
    1389219463,
    1394442279,
    1420709285,
    1468300758,
    1544881072,
    1554252850,
    1557974723,
    1564485910,
    1566036640,
    1637844009,
    1641584834,
    1668922875,
    1697481902,
    1700564263,
    1779722906,
    1817679755,
    1844196310,
    1862443027,
    1862944289,
    1863425670,
    1874439438,
    1918635827,
    1942164974,
    1953292144,
    1996832610,
    2005075462,
    2023914578,
    2171493616,
    2174172768,
    2200270403,
    2224853335,
    2232538822,
    2253530761,
    2271804726,
    2307427283,
    2314778321,
    2325064176,
    2347507979,
    2356867634,
    2422267260,
    2435625787,
    2442761119,
    2448910470,
    2454582508,
    2471444403,
    2478294033,
    2487762682,
    2505529649,
    2513007594,
    2514973059,
    2523046044,
    2584135332,
    2644823364,
    2645305307,
    2697781106,
    2700249759,
    2713921343,
    2858583336,
    2869381059,
    2875883974,
    2877426354,
    2906087318,
    2940183875,
    2941854634,
    2983778787,
    2991311078,
    3020661286,
    3033841873,
    3036938981,
    3061233249,
    3088839886,
    3090851000,
    3116880000,
    3160125774,
    3173697968,
    3175256934,
    3193365922,
    3209525171,
    3247520471,
    3248874150,
    3262696949,
    3293334302,
    3294129343,
    3298593000,
    3336190368,
    3342381501,
    3344449059,
    3367460946,
    3387371732,
    3391640312,
    3415133140,
    3415553447,
    3416872467,
    3486599559,
    3505446608,
    3554833241,
    3594782899,
    3615198865,
    3629910769,
    3642670614,
    3643744473,
    3654513786,
    3675702820,
    3697030868,
    3710380917,
    3732976135,
    3779661543,
    3795518186,
    3803370028,
    3804920752,
    3840174405,
    3861583079,
    3867650596,
    3894082090,
    3900359633,
    3942119031,
    3951224511,
    4009634354,
    4063453845,
    4065646590,
    4079144597,
    4096136978,
    4163056211,
    4180315949,
    4189523019,
    4196008531,
    4202817696,
    4241738188,
    4254148468,
    4265459019,
    4273759132,
    0,
    1,
    1242038520,
    0,
    1,
    1058807915,
    0,
    5,
    1148034389,
    1373602048,
    2160920720,
    2391490885,
    2722440867
]);
function binSearch(arr, elt, start, end) {
    if (start >= end) return false;
    let low = start;
    let high = end - 1;
    while(low <= high){
        const mid = low + high >>> 1;
        const midVal = arr[mid];
        if (midVal < elt) low = mid + 1;
        else {
            if (!(midVal > elt)) return true;
            high = mid - 1;
        }
    }
    return false;
}
const BUFFER = new Uint32Array(20);
function hashHostnameLabelsBackward(hostname, maximumNumberOfLabels) {
    let hash = 5381;
    let index = 0;
    for(let i = hostname.length - 1; i >= 0; i -= 1){
        const code = hostname.charCodeAt(i);
        if (46 === code) {
            BUFFER[index << 1] = hash >>> 0;
            BUFFER[(index << 1) + 1] = i + 1;
            index += 1;
            if (index === maximumNumberOfLabels) return index;
        }
        hash = 33 * hash ^ code;
    }
    BUFFER[index << 1] = hash >>> 0;
    BUFFER[(index << 1) + 1] = 0;
    index += 1;
    return index;
}
function packed_hashes_suffixLookup(hostname, options, out) {
    if (fast_path(hostname, options, out)) return;
    const { allowIcannDomains, allowPrivateDomains } = options;
    let matchIndex = -1;
    let matchKind = 0;
    let matchLabels = 0;
    let index = 1;
    const numberOfHashes = hashHostnameLabelsBackward(hostname, hashes["0"]);
    for(let label = 0; label < numberOfHashes; label += 1){
        const hash = BUFFER[label << 1];
        const labelStart = BUFFER[(label << 1) + 1];
        let match = 0;
        if (allowIcannDomains) match = binSearch(hashes, hash, index + 1, index + hashes[index] + 1) ? 5 : 0;
        index += hashes[index] + 1;
        if (allowPrivateDomains && 0 === match) match = binSearch(hashes, hash, index + 1, index + hashes[index] + 1) ? 6 : 0;
        index += hashes[index] + 1;
        if (allowIcannDomains && 0 === match && (4 & matchKind) === 0) match = binSearch(hashes, hash, index + 1, index + hashes[index] + 1) ? 17 : 0;
        index += hashes[index] + 1;
        if (allowPrivateDomains && 0 === match && (4 & matchKind) === 0) match = binSearch(hashes, hash, index + 1, index + hashes[index] + 1) ? 18 : 0;
        index += hashes[index] + 1;
        if (allowIcannDomains && 0 === match && (4 & matchKind) === 0 && matchLabels <= label) match = binSearch(hashes, hash, index + 1, index + hashes[index] + 1) ? 9 : 0;
        index += hashes[index] + 1;
        if (allowPrivateDomains && 0 === match && (4 & matchKind) === 0 && matchLabels <= label) match = binSearch(hashes, hash, index + 1, index + hashes[index] + 1) ? 10 : 0;
        index += hashes[index] + 1;
        if (0 !== match) {
            matchKind = match;
            matchLabels = label + ((16 & match) !== 0 ? 2 : 1);
            matchIndex = labelStart;
        }
    }
    out.isIcann = (1 & matchKind) !== 0;
    out.isPrivate = (2 & matchKind) !== 0;
    if (-1 === matchIndex) {
        out.publicSuffix = 1 === numberOfHashes ? hostname : hostname.slice(BUFFER[1]);
        return;
    }
    if ((4 & matchKind) !== 0) {
        out.publicSuffix = hostname.slice(BUFFER[(matchLabels - 2 << 1) + 1]);
        return;
    }
    if ((16 & matchKind) !== 0) {
        if (matchLabels < numberOfHashes) {
            out.publicSuffix = hostname.slice(BUFFER[(matchLabels - 1 << 1) + 1]);
            return;
        }
        const parts = hostname.split('.');
        while(parts.length > matchLabels)parts.shift();
        out.publicSuffix = parts.join('.');
        return;
    }
    out.publicSuffix = hostname.slice(matchIndex);
}
getEmptyResult();
function parse(url, options = {}) {
    return factory_parseImpl(url, 5, packed_hashes_suffixLookup, options, getEmptyResult());
}
function newNode() {
    return {
        chars: new Map(),
        code: void 0
    };
}
function create(strings) {
    const node = newNode();
    for(let i = 0; i < strings.length; i += 1){
        const tok = strings[i];
        let root = node;
        for(let j = 0; j < tok.length; j += 1){
            const c = tok.charCodeAt(j);
            let next = root.chars.get(c);
            if (void 0 === next) {
                next = newNode();
                root.chars.set(c, next);
            }
            root = next;
        }
        root.code = i;
    }
    return node;
}
const EMPTY_UINT8_ARRAY = new Uint8Array(0);
class SmazCompress {
    constructor(codebook, maxSize = 30000){
        this.trie = create(codebook);
        this.buffer = new Uint8Array(maxSize);
        this.verbatim = new Uint8Array(255);
    }
    getCompressedSize(buffer) {
        if (0 === buffer.length) return 0;
        const retrieve = 'string' == typeof buffer ? (idx)=>buffer.charCodeAt(idx) : (idx)=>buffer[idx];
        let bufferIndex = 0;
        let verbatimIndex = 0;
        let inputIndex = 0;
        while(inputIndex < buffer.length){
            let indexAfterMatch = -1;
            let code = -1;
            let root = this.trie;
            for(let j = inputIndex; j < buffer.length; j += 1){
                root = root.chars.get(retrieve(j));
                if (void 0 === root) break;
                if (void 0 !== root.code) {
                    code = root.code;
                    indexAfterMatch = j + 1;
                }
            }
            if (-1 === code) {
                verbatimIndex++;
                inputIndex++;
                if (255 === verbatimIndex) {
                    bufferIndex += 2 + verbatimIndex;
                    verbatimIndex = 0;
                }
            } else {
                if (0 !== verbatimIndex) {
                    bufferIndex += 2 + (1 === verbatimIndex ? 0 : verbatimIndex);
                    verbatimIndex = 0;
                }
                bufferIndex++;
                inputIndex = indexAfterMatch;
            }
        }
        if (0 !== verbatimIndex) bufferIndex += 2 + (1 === verbatimIndex ? 0 : verbatimIndex);
        return bufferIndex;
    }
    compress(buffer) {
        if (0 === buffer.length) return EMPTY_UINT8_ARRAY;
        const retrieve = 'string' == typeof buffer ? (idx)=>buffer.charCodeAt(idx) : (idx)=>buffer[idx];
        let bufferIndex = 0;
        let verbatimIndex = 0;
        let inputIndex = 0;
        while(inputIndex < buffer.length){
            let indexAfterMatch = -1;
            let code = -1;
            let root = this.trie;
            for(let j = inputIndex; j < buffer.length; j += 1){
                root = root.chars.get(retrieve(j));
                if (void 0 === root) break;
                if (void 0 !== root.code) {
                    code = root.code;
                    indexAfterMatch = j + 1;
                }
            }
            if (-1 === code) {
                this.verbatim[verbatimIndex++] = retrieve(inputIndex++);
                if (255 === verbatimIndex) {
                    bufferIndex = this.flushVerbatim(verbatimIndex, bufferIndex);
                    verbatimIndex = 0;
                }
            } else {
                if (0 !== verbatimIndex) {
                    bufferIndex = this.flushVerbatim(verbatimIndex, bufferIndex);
                    verbatimIndex = 0;
                }
                this.buffer[bufferIndex++] = code;
                inputIndex = indexAfterMatch;
            }
        }
        if (0 !== verbatimIndex) bufferIndex = this.flushVerbatim(verbatimIndex, bufferIndex);
        return this.buffer.slice(0, bufferIndex);
    }
    flushVerbatim(verbatimIndex, bufferIndex) {
        if (1 === verbatimIndex) {
            this.buffer[bufferIndex++] = 254;
            this.buffer[bufferIndex++] = this.verbatim[0];
        } else {
            this.buffer[bufferIndex++] = 255;
            this.buffer[bufferIndex++] = verbatimIndex;
            for(let k = 0; k < verbatimIndex; k += 1)this.buffer[bufferIndex++] = this.verbatim[k];
        }
        return bufferIndex;
    }
}
class SmazDecompress {
    constructor(codebook){
        this.codebook = codebook;
    }
    decompress(arr) {
        if (0 === arr.byteLength) return '';
        let output = '';
        let i = 0;
        while(i < arr.byteLength)if (254 === arr[i]) {
            output += String.fromCharCode(arr[i + 1]);
            i += 2;
        } else if (255 === arr[i]) {
            const stop = i + arr[i + 1] + 2;
            for(i += 2; i < stop; i += 1)output += String.fromCharCode(arr[i]);
        } else {
            output += this.codebook[arr[i]];
            i += 1;
        }
        return output;
    }
}
const esm_EMPTY_UINT8_ARRAY = new Uint8Array(0);
class SmazDecompressRaw {
    static fromStringCodebook(codebook) {
        const TEXT_ENCODER = new TextEncoder();
        return new this(codebook.map((str)=>TEXT_ENCODER.encode(str)));
    }
    constructor(codebook){
        this.codebook = codebook;
    }
    decompress(arr) {
        if (0 === arr.byteLength) return esm_EMPTY_UINT8_ARRAY;
        const chunks = [];
        let i = 0;
        while(i < arr.byteLength)if (254 === arr[i]) {
            chunks.push(arr.subarray(i + 1, i + 2));
            i += 2;
        } else if (255 === arr[i]) {
            const stop = i + arr[i + 1] + 2;
            chunks.push(arr.subarray(i + 2, stop));
            i = stop;
        } else {
            chunks.push(this.codebook[arr[i]]);
            i += 1;
        }
        const output = new Uint8Array(chunks.reduce((state, chunk)=>state + chunk.byteLength, 0));
        for(let j = 0, offset = 0; j < chunks.length; j++){
            output.set(chunks[j], offset);
            offset += chunks[j].byteLength;
        }
        return output;
    }
}
class Smaz {
    constructor(codebook, maxSize = 30000){
        this.codebook = codebook;
        this.compressor = new SmazCompress(codebook, maxSize);
        this.decompressor = new SmazDecompress(codebook);
        this.rawDecompressor = SmazDecompressRaw.fromStringCodebook(codebook);
    }
    compress(buffer) {
        return this.compressor.compress(buffer);
    }
    getCompressedSize(buffer) {
        return this.compressor.getCompressedSize(buffer);
    }
    decompress(buffer) {
        return this.decompressor.decompress(buffer);
    }
    decompressRaw(buffer) {
        return this.rawDecompressor.decompress(buffer);
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const cosmetic_selector = [
    "_storage%22%3A%22denied%22%2C%22ad_user_data%22%3A%22denied%22%2C%22ad_personalizat",
    "trusted-set-cookie, SOCS, CAISNQgQEitib3FfaWRlbnRpdHlmcm9udGVuZHVpc2VydmVyXzIwMjQwN",
    "acs, document.createElement, %2Fl%5C.parentNode%5C.insertBefore%5C(s%2F",
    ", OptanonConsent, groups%3DC0001%253A1%252CC0002%253A0%252CC000",
    "TE0LjA2X3AwGgJmaSADGgYIgOu0sgY, 1year, , domain, google.",
    ":not([style^=\"position: absolute; left: -5000px\"])",
    "href-sanitizer, a%5Bhref%5E%3D%22https%3A%2F%2F",
    ", OptanonAlertBoxClosed, %24currentDate%24",
    "acs, addEventListener, google_ad_client",
    "aost, String.prototype.charCodeAt, ai_",
    "aopr, app_vars.force_disable_adblock",
    "img[src*=\"https://im.chip.de/ii/\"]",
    "acs, document.addEventListener, ",
    "acs, document.getElementById, ",
    "no-fetch-if, googlesyndication",
    "aopr, document.dispatchEvent",
    "no-xhr-if, googlesyndication",
    ", document.createElement, ",
    "%2522%253Afalse%252C%2522",
    ", document.oncontextmenu",
    "aeld, DOMContentLoaded, ",
    "nosiif, visibility, 1000",
    "set-local-storage-item, ",
    "trusted-click-element, ",
    "set, blurred, false",
    "decodeURIComponent",
    "[target=\"_blank\"]",
    "%22%3Afalse%2C%22",
    "[href^=\"https://",
    "%22%3Atrue%2C%22",
    "trusted-replace-",
    "[href^=\"http://",
    "[href=\"https://",
    "[src^=\"https://",
    "[data-testid=\"",
    "%22%3Afalse%7D",
    "rmnt, script, ",
    ", , reload, 1",
    "BlockDetected",
    "onselectstart",
    "div[class^=\"",
    "trusted-set-",
    ", document.",
    ".prototype.",
    "contextmenu",
    "leaderboard",
    "no-fetch-if",
    "otification",
    ":has-text(",
    "background",
    "analytics",
    "container",
    "Container",
    "div[style",
    "no-xhr-if",
    "placehold",
    "sbygoogle",
    "[href*=\"",
    "%5Bdata-",
    "AAAAAAAA",
    "Detector",
    "disclaim",
    "nano-sib",
    "nextFunc",
    "noopFunc",
    "nostif, ",
    ".com/\"]",
    "300x250",
    "article",
    "consent",
    "Consent",
    "content",
    "display",
    "keydown",
    "message",
    "Message",
    "overlay",
    "privacy",
    "sidebar",
    "sponsor",
    "wrapper",
    "-child",
    "[class",
    "[data-",
    "[id^=\"",
    "accept",
    "banner",
    "bottom",
    "button",
    "cookie",
    "Cookie",
    "necess",
    "notice",
    "nowoif",
    "policy",
    "Policy",
    "produc",
    "script",
    "widget",
    ":has(",
    ":not(",
    "Accep",
    "block",
    "Block",
    "click",
    "disab",
    "false",
    "fixed",
    "frame",
    "modal",
    "popup",
    "video",
    "width",
    ".com",
    "0px;",
    "2%3A",
    "2%5D",
    "aeld",
    "aopr",
    "body",
    "foot",
    "gdpr",
    "goog",
    "html",
    "icky",
    "ight",
    "set-",
    "show",
    "tion",
    "true",
    " > ",
    "%3A",
    "%3D",
    "%5B",
    "522",
    "age",
    "box",
    "div",
    "dow",
    "ent",
    "out",
    "rap",
    "__",
    ", ",
    ".m",
    "\"]",
    "%2",
    "%7",
    "=\"",
    "00",
    "ac",
    "ad",
    "Ad",
    "al",
    "an",
    "ar",
    "at",
    "de",
    "ed",
    "en",
    "er",
    "et",
    "he",
    "id",
    "in",
    "la",
    "le",
    "lo",
    "ol",
    "om",
    "on",
    "op",
    "or",
    "re",
    "ro",
    "s_",
    "s-",
    "se",
    "si",
    "st",
    "t-",
    "te",
    "ti",
    "un",
    " ",
    "_",
    "-",
    ";",
    ":",
    ".",
    "(",
    ")",
    "[",
    "]",
    "*",
    "/",
    "#",
    "^",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "b",
    "B",
    "c",
    "C",
    "d",
    "D",
    "e",
    "E",
    "f",
    "F",
    "g",
    "G",
    "h",
    "H",
    "I",
    "j",
    "k",
    "K",
    "l",
    "L",
    "m",
    "M",
    "n",
    "N",
    "o",
    "O",
    "p",
    "P",
    "q",
    "Q",
    "r",
    "R",
    "s",
    "S",
    "t",
    "T",
    "u",
    "U",
    "v",
    "V",
    "w",
    "W",
    "x",
    "y",
    "Y",
    "z"
];
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const network_csp = [
    "sandbox allow-forms allow-same-origin allow-scripts allow-modals allow-orientation-lock allow-pointer-lock allow-presentation allow-top-navigation",
    "script-src 'self' data: 'unsafe-inline' 'unsafe-hashes' 'unsafe-eval'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' ",
    " *.google.com *.gstatic.com *.googleapis.com",
    " data: blob: mediastream: filesystem:",
    "script-src 'self' '*' 'unsafe-inline'",
    " *.gstatic.com *.google.com *.google",
    "default-src 'unsafe-inline' 'self'",
    " allow-same-origin allow-scripts",
    "script-src 'self' 'unsafe-eval' ",
    " *.google.com *.gstatic.com *.",
    "t-src 'self' 'unsafe-inline' ",
    "script-src * 'unsafe-inline'",
    ".com *.googletagmanager.com",
    "default-src 'self' *.",
    " *.googleapis.com *.",
    "child-src 'none';",
    "worker-src 'none'",
    "bootstrapcdn.com",
    ".googleapis.com",
    "'unsafe-inline'",
    "e-src 'self' *",
    " allow-modals",
    "unsafe-eval'",
    "child-src *",
    "gstatic.com",
    "style-src *",
    "cloudflare",
    "google.com",
    "script-src",
    " https://",
    "frame-src",
    "data: *.",
    "facebook",
    " 'self'",
    " allow-",
    " https:",
    ".com *.",
    ".net *.",
    "addthis",
    "captcha",
    "sandbox",
    "youtube",
    " blob:",
    "defaul",
    "disqus",
    "google",
    "jquery",
    "ation",
    "data:",
    "http:",
    "t-src",
    ".com",
    ".net",
    "cdn.",
    " *.",
    "age",
    "avi",
    "con",
    "ent",
    "pic",
    "ram",
    "tag",
    "yti",
    " '",
    " *",
    " f",
    "*.",
    "ad",
    "an",
    "as",
    "cc",
    "ck",
    "dn",
    "er",
    "ga",
    "he",
    "im",
    "in",
    "lo",
    "ne",
    "op",
    "or",
    "rc",
    "re",
    "wi",
    "wp",
    "ww",
    " ",
    "-",
    ";",
    ":",
    ".",
    "'",
    "*",
    "/",
    "1",
    "3",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y"
];
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const network_filter = [
    "/videojs-vast-vpaid@2.0.2/bin/videojs_5.vast.vpaid.min",
    "/etc.clientlibs/logitech-common/clientlibs/onetrust.",
    "*&iu=%2f18190176%2c22509719621%2fadthrive_video_",
    "/(\\d{0,1})?tamilprint(\\d{1,2})?\\.(?:pro|art)/##",
    "/pagead/managed/js/adsense/*/show_ads_impl",
    "/pagead/managed/js/gpt/*/pubads_impl",
    "/wrappermessagingwithoutdetection",
    "/pagead/js/adsbygoogle.js",
    "/js/sdkloader/ima3.js",
    "/js/sdkloader/ima3_d",
    "/videojs-contrib-ads",
    "/wp-content/plugins/",
    "/wp-content/uploads/",
    "/wp-content/themes/",
    "*.codeanyapp.com^",
    "/detroitchicago/",
    "*/satellitelib-",
    "/appmeasurement",
    "/cdn-cgi/trace",
    "/^https?:\\/\\/",
    "*.b-cdn.net^",
    "/^https:\\/\\/",
    "[a-zA-Z0-9]",
    "fingerprint",
    "/413gkwmt/",
    "/affiliate",
    "/ljub4etb/",
    "impression",
    "[a-z0-9]{",
    "/plugins/",
    "analytics",
    "telemetry",
    "[0-9a-z]",
    "/assets/",
    "/images/",
    "tracking",
    "/public",
    "300x250",
    "captcha",
    "collect",
    "consent",
    "content",
    "counter",
    "metrics",
    "privacy",
    "/embed",
    "728x90",
    "banner",
    "bundle",
    "client",
    "cookie",
    "dn-cgi",
    "google",
    "iframe",
    "module",
    "prebid",
    "script",
    "source",
    "widget",
    ".aspx",
    ".cgi?",
    ".com/",
    ".html",
    "[a-z]",
    "*.r2.",
    "/api/",
    "/beac",
    "/java",
    "/stat",
    "block",
    "click",
    "count",
    "event",
    "fault",
    "image",
    "manag",
    "media",
    "pixel",
    "popup",
    "theme",
    "track",
    "type=",
    "video",
    "visit",
    ".css",
    ".gif",
    ".jpg",
    ".min",
    ".php",
    ".png",
    "/img",
    "/jqu",
    "/js/",
    "/lib",
    "/log",
    "/web",
    "/wp-",
    "468x",
    "gi-b",
    "http",
    "mail",
    "page",
    "play",
    "plug",
    "publ",
    "tect",
    "uild",
    "view",
    ".js",
    "(?:",
    "/ad",
    "=*&",
    "com",
    "dpr",
    "id=",
    "jax",
    "key",
    "log",
    "sdk",
    "tag",
    "web",
    "ync",
    ":/",
    "*/",
    "*^",
    "/_",
    "/?",
    "/*",
    "/d",
    "/f",
    "/g",
    "/h",
    "/l",
    "/n",
    "/r",
    "/u",
    "/w",
    "\\.",
    "\\/",
    "00",
    "1/",
    "20",
    "ac",
    "ad",
    "ag",
    "al",
    "am",
    "an",
    "ap",
    "ar",
    "as",
    "at",
    "ch",
    "ck",
    "co",
    "de",
    "di",
    "e-",
    "e/",
    "ed",
    "el",
    "em",
    "en",
    "er",
    "es",
    "et",
    "ic",
    "id",
    "ig",
    "im",
    "in",
    "it",
    "js",
    "la",
    "le",
    "li",
    "lo",
    "mp",
    "ol",
    "om",
    "on",
    "op",
    "or",
    "ot",
    "re",
    "ro",
    "s_",
    "s-",
    "s?",
    "s/",
    "si",
    "sp",
    "st",
    "t/",
    "te",
    "ti",
    "tm",
    "tr",
    "ub",
    "un",
    "ur",
    "us",
    "ut",
    "ve",
    "_",
    "-",
    ",",
    "?",
    ".",
    ")",
    "{",
    "}",
    "*",
    "/",
    "\\",
    "&",
    "^",
    "=",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z"
];
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const network_hostname = [
    "securepubads.g.doubleclick",
    "pagead2.googlesyndication",
    ".actonservice.com",
    "googlesyndication",
    "imasdk.googleapis",
    ".cloudfront.net",
    "googletagmanag",
    "analytics.",
    "marketing.",
    "tracking.",
    "metrics.",
    "images.",
    ".co.jp",
    ".co.uk",
    "a8clk.",
    "stats.",
    "a8cv.",
    "media",
    "track",
    ".com",
    ".net",
    ".top",
    ".xyz",
    "www.",
    ".io",
    ".jp",
    "a8.",
    "app",
    "cdn",
    "new",
    "web",
    ".b",
    ".c",
    ".d",
    ".f",
    ".g",
    ".h",
    ".k",
    ".m",
    ".n",
    ".p",
    ".s",
    ".w",
    "10",
    "24",
    "a-",
    "a1",
    "a2",
    "a4",
    "ab",
    "ac",
    "ad",
    "af",
    "ag",
    "ah",
    "ai",
    "ak",
    "al",
    "am",
    "an",
    "ap",
    "ar",
    "as",
    "at",
    "au",
    "av",
    "aw",
    "ax",
    "ay",
    "az",
    "be",
    "bi",
    "bl",
    "bo",
    "br",
    "bu",
    "ca",
    "ce",
    "ch",
    "ci",
    "ck",
    "cl",
    "cr",
    "ct",
    "cu",
    "de",
    "di",
    "do",
    "dr",
    "ds",
    "du",
    "dy",
    "e-",
    "eb",
    "ec",
    "ed",
    "ef",
    "el",
    "em",
    "en",
    "ep",
    "er",
    "es",
    "et",
    "eu",
    "ev",
    "ew",
    "ex",
    "fe",
    "ff",
    "fi",
    "fo",
    "fr",
    "ge",
    "gh",
    "gi",
    "gn",
    "go",
    "gr",
    "gu",
    "he",
    "hi",
    "ho",
    "ic",
    "id",
    "ie",
    "if",
    "il",
    "im",
    "in",
    "ip",
    "ir",
    "is",
    "it",
    "iv",
    "iz",
    "jo",
    "ke",
    "ks",
    "la",
    "ld",
    "le",
    "li",
    "ll",
    "lo",
    "lu",
    "ly",
    "ma",
    "me",
    "mi",
    "mo",
    "mp",
    "my",
    "ne",
    "ni",
    "no",
    "ok",
    "ol",
    "om",
    "on",
    "oo",
    "op",
    "or",
    "ot",
    "ou",
    "ow",
    "pe",
    "ph",
    "pi",
    "pl",
    "po",
    "pr",
    "qu",
    "re",
    "ri",
    "ro",
    "ru",
    "s-",
    "sc",
    "se",
    "sh",
    "si",
    "sk",
    "so",
    "sp",
    "ss",
    "st",
    "su",
    "sw",
    "sy",
    "t-",
    "ta",
    "te",
    "th",
    "ti",
    "tn",
    "to",
    "tr",
    "ts",
    "tu",
    "tv",
    "tw",
    "ty",
    "ub",
    "ud",
    "ul",
    "um",
    "un",
    "up",
    "ur",
    "us",
    "ut",
    "ve",
    "vi",
    "vo",
    "we",
    "-",
    ".",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z"
];
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const network_redirect = [
    "google-analytics.com/analytics.js",
    "googlesyndication_adsbygoogle.js",
    "googletagmanager.com/gtm.js",
    "googletagservices_gpt.js",
    "googletagmanager_gtm.js",
    "fuckadblock.js-3.2.0:5",
    "amazon_apstag.js",
    "google-analytics",
    "fingerprint2.js",
    "noop-1s.mp4:10",
    "google-ima.js",
    "noop-0.1s.mp3",
    "prebid-ads.js",
    "nobab2.js:10",
    "noopmp3-0.1s",
    "noop-1s.mp4",
    "noopmp4-1s",
    "32x32.png",
    "noop.html",
    "noopframe",
    "noop.txt",
    "nooptext",
    "1x1.gif",
    "2x2.png",
    "noop.js",
    "noopjs",
    ".com/",
    ".js:5",
    "none",
    "noop",
    "-3.",
    ":10",
    ".js",
    "ads",
    "bea",
    "_a",
    ":5",
    ".0",
    "ar",
    "ch",
    "ic",
    "in",
    "le",
    "ma",
    "re",
    "st",
    "_",
    "-",
    ":",
    ".",
    "/",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z"
];
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const raw_network = [
    "/js/sdkloader/ima3.j",
    "/wp-content/plugins/",
    "/wp-content/uploads/",
    "redirect=google-ima.",
    ",redirect-rule=noop",
    ".actonservice.com^",
    ".com^$third-party",
    "googlesyndication",
    "imasdk.googleapis",
    ".cloudfront.net^",
    "$script,domain=",
    ",3p,denyallow=",
    ",redirect=noop",
    "xmlhttprequest",
    "^$third-party",
    "/^https:\\/\\/",
    "||smetrics.",
    "third-party",
    "marketing.",
    "$document",
    "analytics",
    ",domain=",
    "/assets/",
    "metrics.",
    "subdocum",
    "tracking",
    "$script",
    ".co.uk",
    ".shop^",
    "$ghide",
    "a8clk.",
    "cookie",
    "google",
    "script",
    ",to=~",
    ".com^",
    ".top^",
    ".xyz^",
    "/api/",
    "$doma",
    "a8cv.",
    "image",
    "media",
    "track",
    ".com",
    ".fr^",
    ".gif",
    ".jp^",
    ".net",
    "/js/",
    "$doc",
    "$xhr",
    "stat",
    "www.",
    ",1p",
    ".io",
    ".jp",
    ".js",
    "app",
    "cdn",
    "ent",
    "ght",
    "new",
    "web",
    ".b",
    ".c",
    ".f",
    ".h",
    ".m",
    ".n",
    ".p",
    ".s",
    ".t",
    ".w",
    "@@",
    "/*",
    "/p",
    "||",
    "a-",
    "ab",
    "ac",
    "ad",
    "af",
    "ag",
    "ak",
    "al",
    "am",
    "an",
    "ap",
    "ar",
    "as",
    "at",
    "au",
    "av",
    "aw",
    "ax",
    "ay",
    "az",
    "be",
    "bi",
    "bo",
    "br",
    "ca",
    "ce",
    "ch",
    "ci",
    "ck",
    "ct",
    "cu",
    "de",
    "di",
    "do",
    "ds",
    "e-",
    "e^",
    "eb",
    "ec",
    "ed",
    "el",
    "em",
    "en",
    "ep",
    "er",
    "es",
    "et",
    "ev",
    "ew",
    "ex",
    "fi",
    "fo",
    "fr",
    "g^",
    "ge",
    "gi",
    "go",
    "gr",
    "he",
    "hi",
    "ho",
    "hp",
    "ic",
    "id",
    "il",
    "im",
    "in",
    "ip",
    "ir",
    "is",
    "it",
    "ix",
    "js",
    "ke",
    "la",
    "le",
    "li",
    "lo",
    "lu",
    "ly",
    "me",
    "mo",
    "mp",
    "ne",
    "ni",
    "no",
    "ol",
    "om",
    "on",
    "oo",
    "op",
    "or",
    "ot",
    "pl",
    "po",
    "pr",
    "qu",
    "re",
    "ri",
    "ro",
    "ru",
    "s-",
    "s/",
    "sc",
    "se",
    "sh",
    "si",
    "so",
    "sp",
    "ss",
    "st",
    "te",
    "th",
    "ti",
    "to",
    "tr",
    "ts",
    "ub",
    "ud",
    "ul",
    "um",
    "un",
    "up",
    "ur",
    "us",
    "ut",
    "ve",
    "vi",
    "_",
    "-",
    ",",
    "?",
    ".",
    "*",
    "/",
    "^",
    "=",
    "|",
    "~",
    "$",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z"
];
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const raw_cosmetic = [
    "-webkit-touch-callo",
    ", 1year, , domain, ",
    ", googlesyndication",
    ", SOCS, CAISNQgQEit",
    ":style(overflow: au",
    "+js(trusted-click-e",
    "9udGVuZHVpc2VydmVyX",
    "GgJmaSADGgYIgOu0sgY",
    "ib3FfaWRlbnRpdHlmcm",
    "local-storage-item,",
    "user-select: text !",
    "zIwMjQwNTE0LjA2X3Aw",
    "##+js(set-cookie, ",
    "+js(acs, document.",
    "%22%3Afalse%2C%22",
    "^script:has-text(",
    "[href^=\"https://",
    "%22%3Atrue%2C%22",
    "+js(trusted-set-",
    ", , reload, 1)",
    "lement, button",
    "rmnt, script, ",
    "ut: default !",
    "+js(nostif, ",
    "div[class^=\"",
    ", noopFunc)",
    "contextmenu",
    "no-fetch-if",
    ":has-text(",
    "+js(aeld, ",
    "+js(aopr, ",
    "=\"https://",
    "background",
    "important;",
    " -webkit-",
    ".*,xhamst",
    "+js(set, ",
    "container",
    "AAAAAAAA",
    "consent",
    "message",
    "nowoif)",
    "privacy",
    "-wrapp",
    ".co.uk",
    ".com##",
    "[class",
    "[data-",
    "[id^=\"",
    "accept",
    "banner",
    "bottom",
    "cookie",
    "Cookie",
    "google",
    "policy",
    "widget",
    ":has(",
    ".com,",
    "block",
    "style",
    "true)",
    ".com",
    ".de,",
    ".fr,",
    ".net",
    ".nl,",
    ".pl,",
    "#@#.",
    "%7D)",
    "+js(",
    "2%5D",
    "gdpr",
    "html",
    "ight",
    "news",
    "www.",
    " > ",
    "##.",
    "###",
    "%3A",
    "%3D",
    "%5B",
    "%5C",
    "%7B",
    "%7C",
    "522",
    "age",
    "ent",
    "web",
    " !",
    "__",
    ", ",
    ": ",
    ".*",
    ".p",
    ".t",
    "\"]",
    "##",
    "%2",
    "=\"",
    "00",
    "ab",
    "ac",
    "ad",
    "Ad",
    "al",
    "am",
    "an",
    "ap",
    "ar",
    "as",
    "at",
    "au",
    "ay",
    "be",
    "bi",
    "bo",
    "ce",
    "ch",
    "ck",
    "co",
    "ct",
    "d-",
    "de",
    "di",
    "do",
    "ed",
    "el",
    "en",
    "er",
    "es",
    "et",
    "fi",
    "fo",
    "ga",
    "ge",
    "go",
    "he",
    "ho",
    "ic",
    "id",
    "if",
    "il",
    "im",
    "in",
    "is",
    "it",
    "ld",
    "le",
    "li",
    "lo",
    "ma",
    "me",
    "mo",
    "mp",
    "na",
    "ne",
    "no",
    "ol",
    "on",
    "op",
    "or",
    "ot",
    "ov",
    "po",
    "pp",
    "ra",
    "re",
    "ro",
    "ru",
    "s_",
    "s-",
    "sc",
    "se",
    "sh",
    "si",
    "sk",
    "so",
    "sp",
    "st",
    "t-",
    "ta",
    "th",
    "ti",
    "to",
    "ub",
    "ul",
    "um",
    "un",
    "up",
    "ur",
    "us",
    "ut",
    "ve",
    "vi",
    " ",
    "_",
    "-",
    ",",
    ":",
    ".",
    "(",
    ")",
    "[",
    "*",
    "/",
    "#",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "b",
    "B",
    "c",
    "C",
    "d",
    "D",
    "e",
    "E",
    "f",
    "F",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "L",
    "m",
    "M",
    "n",
    "o",
    "p",
    "P",
    "q",
    "r",
    "s",
    "S",
    "t",
    "T",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z"
];
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ class Compression {
    constructor(){
        this.cosmeticSelector = new Smaz(cosmetic_selector);
        this.networkCSP = new Smaz(network_csp);
        this.networkRedirect = new Smaz(network_redirect);
        this.networkHostname = new Smaz(network_hostname);
        this.networkFilter = new Smaz(network_filter);
        this.networkRaw = new Smaz(raw_network);
        this.cosmeticRaw = new Smaz(raw_cosmetic, 800000);
    }
}
const T = (()=>{
    let c = 0;
    const table = new Int32Array(256);
    for(let n = 0; 256 !== n; n += 1){
        c = n;
        c = 1 & c ? -306674912 ^ c >>> 1 : c >>> 1;
        c = 1 & c ? -306674912 ^ c >>> 1 : c >>> 1;
        c = 1 & c ? -306674912 ^ c >>> 1 : c >>> 1;
        c = 1 & c ? -306674912 ^ c >>> 1 : c >>> 1;
        c = 1 & c ? -306674912 ^ c >>> 1 : c >>> 1;
        c = 1 & c ? -306674912 ^ c >>> 1 : c >>> 1;
        c = 1 & c ? -306674912 ^ c >>> 1 : c >>> 1;
        c = 1 & c ? -306674912 ^ c >>> 1 : c >>> 1;
        table[n] = c;
    }
    return table;
})();
function crc32(buf, start, end) {
    let C = -1;
    const L = end - 7;
    let i = start;
    while(i < L){
        C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
        C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
        C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
        C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
        C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
        C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
        C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
        C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
    }
    while(i < L + 7)C = C >>> 8 ^ T[(C ^ buf[i++]) & 0xff];
    return (-1 ^ C) >>> 0;
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const data_view_EMPTY_UINT8_ARRAY = new Uint8Array(0);
const EMPTY_UINT32_ARRAY = new Uint32Array(0);
const LITTLE_ENDIAN = 1 === new Int8Array(new Int16Array([
    1
]).buffer)[0];
const data_view_TEXT_ENCODER = new TextEncoder();
let getCompressionSingleton = ()=>{
    const COMPRESSION = new Compression();
    getCompressionSingleton = ()=>COMPRESSION;
    return COMPRESSION;
};
function align4(pos) {
    return pos + 3 & -4;
}
function sizeOfByte() {
    return 1;
}
function sizeOfBool() {
    return 1;
}
function sizeOfLength(length) {
    return length <= 127 ? 1 : 5;
}
function sizeOfBytes(array, align) {
    return sizeOfBytesWithLength(array.length, align);
}
function sizeOfBytesWithLength(length, align) {
    return (align ? 3 : 0) + length + sizeOfLength(length);
}
function sizeOfASCII(str) {
    return str.length + sizeOfLength(str.length);
}
function sizeOfUTF8(str) {
    const encodedLength = data_view_TEXT_ENCODER.encode(str).length;
    return encodedLength + sizeOfLength(encodedLength);
}
function sizeOfUint32Array(array) {
    return array.byteLength + sizeOfLength(array.length);
}
function sizeOfNetworkRedirect(str, compression) {
    return true === compression ? sizeOfBytesWithLength(getCompressionSingleton().networkRedirect.getCompressedSize(str), false) : sizeOfASCII(str);
}
function sizeOfNetworkHostname(str, compression) {
    return true === compression ? sizeOfBytesWithLength(getCompressionSingleton().networkHostname.getCompressedSize(str), false) : sizeOfASCII(str);
}
function sizeOfNetworkCSP(str, compression) {
    return true === compression ? sizeOfBytesWithLength(getCompressionSingleton().networkCSP.getCompressedSize(str), false) : sizeOfASCII(str);
}
function sizeOfNetworkFilter(str, compression) {
    return true === compression ? sizeOfBytesWithLength(getCompressionSingleton().networkFilter.getCompressedSize(str), false) : sizeOfASCII(str);
}
function sizeOfCosmeticSelector(str, compression) {
    return true === compression ? sizeOfBytesWithLength(getCompressionSingleton().cosmeticSelector.getCompressedSize(str), false) : sizeOfASCII(str);
}
function sizeOfRawNetwork(str, compression) {
    return true === compression ? sizeOfBytesWithLength(getCompressionSingleton().networkRaw.getCompressedSize(data_view_TEXT_ENCODER.encode(str)), false) : sizeOfUTF8(str);
}
function sizeOfRawCosmetic(str, compression) {
    return true === compression ? sizeOfBytesWithLength(getCompressionSingleton().cosmeticRaw.getCompressedSize(data_view_TEXT_ENCODER.encode(str)), false) : sizeOfUTF8(str);
}
class StaticDataView {
    static empty(options) {
        return StaticDataView.fromUint8Array(data_view_EMPTY_UINT8_ARRAY, options);
    }
    static fromUint8Array(array, options) {
        return new StaticDataView(array, options);
    }
    static allocate(capacity, options) {
        return new StaticDataView(new Uint8Array(capacity), options);
    }
    constructor(buffer, { enableCompression }){
        if (false === LITTLE_ENDIAN) throw new Error('Adblocker currently does not support Big-endian systems');
        if (true === enableCompression) this.enableCompression();
        this.buffer = buffer;
        this.pos = 0;
    }
    enableCompression() {
        this.compression = getCompressionSingleton();
    }
    checksum() {
        return crc32(this.buffer, 0, this.pos);
    }
    dataAvailable() {
        return this.pos < this.buffer.byteLength;
    }
    setPos(pos) {
        this.pos = pos;
    }
    getPos() {
        return this.pos;
    }
    seekZero() {
        this.pos = 0;
    }
    slice() {
        this.checkSize();
        return this.buffer.slice(0, this.pos);
    }
    subarray() {
        if (this.pos === this.buffer.byteLength) return this.buffer;
        this.checkSize();
        return this.buffer.subarray(0, this.pos);
    }
    align4() {
        this.pos = align4(this.pos);
    }
    set(buffer) {
        this.buffer = new Uint8Array(buffer);
        this.seekZero();
    }
    pushBool(bool) {
        this.pushByte(Number(bool));
    }
    getBool() {
        return Boolean(this.getByte());
    }
    setByte(pos, byte) {
        this.buffer[pos] = byte;
    }
    pushByte(octet) {
        this.pushUint8(octet);
    }
    getByte() {
        return this.getUint8();
    }
    pushBytes(bytes, align = false) {
        this.pushLength(bytes.length);
        if (true === align) this.align4();
        this.buffer.set(bytes, this.pos);
        this.pos += bytes.byteLength;
    }
    getBytes(align = false) {
        const numberOfBytes = this.getLength();
        if (true === align) this.align4();
        const bytes = this.buffer.subarray(this.pos, this.pos + numberOfBytes);
        this.pos += numberOfBytes;
        return bytes;
    }
    getUint32ArrayView(desiredSize) {
        this.align4();
        if (0 === desiredSize) return EMPTY_UINT32_ARRAY;
        const view = new Uint32Array(this.buffer.buffer, this.pos + this.buffer.byteOffset, desiredSize);
        this.pos += 4 * desiredSize;
        return view;
    }
    pushUint8(uint8) {
        this.buffer[this.pos++] = uint8;
    }
    getUint8() {
        return this.buffer[this.pos++];
    }
    pushUint16(uint16) {
        this.buffer[this.pos++] = uint16 >>> 8;
        this.buffer[this.pos++] = uint16;
    }
    getUint16() {
        return (this.buffer[this.pos++] << 8 | this.buffer[this.pos++]) >>> 0;
    }
    pushUint32(uint32) {
        this.buffer[this.pos++] = uint32 >>> 24;
        this.buffer[this.pos++] = uint32 >>> 16;
        this.buffer[this.pos++] = uint32 >>> 8;
        this.buffer[this.pos++] = uint32;
    }
    getUint32() {
        return (this.buffer[this.pos++] << 24 >>> 0) + (this.buffer[this.pos++] << 16 | this.buffer[this.pos++] << 8 | this.buffer[this.pos++]) >>> 0;
    }
    pushUint32Array(arr) {
        this.pushLength(arr.length);
        for (const n of arr)this.pushUint32(n);
    }
    getUint32Array() {
        const length = this.getLength();
        const arr = new Uint32Array(length);
        for(let i = 0; i < length; i += 1)arr[i] = this.getUint32();
        return arr;
    }
    pushUTF8(raw) {
        const pos = this.getPos();
        const start = pos + sizeOfLength(raw.length);
        const { written } = data_view_TEXT_ENCODER.encodeInto(raw, this.buffer.subarray(start));
        if (pos + sizeOfLength(written) !== start) this.buffer.copyWithin(pos + 5, start, start + written);
        this.setPos(pos);
        this.pushLength(written);
        this.setPos(this.pos + written);
    }
    getUTF8() {
        const byteLength = this.getLength();
        this.pos += byteLength;
        return new TextDecoder('utf8', {
            ignoreBOM: true
        }).decode(this.buffer.subarray(this.pos - byteLength, this.pos));
    }
    pushASCII(str) {
        this.pushLength(str.length);
        for(let i = 0; i < str.length; i += 1)this.buffer[this.pos++] = str.charCodeAt(i);
    }
    getASCII() {
        const byteLength = this.getLength();
        this.pos += byteLength;
        return String.fromCharCode.apply(null, this.buffer.subarray(this.pos - byteLength, this.pos));
    }
    pushNetworkRedirect(str) {
        if (void 0 !== this.compression) this.pushBytes(this.compression.networkRedirect.compress(str));
        else this.pushASCII(str);
    }
    getNetworkRedirect() {
        if (void 0 !== this.compression) return this.compression.networkRedirect.decompress(this.getBytes());
        return this.getASCII();
    }
    pushNetworkHostname(str) {
        if (void 0 !== this.compression) this.pushBytes(this.compression.networkHostname.compress(str));
        else this.pushASCII(str);
    }
    getNetworkHostname() {
        if (void 0 !== this.compression) return this.compression.networkHostname.decompress(this.getBytes());
        return this.getASCII();
    }
    pushNetworkCSP(str) {
        if (void 0 !== this.compression) this.pushBytes(this.compression.networkCSP.compress(str));
        else this.pushASCII(str);
    }
    getNetworkCSP() {
        if (void 0 !== this.compression) return this.compression.networkCSP.decompress(this.getBytes());
        return this.getASCII();
    }
    pushNetworkFilter(str) {
        if (void 0 !== this.compression) this.pushBytes(this.compression.networkFilter.compress(str));
        else this.pushASCII(str);
    }
    getNetworkFilter() {
        if (void 0 !== this.compression) return this.compression.networkFilter.decompress(this.getBytes());
        return this.getASCII();
    }
    pushCosmeticSelector(str) {
        if (void 0 !== this.compression) this.pushBytes(this.compression.cosmeticSelector.compress(str));
        else this.pushASCII(str);
    }
    getCosmeticSelector() {
        if (void 0 !== this.compression) return this.compression.cosmeticSelector.decompress(this.getBytes());
        return this.getASCII();
    }
    pushRawCosmetic(str) {
        if (void 0 !== this.compression) this.pushBytes(this.compression.cosmeticRaw.compress(data_view_TEXT_ENCODER.encode(str)));
        else this.pushUTF8(str);
    }
    getRawCosmetic() {
        if (void 0 !== this.compression) return new TextDecoder('utf8', {
            ignoreBOM: true
        }).decode(this.compression.cosmeticRaw.decompressRaw(this.getBytes()));
        return this.getUTF8();
    }
    pushRawNetwork(str) {
        if (void 0 !== this.compression) this.pushBytes(this.compression.networkRaw.compress(data_view_TEXT_ENCODER.encode(str)));
        else this.pushUTF8(str);
    }
    getRawNetwork() {
        if (void 0 !== this.compression) return new TextDecoder('utf8', {
            ignoreBOM: true
        }).decode(this.compression.networkRaw.decompressRaw(this.getBytes()));
        return this.getUTF8();
    }
    checkSize() {
        if (0 !== this.pos && this.pos > this.buffer.byteLength) throw new Error(`StaticDataView too small: ${this.buffer.byteLength}, but required ${this.pos} bytes`);
    }
    pushLength(length) {
        if (length <= 127) this.pushUint8(length);
        else {
            this.pushUint8(128);
            this.pushUint32(length);
        }
    }
    getLength() {
        const lengthShort = this.getUint8();
        return 128 === lengthShort ? this.getUint32() : lengthShort;
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ class config_Config {
    static deserialize(buffer) {
        return new config_Config({
            debug: buffer.getBool(),
            enableCompression: buffer.getBool(),
            enableHtmlFiltering: buffer.getBool(),
            enableInMemoryCache: buffer.getBool(),
            enableMutationObserver: buffer.getBool(),
            enableOptimizations: buffer.getBool(),
            enablePushInjectionsOnNavigationEvents: buffer.getBool(),
            guessRequestTypeFromUrl: buffer.getBool(),
            integrityCheck: buffer.getBool(),
            loadCSPFilters: buffer.getBool(),
            loadCosmeticFilters: buffer.getBool(),
            loadExceptionFilters: buffer.getBool(),
            loadExtendedSelectors: buffer.getBool(),
            loadGenericCosmeticsFilters: buffer.getBool(),
            loadNetworkFilters: buffer.getBool(),
            loadPreprocessors: buffer.getBool()
        });
    }
    constructor({ debug = false, enableCompression = false, enableHtmlFiltering = false, enableInMemoryCache = true, enableMutationObserver = true, enableOptimizations = true, enablePushInjectionsOnNavigationEvents = true, guessRequestTypeFromUrl = false, integrityCheck = true, loadCSPFilters = true, loadCosmeticFilters = true, loadExceptionFilters = true, loadExtendedSelectors = false, loadGenericCosmeticsFilters = true, loadNetworkFilters = true, loadPreprocessors = false } = {}){
        this.debug = debug;
        this.enableCompression = enableCompression;
        this.enableHtmlFiltering = enableHtmlFiltering;
        this.enableInMemoryCache = enableInMemoryCache;
        this.enableMutationObserver = enableMutationObserver;
        this.enableOptimizations = enableOptimizations;
        this.enablePushInjectionsOnNavigationEvents = enablePushInjectionsOnNavigationEvents;
        this.guessRequestTypeFromUrl = guessRequestTypeFromUrl;
        this.integrityCheck = integrityCheck;
        this.loadCSPFilters = loadCSPFilters;
        this.loadCosmeticFilters = loadCosmeticFilters;
        this.loadExceptionFilters = loadExceptionFilters;
        this.loadExtendedSelectors = loadExtendedSelectors;
        this.loadGenericCosmeticsFilters = loadGenericCosmeticsFilters;
        this.loadNetworkFilters = loadNetworkFilters;
        this.loadPreprocessors = loadPreprocessors;
    }
    getSerializedSize() {
        return 16 * sizeOfBool();
    }
    serialize(buffer) {
        buffer.pushBool(this.debug);
        buffer.pushBool(this.enableCompression);
        buffer.pushBool(this.enableHtmlFiltering);
        buffer.pushBool(this.enableInMemoryCache);
        buffer.pushBool(this.enableMutationObserver);
        buffer.pushBool(this.enableOptimizations);
        buffer.pushBool(this.enablePushInjectionsOnNavigationEvents);
        buffer.pushBool(this.guessRequestTypeFromUrl);
        buffer.pushBool(this.integrityCheck);
        buffer.pushBool(this.loadCSPFilters);
        buffer.pushBool(this.loadCosmeticFilters);
        buffer.pushBool(this.loadExceptionFilters);
        buffer.pushBool(this.loadExtendedSelectors);
        buffer.pushBool(this.loadGenericCosmeticsFilters);
        buffer.pushBool(this.loadNetworkFilters);
        buffer.pushBool(this.loadPreprocessors);
    }
}
let promise;
const queueMicrotask = 'undefined' != typeof window && 'function' == typeof window.queueMicrotask ? (cb)=>window.queueMicrotask(cb) : (cb)=>(promise || (promise = Promise.resolve())).then(cb).catch((err)=>setTimeout(()=>{
            throw err;
        }, 0));
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function registerCallback(event, callback, listeners) {
    let listenersForEvent = listeners.get(event);
    if (void 0 === listenersForEvent) {
        listenersForEvent = [];
        listeners.set(event, listenersForEvent);
    }
    listenersForEvent.push(callback);
}
function unregisterCallback(event, callback, listeners) {
    const listenersForEvent = listeners.get(event);
    if (void 0 !== listenersForEvent) {
        const indexOfCallback = listenersForEvent.indexOf(callback);
        if (-1 !== indexOfCallback) listenersForEvent.splice(indexOfCallback, 1);
    }
}
function triggerCallback(event, args, listeners) {
    if (0 === listeners.size) return false;
    const listenersForEvent = listeners.get(event);
    if (void 0 !== listenersForEvent) {
        queueMicrotask(()=>{
            for (const listener of listenersForEvent)listener(...args);
        });
        return true;
    }
    return false;
}
class EventEmitter {
    constructor(){
        this.onceListeners = new Map();
        this.onListeners = new Map();
    }
    on(event, callback) {
        registerCallback(event, callback, this.onListeners);
    }
    once(event, callback) {
        registerCallback(event, callback, this.onceListeners);
    }
    unsubscribe(event, callback) {
        unregisterCallback(event, callback, this.onListeners);
        unregisterCallback(event, callback, this.onceListeners);
    }
    emit(event, ...args) {
        triggerCallback(event, args, this.onListeners);
        if (true === triggerCallback(event, args, this.onceListeners)) this.onceListeners.delete(event);
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function fetchWithRetry(fetch1, url) {
    let retry = 3;
    const fetchWrapper = ()=>fetch1(url).catch((ex)=>{
            if (retry > 0) {
                retry -= 1;
                return new Promise((resolve, reject)=>{
                    setTimeout(()=>{
                        fetchWrapper().then(resolve).catch(reject);
                    }, 500);
                });
            }
            throw ex;
        });
    return fetchWrapper();
}
function fetchResource(fetch1, url) {
    return fetchWithRetry(fetch1, url).then((response)=>response.text());
}
const PREFIX = 'https://raw.githubusercontent.com/ghostery/adblocker/master/packages/adblocker/assets';
const adsLists = [
    `${PREFIX}/easylist/easylist.txt`,
    `${PREFIX}/peter-lowe/serverlist.txt`,
    `${PREFIX}/ublock-origin/badware.txt`,
    `${PREFIX}/ublock-origin/filters-2020.txt`,
    `${PREFIX}/ublock-origin/filters-2021.txt`,
    `${PREFIX}/ublock-origin/filters-2022.txt`,
    `${PREFIX}/ublock-origin/filters-2023.txt`,
    `${PREFIX}/ublock-origin/filters-2024.txt`,
    `${PREFIX}/ublock-origin/filters.txt`,
    `${PREFIX}/ublock-origin/quick-fixes.txt`,
    `${PREFIX}/ublock-origin/resource-abuse.txt`,
    `${PREFIX}/ublock-origin/unbreak.txt`
];
const adsAndTrackingLists = [
    ...adsLists,
    `${PREFIX}/easylist/easyprivacy.txt`,
    `${PREFIX}/ublock-origin/privacy.txt`
];
const fullLists = [
    ...adsAndTrackingLists,
    `${PREFIX}/easylist/easylist-cookie.txt`,
    `${PREFIX}/ublock-origin/annoyances-others.txt`,
    `${PREFIX}/ublock-origin/annoyances-cookies.txt`
];
function fetchLists(fetch1, urls) {
    return Promise.all(urls.map((url)=>fetchResource(fetch1, url)));
}
function fetchResources(fetch1) {
    return fetchResource(fetch1, `${PREFIX}/ublock-origin/resources.json`);
}
function isAtoms(tokens) {
    return tokens.every((token)=>'string' != typeof token);
}
function isAST(tokens) {
    return tokens.every((token)=>'comma' !== token.type && 'combinator' !== token.type);
}
/*!
 * Based on parsel. Extended by Rmi Berson for Ghostery (2021).
 * https://github.com/LeaVerou/parsel
 *
 * MIT License
 *
 * Copyright (c) 2020 Lea Verou
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */ const RECURSIVE_PSEUDO_CLASSES = new Set([
    'any',
    'dir',
    'has',
    'host-context',
    'if',
    'if-not',
    'is',
    'matches',
    'not',
    'where'
]);
const TOKENS = {
    attribute: /\[\s*(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(?<caseSensitive>[iIsS])?\s*)?\]/gu,
    id: /#(?<name>(?:[-\w\u{0080}-\u{FFFF}]|\\.)+)/gu,
    class: /\.(?<name>(?:[-\w\u{0080}-\u{FFFF}]|\\.)+)/gu,
    comma: /\s*,\s*/g,
    combinator: /\s*[\s>+~]\s*/g,
    'pseudo-element': /::(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?:*)\))?/gu,
    'pseudo-class': /:(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>*)\))?/gu,
    type: /(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)|\*/gu
};
const TOKENS_WITH_PARENS = new Set([
    'pseudo-class',
    'pseudo-element'
]);
const TOKENS_WITH_STRINGS = new Set([
    ...TOKENS_WITH_PARENS,
    'attribute'
]);
const TRIM_TOKENS = new Set([
    'combinator',
    'comma'
]);
const TOKENS_FOR_RESTORE = Object.assign({}, TOKENS);
TOKENS_FOR_RESTORE['pseudo-element'] = RegExp(TOKENS['pseudo-element'].source.replace('(?<argument>*)', '(?<argument>.*?)'), 'gu');
TOKENS_FOR_RESTORE['pseudo-class'] = RegExp(TOKENS['pseudo-class'].source.replace('(?<argument>*)', '(?<argument>.*)'), 'gu');
function splitOnMatch(pattern, str) {
    pattern.lastIndex = 0;
    const match = pattern.exec(str);
    if (null === match) return;
    const from = match.index - 1;
    const content = match[0];
    const before = str.slice(0, from + 1);
    const after = str.slice(from + content.length + 1);
    return [
        before,
        [
            content,
            match.groups || {}
        ],
        after
    ];
}
const GRAMMAR = [
    (str)=>{
        const match = splitOnMatch(TOKENS.attribute, str);
        if (void 0 === match) return;
        const [before, [content, { name, operator, value, namespace, caseSensitive }], after] = match;
        if (void 0 === name) return;
        return [
            before,
            {
                type: 'attribute',
                content,
                length: content.length,
                namespace,
                caseSensitive,
                pos: [],
                name,
                operator,
                value
            },
            after
        ];
    },
    (str)=>{
        const match = splitOnMatch(TOKENS.id, str);
        if (void 0 === match) return;
        const [before, [content, { name }], after] = match;
        if (void 0 === name) return;
        return [
            before,
            {
                type: 'id',
                content,
                length: content.length,
                pos: [],
                name
            },
            after
        ];
    },
    (str)=>{
        const match = splitOnMatch(TOKENS.class, str);
        if (void 0 === match) return;
        const [before, [content, { name }], after] = match;
        if (void 0 === name) return;
        return [
            before,
            {
                type: 'class',
                content,
                length: content.length,
                pos: [],
                name
            },
            after
        ];
    },
    (str)=>{
        const match = splitOnMatch(TOKENS.comma, str);
        if (void 0 === match) return;
        const [before, [content], after] = match;
        return [
            before,
            {
                type: 'comma',
                content,
                length: content.length,
                pos: []
            },
            after
        ];
    },
    (str)=>{
        const match = splitOnMatch(TOKENS.combinator, str);
        if (void 0 === match) return;
        const [before, [content], after] = match;
        return [
            before,
            {
                type: 'combinator',
                content,
                length: content.length,
                pos: []
            },
            after
        ];
    },
    (str)=>{
        const match = splitOnMatch(TOKENS['pseudo-element'], str);
        if (void 0 === match) return;
        const [before, [content, { name }], after] = match;
        if (void 0 === name) return;
        return [
            before,
            {
                type: 'pseudo-element',
                content,
                length: content.length,
                pos: [],
                name
            },
            after
        ];
    },
    (str)=>{
        const match = splitOnMatch(TOKENS['pseudo-class'], str);
        if (void 0 === match) return;
        const [before, [content, { name, argument }], after] = match;
        if (void 0 === name) return;
        return [
            before,
            {
                type: 'pseudo-class',
                content,
                length: content.length,
                pos: [],
                name,
                argument,
                subtree: void 0
            },
            after
        ];
    },
    (str)=>{
        const match = splitOnMatch(TOKENS.type, str);
        if (void 0 === match) return;
        const [before, [content, { name, namespace }], after] = match;
        return [
            before,
            {
                type: 'type',
                content,
                length: content.length,
                namespace,
                pos: [],
                name
            },
            after
        ];
    }
];
function tokenizeBy(text) {
    if (!text) return [];
    const strarr = [
        text
    ];
    for (const tokenizer of GRAMMAR)for(let i = 0; i < strarr.length; i++){
        const str = strarr[i];
        if ('string' == typeof str) {
            const match = tokenizer(str);
            if (void 0 !== match) strarr.splice(i, 1, ...match.filter((a)=>0 !== a.length));
        }
    }
    let offset = 0;
    for (const token of strarr){
        if ('string' != typeof token) {
            token.pos = [
                offset,
                offset + token.length
            ];
            if (TRIM_TOKENS.has(token.type)) token.content = token.content.trim() || ' ';
        }
        offset += token.length;
    }
    if (isAtoms(strarr)) return strarr;
    return [];
}
function restoreNested(tokens, strings, regex, types) {
    for (const str of strings)for (const token of tokens)if (types.has(token.type) && token.pos[0] < str.start && str.start < token.pos[1]) {
        const content = token.content;
        token.content = token.content.replace(regex, str.str);
        if (token.content !== content) {
            TOKENS_FOR_RESTORE[token.type].lastIndex = 0;
            const match = TOKENS_FOR_RESTORE[token.type].exec(token.content);
            if (null !== match) Object.assign(token, match.groups);
        }
    }
}
function parse_isEscaped(str, index) {
    let backslashes = 0;
    index -= 1;
    while(index >= 0 && '\\' === str[index]){
        backslashes += 1;
        index -= 1;
    }
    return backslashes % 2 !== 0;
}
function gobbleQuotes(text, quote, start) {
    let end = start + 1;
    while(-1 !== (end = text.indexOf(quote, end)) && true === parse_isEscaped(text, end))end += 1;
    if (-1 === end) return;
    return text.slice(start, end + 1);
}
function gobbleParens(text, start) {
    let stack = 0;
    for(let i = start; i < text.length; i++){
        const char = text[i];
        if ('(' === char) stack += 1;
        else if (')' === char) {
            if (stack > 0) stack -= 1;
            else break;
        }
        if (0 === stack) return text.slice(start, i + 1);
    }
}
function replace(selector, replacement, opening, gobble) {
    const strings = [];
    let offset = 0;
    while(-1 !== (offset = selector.indexOf(opening, offset))){
        const str = gobble(selector, offset);
        if (void 0 === str) break;
        strings.push({
            str,
            start: offset
        });
        selector = `${selector.slice(0, offset + 1)}${replacement.repeat(str.length - 2)}${selector.slice(offset + str.length - 1)}`;
        offset += str.length;
    }
    return [
        strings,
        selector
    ];
}
function tokenize(selector) {
    if ('string' != typeof selector) return [];
    selector = selector.trim();
    if (0 === selector.length) return [];
    const [doubleQuotes, selectorWithoutDoubleQuotes] = replace(selector, '', '"', (text, start)=>gobbleQuotes(text, '"', start));
    const [singleQuotes, selectorWithoutQuotes] = replace(selectorWithoutDoubleQuotes, '', "'", (text, start)=>gobbleQuotes(text, "'", start));
    const [parens, selectorWithoutParens] = replace(selectorWithoutQuotes, '', '(', gobbleParens);
    const tokens = tokenizeBy(selectorWithoutParens);
    restoreNested(tokens, parens, /\(*\)/, TOKENS_WITH_PARENS);
    restoreNested(tokens, doubleQuotes, /"*"/, TOKENS_WITH_STRINGS);
    restoreNested(tokens, singleQuotes, /'*'/, TOKENS_WITH_STRINGS);
    return tokens;
}
function nestTokens(tokens, { list = true } = {}) {
    if (true === list && tokens.some((t)=>'comma' === t.type)) {
        const selectors = [];
        const temp = [];
        for(let i = 0; i < tokens.length; i += 1){
            const token = tokens[i];
            if ('comma' === token.type) {
                if (0 === temp.length) throw new Error('Incorrect comma at ' + i);
                const sub = nestTokens(temp, {
                    list: false
                });
                if (void 0 !== sub) selectors.push(sub);
                temp.length = 0;
            } else temp.push(token);
        }
        if (0 === temp.length) throw new Error('Trailing comma');
        {
            const sub = nestTokens(temp, {
                list: false
            });
            if (void 0 !== sub) selectors.push(sub);
        }
        return {
            type: 'list',
            list: selectors
        };
    }
    for(let i = tokens.length - 1; i >= 0; i--){
        const token = tokens[i];
        if ('combinator' === token.type) {
            const left = nestTokens(tokens.slice(0, i));
            const right = nestTokens(tokens.slice(i + 1));
            if (void 0 === right) return;
            if (' ' !== token.content && '~' !== token.content && '+' !== token.content && '>' !== token.content) return;
            return {
                type: 'complex',
                combinator: token.content,
                left,
                right
            };
        }
    }
    if (0 === tokens.length) return;
    if (isAST(tokens)) {
        if (1 === tokens.length) return tokens[0];
        return {
            type: 'compound',
            compound: [
                ...tokens
            ]
        };
    }
}
function walk(node, callback, o, parent) {
    if (void 0 === node) return;
    if ('complex' === node.type) {
        walk(node.left, callback, o, node);
        walk(node.right, callback, o, node);
    } else if ('compound' === node.type) for (const n of node.compound)walk(n, callback, o, node);
    else if ('pseudo-class' === node.type && void 0 !== node.subtree && void 0 !== o && 'pseudo-class' === o.type && void 0 !== o.subtree) walk(node.subtree, callback, o, node);
    callback(node, parent);
}
function parse_parse(selector, { recursive = true, list = true } = {}) {
    const tokens = tokenize(selector);
    if (0 === tokens.length) return;
    const ast = nestTokens(tokens, {
        list
    });
    if (true === recursive) walk(ast, (node)=>{
        if ('pseudo-class' === node.type && node.argument && void 0 !== node.name && RECURSIVE_PSEUDO_CLASSES.has(node.name)) node.subtree = parse_parse(node.argument, {
            recursive: true,
            list: true
        });
    });
    return ast;
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const EXTENDED_PSEUDO_CLASSES = new Set([
    'has',
    'has-text',
    'if'
]);
const PSEUDO_CLASSES = new Set([
    'active',
    'any',
    'any-link',
    'blank',
    'checked',
    'default',
    'defined',
    'dir',
    'disabled',
    'empty',
    'enabled',
    'first',
    'first-child',
    'first-of-type',
    'focus',
    'focus-visible',
    'focus-within',
    'fullscreen',
    'host',
    'host-context',
    'hover',
    'in-range',
    'indeterminate',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'matches',
    'not',
    'nth-child',
    'nth-last-child',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'target',
    'valid',
    'visited',
    'where'
]);
const PSEUDO_ELEMENTS = new Set([
    'after',
    'before',
    'first-letter',
    'first-line'
]);
var extended_SelectorType;
(function(SelectorType) {
    SelectorType[SelectorType["Normal"] = 0] = "Normal";
    SelectorType[SelectorType["Extended"] = 1] = "Extended";
    SelectorType[SelectorType["Invalid"] = 2] = "Invalid";
})(extended_SelectorType || (extended_SelectorType = {}));
function classifySelector(selector) {
    if (-1 === selector.indexOf(':')) return extended_SelectorType.Normal;
    const tokens = tokenize(selector);
    let foundSupportedExtendedSelector = false;
    for (const token of tokens)if ('pseudo-class' === token.type) {
        const { name } = token;
        if (true === EXTENDED_PSEUDO_CLASSES.has(name)) foundSupportedExtendedSelector = true;
        else if (false === PSEUDO_CLASSES.has(name) && false === PSEUDO_ELEMENTS.has(name)) return extended_SelectorType.Invalid;
        if (false === foundSupportedExtendedSelector && void 0 !== token.argument && true === RECURSIVE_PSEUDO_CLASSES.has(name)) {
            const argumentType = classifySelector(token.argument);
            if (argumentType === extended_SelectorType.Invalid) return argumentType;
            if (argumentType === extended_SelectorType.Extended) foundSupportedExtendedSelector = true;
        }
    }
    if (true === foundSupportedExtendedSelector) return extended_SelectorType.Extended;
    return extended_SelectorType.Normal;
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function isPureHasSelector(selector) {
    const ast = parse_parse(selector);
    try {
        walk(ast, (node)=>{
            if ('pseudo-class' === node.type && void 0 !== node.name && 'has' !== node.name && EXTENDED_PSEUDO_CLASSES.has(node.name)) throw new Error('not a :has');
        });
    } catch (e) {
        return false;
    }
    return true;
}
const EXTENSIONS = new Set([
    'htm',
    'html',
    'xhtml'
]);
const fonts_EXTENSIONS = new Set([
    'eot',
    'otf',
    'sfnt',
    'ttf',
    'woff',
    'woff2'
]);
const images_EXTENSIONS = new Set([
    'apng',
    'bmp',
    'cur',
    'dib',
    'eps',
    'gif',
    'heic',
    'heif',
    'ico',
    'j2k',
    'jfi',
    'jfif',
    'jif',
    'jp2',
    'jpe',
    'jpeg',
    'jpf',
    'jpg',
    'jpm',
    'jpx',
    'mj2',
    'pjp',
    'pjpeg',
    'png',
    'svg',
    'svgz',
    'tif',
    'tiff',
    'webp'
]);
const medias_EXTENSIONS = new Set([
    'avi',
    'flv',
    'mp3',
    'mp4',
    'ogg',
    'wav',
    'weba',
    'webm',
    'wmv'
]);
const scripts_EXTENSIONS = new Set([
    'js',
    'ts',
    'jsx',
    'esm'
]);
const stylesheets_EXTENSIONS = new Set([
    'css',
    'scss'
]);
function extname(url) {
    let endOfPath = url.length;
    const indexOfFragment = url.indexOf('#');
    if (-1 !== indexOfFragment) endOfPath = indexOfFragment;
    const indexOfQuery = url.indexOf('?');
    if (-1 !== indexOfQuery && indexOfQuery < endOfPath) endOfPath = indexOfQuery;
    let startOfExt = endOfPath - 1;
    let code = 0;
    for(; startOfExt >= 0; startOfExt -= 1){
        code = url.charCodeAt(startOfExt);
        if (false === (code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 48 && code <= 57)) break;
    }
    if (46 !== code || startOfExt < 0 || endOfPath - startOfExt >= 10) return '';
    return url.slice(startOfExt + 1, endOfPath);
}
function getRequestType(url) {
    const ext = extname(url);
    if (images_EXTENSIONS.has(ext) || url.startsWith('data:image/') || url.startsWith('https://frog.wix.com/bt')) return 'image';
    if (medias_EXTENSIONS.has(ext) || url.startsWith('data:audio/') || url.startsWith('data:video/')) return 'media';
    if (stylesheets_EXTENSIONS.has(ext) || url.startsWith('data:text/css')) return 'stylesheet';
    if (scripts_EXTENSIONS.has(ext) || url.startsWith('data:') && (url.startsWith("data:application/ecmascript") || url.startsWith("data:application/javascript") || url.startsWith("data:application/x-ecmascript") || url.startsWith("data:application/x-javascript") || url.startsWith("data:text/ecmascript") || url.startsWith("data:text/javascript") || url.startsWith("data:text/javascript1.0") || url.startsWith("data:text/javascript1.1") || url.startsWith("data:text/javascript1.2") || url.startsWith("data:text/javascript1.3") || url.startsWith("data:text/javascript1.4") || url.startsWith("data:text/javascript1.5") || url.startsWith("data:text/jscript") || url.startsWith("data:text/livescript") || url.startsWith("data:text/x-ecmascript") || url.startsWith("data:text/x-javascript")) || url.startsWith('https://maps.googleapis.com/maps/api/js') || url.startsWith('https://www.googletagmanager.com/gtag/js')) return "script";
    if (EXTENSIONS.has(ext) || url.startsWith('data:text/html') || url.startsWith('data:application/xhtml') || url.startsWith('https://www.youtube.com/embed/') || url.startsWith('https://www.google.com/gen_204')) return 'document';
    if (fonts_EXTENSIONS.has(ext) || url.startsWith('data:font/')) return 'font';
    return 'other';
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ class TokensBuffer {
    constructor(size){
        this.pos = 0;
        this.buffer = new Uint32Array(size);
    }
    reset() {
        this.pos = 0;
    }
    slice() {
        return this.buffer.slice(0, this.pos);
    }
    push(token) {
        this.buffer[this.pos++] = token;
    }
    empty() {
        return 0 === this.pos;
    }
    full() {
        return this.pos === this.buffer.length;
    }
    remaining() {
        return this.buffer.length - this.pos;
    }
}
const tokens_buffer_TOKENS_BUFFER = new TokensBuffer(1024);
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const HASH_INTERNAL_MULT = 37;
const HASH_SEED = 5011;
function bitCount(n) {
    n -= n >> 1 & 0x55555555;
    n = (0x33333333 & n) + (n >> 2 & 0x33333333);
    return (n + (n >> 4) & 0xf0f0f0f) * 0x1010101 >> 24;
}
function getBit(n, mask) {
    return !!(n & mask);
}
function setBit(n, mask) {
    return (n | mask) >>> 0;
}
function clearBit(n, mask) {
    return (n & ~mask) >>> 0;
}
function fastHashBetween(str, begin, end) {
    let hash = HASH_SEED;
    for(let i = begin; i < end; i += 1)hash = hash * HASH_INTERNAL_MULT ^ str.charCodeAt(i);
    return hash >>> 0;
}
function fastHash(str) {
    if ('string' != typeof str) return HASH_SEED;
    if (0 === str.length) return HASH_SEED;
    return fastHashBetween(str, 0, str.length);
}
function hashStrings(strings) {
    const result = new Uint32Array(strings.length);
    let index = 0;
    for (const str of strings)result[index++] = fastHash(str);
    return result;
}
function utils_isDigit(ch) {
    return ch >= 48 && ch <= 57;
}
function isAlpha(ch) {
    return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
}
function isAlphaExtended(ch) {
    return ch >= 192 && ch <= 450;
}
function isCyrillic(ch) {
    return ch >= 1024 && ch <= 1279;
}
function isAllowedCode(ch) {
    return isAlpha(ch) || utils_isDigit(ch) || 37 === ch || isAlphaExtended(ch) || isCyrillic(ch);
}
function tokenizeWithWildcardsInPlace(pattern, skipFirstToken, skipLastToken, buffer) {
    const len = Math.min(pattern.length, 2 * buffer.remaining());
    let inside = false;
    let precedingCh = 0;
    let start = 0;
    let hash = HASH_SEED;
    for(let i = 0; i < len; i += 1){
        const ch = pattern.charCodeAt(i);
        if (true === isAllowedCode(ch)) {
            if (false === inside) {
                hash = HASH_SEED;
                inside = true;
                start = i;
            }
            hash = hash * HASH_INTERNAL_MULT ^ ch;
        } else {
            if (true === inside) {
                inside = false;
                if (i - start > 1 && 42 !== ch && 42 !== precedingCh && (false === skipFirstToken || 0 !== start)) buffer.push(hash >>> 0);
            }
            precedingCh = ch;
        }
    }
    if (false === skipLastToken && true === inside && 42 !== precedingCh && pattern.length - start > 1 && false === buffer.full()) buffer.push(hash >>> 0);
}
function tokenizeInPlace(pattern, skipFirstToken, skipLastToken, buffer) {
    const len = Math.min(pattern.length, 2 * buffer.remaining());
    let inside = false;
    let start = 0;
    let hash = HASH_SEED;
    for(let i = 0; i < len; i += 1){
        const ch = pattern.charCodeAt(i);
        if (true === isAllowedCode(ch)) {
            if (false === inside) {
                hash = HASH_SEED;
                inside = true;
                start = i;
            }
            hash = hash * HASH_INTERNAL_MULT ^ ch;
        } else if (true === inside) {
            inside = false;
            if (i - start > 1 && (false === skipFirstToken || 0 !== start)) buffer.push(hash >>> 0);
        }
    }
    if (true === inside && false === skipLastToken && pattern.length - start > 1 && false === buffer.full()) buffer.push(hash >>> 0);
}
function tokenizeNoSkipInPlace(pattern, buffer) {
    const len = Math.min(pattern.length, 2 * buffer.remaining());
    let inside = false;
    let start = 0;
    let hash = HASH_SEED;
    for(let i = 0; i < len; i += 1){
        const ch = pattern.charCodeAt(i);
        if (true === isAllowedCode(ch)) {
            if (false === inside) {
                hash = HASH_SEED;
                inside = true;
                start = i;
            }
            hash = hash * HASH_INTERNAL_MULT ^ ch;
        } else if (true === inside) {
            inside = false;
            if (i - start > 1) buffer.push(hash >>> 0);
        }
    }
    if (true === inside && pattern.length - start > 1 && false === buffer.full()) buffer.push(hash >>> 0);
}
function tokenizeNoSkip(pattern) {
    tokens_buffer_TOKENS_BUFFER.reset();
    tokenizeNoSkipInPlace(pattern, tokens_buffer_TOKENS_BUFFER);
    return tokens_buffer_TOKENS_BUFFER.slice();
}
function utils_tokenize(pattern, skipFirstToken, skipLastToken) {
    tokens_buffer_TOKENS_BUFFER.reset();
    tokenizeInPlace(pattern, skipFirstToken, skipLastToken, tokens_buffer_TOKENS_BUFFER);
    return tokens_buffer_TOKENS_BUFFER.slice();
}
function tokenizeRegexInPlace(selector, tokens) {
    let end = selector.length - 1;
    let begin = 1;
    let prev = 0;
    for(; begin < end; begin += 1){
        const code = selector.charCodeAt(begin);
        if (124 === code) return;
        if (40 === code || 42 === code || 43 === code || 63 === code || 91 === code || 123 === code || 46 === code && 92 !== prev || 92 === code && isAlpha(selector.charCodeAt(begin + 1))) break;
        prev = code;
    }
    prev = 0;
    for(; end >= begin; end -= 1){
        const code = selector.charCodeAt(end);
        if (124 === code) return;
        if (41 === code || 42 === code || 43 === code || 63 === code || 93 === code || 125 === code || 46 === code && 92 !== selector.charCodeAt(end - 1) || 92 === code && isAlpha(prev)) break;
        prev = code;
    }
    if (end < begin) {
        const skipFirstToken = 94 !== selector.charCodeAt(1);
        const skipLastToken = 36 !== selector.charCodeAt(selector.length - 1);
        tokenizeInPlace(selector.slice(1, selector.length - 1), skipFirstToken, skipLastToken, tokens);
    } else {
        if (begin > 1) tokenizeInPlace(selector.slice(1, begin), 94 !== selector.charCodeAt(1), true, tokens);
        if (end < selector.length - 1) tokenizeInPlace(selector.slice(end + 1, selector.length - 1), true, 94 !== selector.charCodeAt(selector.length - 1), tokens);
    }
}
function utils_binSearch(arr, elt) {
    if (0 === arr.length) return -1;
    let low = 0;
    let high = arr.length - 1;
    while(low <= high){
        const mid = low + high >>> 1;
        const midVal = arr[mid];
        if (midVal < elt) low = mid + 1;
        else {
            if (!(midVal > elt)) return mid;
            high = mid - 1;
        }
    }
    return -1;
}
function binLookup(arr, elt) {
    return -1 !== utils_binSearch(arr, elt);
}
const hasUnicodeRe = /[^\u0000-\u00ff]/;
function hasUnicode(str) {
    return hasUnicodeRe.test(str);
}
function findLastIndexOfUnescapedCharacter(text, character) {
    let lastIndex = text.lastIndexOf(character);
    if (-1 === lastIndex) return -1;
    while(lastIndex > 0 && 92 === text.charCodeAt(lastIndex - 1))lastIndex = text.lastIndexOf(character, lastIndex - 1);
    return lastIndex;
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const TLDTS_OPTIONS = {
    extractHostname: true,
    mixedInputs: false,
    validateHostname: false
};
const NORMALIZED_TYPE_TOKEN = {
    beacon: fastHash('type:beacon'),
    cspReport: fastHash('type:csp'),
    csp_report: fastHash('type:csp'),
    cspviolationreport: fastHash('type:cspviolationreport'),
    document: fastHash('type:document'),
    eventsource: fastHash('type:other'),
    fetch: fastHash('type:xhr'),
    font: fastHash('type:font'),
    image: fastHash('type:image'),
    imageset: fastHash('type:image'),
    json: fastHash("type:script"),
    mainFrame: fastHash('type:document'),
    main_frame: fastHash('type:document'),
    manifest: fastHash('type:other'),
    media: fastHash('type:media'),
    object: fastHash('type:object'),
    object_subrequest: fastHash('type:object'),
    other: fastHash('type:other'),
    ping: fastHash('type:ping'),
    prefetch: fastHash('type:other'),
    preflight: fastHash('type:preflight'),
    script: fastHash("type:script"),
    signedexchange: fastHash('type:signedexchange'),
    speculative: fastHash('type:other'),
    stylesheet: fastHash('type:stylesheet'),
    subFrame: fastHash('type:subdocument'),
    sub_frame: fastHash('type:subdocument'),
    texttrack: fastHash('type:other'),
    webSocket: fastHash('type:websocket'),
    web_manifest: fastHash('type:other'),
    websocket: fastHash('type:websocket'),
    xhr: fastHash('type:xhr'),
    xml_dtd: fastHash('type:other'),
    xmlhttprequest: fastHash('type:xhr'),
    xslt: fastHash('type:other')
};
function hashHostnameBackward(hostname) {
    let hash = HASH_SEED;
    for(let j = hostname.length - 1; j >= 0; j -= 1)hash = hash * HASH_INTERNAL_MULT ^ hostname.charCodeAt(j);
    return hash >>> 0;
}
function getHashesFromLabelsBackward(hostname, end, startOfDomain) {
    tokens_buffer_TOKENS_BUFFER.reset();
    let hash = HASH_SEED;
    for(let i = end - 1; i >= 0; i -= 1){
        const code = hostname.charCodeAt(i);
        if (46 === code && i < startOfDomain) tokens_buffer_TOKENS_BUFFER.push(hash >>> 0);
        hash = hash * HASH_INTERNAL_MULT ^ code;
    }
    tokens_buffer_TOKENS_BUFFER.push(hash >>> 0);
    return tokens_buffer_TOKENS_BUFFER.slice();
}
function getHostnameWithoutPublicSuffix(hostname, domain) {
    let hostnameWithoutPublicSuffix = null;
    const indexOfDot = domain.indexOf('.');
    if (-1 !== indexOfDot) {
        const publicSuffix = domain.slice(indexOfDot + 1);
        hostnameWithoutPublicSuffix = hostname.slice(0, -publicSuffix.length - 1);
    }
    return hostnameWithoutPublicSuffix;
}
function getEntityHashesFromLabelsBackward(hostname, domain) {
    const hostnameWithoutPublicSuffix = getHostnameWithoutPublicSuffix(hostname, domain);
    if (null !== hostnameWithoutPublicSuffix) return getHashesFromLabelsBackward(hostnameWithoutPublicSuffix, hostnameWithoutPublicSuffix.length, hostnameWithoutPublicSuffix.length);
    return EMPTY_UINT32_ARRAY;
}
function getHostnameHashesFromLabelsBackward(hostname, domain) {
    return getHashesFromLabelsBackward(hostname, hostname.length, hostname.length - domain.length);
}
function isThirdParty(hostname, domain, sourceHostname, sourceDomain, type) {
    if ('main_frame' === type || 'mainFrame' === type) ;
    else if (0 !== domain.length && 0 !== sourceDomain.length) return domain !== sourceDomain;
    else if (0 !== domain.length && 0 !== sourceHostname.length) return domain !== sourceHostname;
    else if (0 !== sourceDomain.length && 0 !== hostname.length) return hostname !== sourceDomain;
    return false;
}
class Request {
    static fromRawDetails({ requestId = '0', tabId = 0, url = '', hostname, domain, sourceUrl = '', sourceHostname, sourceDomain, type = 'main_frame', _originalRequestDetails }) {
        url = url.toLowerCase();
        if (void 0 === hostname || void 0 === domain) {
            const parsed = parse(url, TLDTS_OPTIONS);
            hostname = hostname || parsed.hostname || '';
            domain = domain || parsed.domain || '';
        }
        if (void 0 === sourceHostname || void 0 === sourceDomain) {
            const parsed = parse(sourceHostname || sourceDomain || sourceUrl, TLDTS_OPTIONS);
            sourceHostname = sourceHostname || parsed.hostname || '';
            sourceDomain = sourceDomain || parsed.domain || sourceHostname || '';
        }
        return new Request({
            requestId,
            tabId,
            domain,
            hostname,
            url,
            sourceDomain,
            sourceHostname,
            sourceUrl,
            type,
            _originalRequestDetails
        });
    }
    constructor({ requestId, tabId, type, domain, hostname, url, sourceDomain, sourceHostname, _originalRequestDetails }){
        this.tokens = void 0;
        this.hostnameHashes = void 0;
        this.entityHashes = void 0;
        this._originalRequestDetails = _originalRequestDetails;
        this.id = requestId;
        this.tabId = tabId;
        this.type = type;
        this.url = url;
        this.hostname = hostname;
        this.domain = domain;
        this.sourceHostnameHashes = 0 === sourceHostname.length ? EMPTY_UINT32_ARRAY : getHostnameHashesFromLabelsBackward(sourceHostname, sourceDomain);
        this.sourceEntityHashes = 0 === sourceHostname.length ? EMPTY_UINT32_ARRAY : getEntityHashesFromLabelsBackward(sourceHostname, sourceDomain);
        this.isThirdParty = isThirdParty(hostname, domain, sourceHostname, sourceDomain, type);
        this.isFirstParty = !this.isThirdParty;
        this.isSupported = true;
        if ('websocket' === this.type || this.url.startsWith('ws:') || this.url.startsWith('wss:')) {
            this.isHttp = false;
            this.isHttps = false;
            this.type = 'websocket';
            this.isSupported = true;
        } else if (this.url.startsWith('http:')) {
            this.isHttp = true;
            this.isHttps = false;
        } else if (this.url.startsWith('https:')) {
            this.isHttps = true;
            this.isHttp = false;
        } else if (this.url.startsWith('data:')) {
            this.isHttp = false;
            this.isHttps = false;
            const indexOfComa = this.url.indexOf(',');
            if (-1 !== indexOfComa) this.url = this.url.slice(0, indexOfComa);
        } else {
            this.isHttp = false;
            this.isHttps = false;
            this.isSupported = false;
        }
    }
    getHostnameHashes() {
        if (void 0 === this.hostnameHashes) this.hostnameHashes = 0 === this.hostname.length ? EMPTY_UINT32_ARRAY : getHostnameHashesFromLabelsBackward(this.hostname, this.domain);
        return this.hostnameHashes;
    }
    getEntityHashes() {
        if (void 0 === this.entityHashes) this.entityHashes = 0 === this.hostname.length ? EMPTY_UINT32_ARRAY : getEntityHashesFromLabelsBackward(this.hostname, this.domain);
        return this.entityHashes;
    }
    getTokens() {
        if (void 0 === this.tokens) {
            tokens_buffer_TOKENS_BUFFER.reset();
            for (const hash of this.sourceHostnameHashes)tokens_buffer_TOKENS_BUFFER.push(hash);
            tokens_buffer_TOKENS_BUFFER.push(NORMALIZED_TYPE_TOKEN[this.type]);
            tokenizeNoSkipInPlace(this.url, tokens_buffer_TOKENS_BUFFER);
            this.tokens = tokens_buffer_TOKENS_BUFFER.slice();
        }
        return this.tokens;
    }
    isMainFrame() {
        return 'main_frame' === this.type || 'mainFrame' === this.type;
    }
    isSubFrame() {
        return 'sub_frame' === this.type || 'subFrame' === this.type;
    }
    guessTypeOfRequest() {
        const currentType = this.type;
        this.type = getRequestType(this.url);
        if (currentType !== this.type) this.tokens = void 0;
        return this.type;
    }
}
/*!
 * Copyright Mathias Bynens <https://mathiasbynens.be/>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ const maxInt = 2147483647;
const punycode_base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const punycode_delimiter = '-';
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
    'invalid-input': 'Invalid input',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    overflow: 'Overflow: input needs wider integers to process'
};
const baseMinusTMin = punycode_base - tMin;
function punycode_error(type) {
    throw new RangeError(errors[type]);
}
function ucs2decode(str) {
    const output = [];
    let counter = 0;
    const length = str.length;
    while(counter < length){
        const value = str.charCodeAt(counter++);
        if (value >= 0xd800 && value <= 0xdbff && counter < length) {
            const extra = str.charCodeAt(counter++);
            if ((0xfc00 & extra) === 0xdc00) output.push(((0x3ff & value) << 10) + (0x3ff & extra) + 0x10000);
            else {
                output.push(value);
                counter--;
            }
        } else output.push(value);
    }
    return output;
}
function digitToBasic(digit, flag) {
    return digit + 22 + 75 * (digit < 26 ? 1 : 0) - ((0 !== flag ? 1 : 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
    delta += Math.floor(delta / numPoints);
    for(; delta > baseMinusTMin * tMax >> 1; k += punycode_base)delta = Math.floor(delta / baseMinusTMin);
    return Math.floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode(str) {
    const output = [];
    const input = ucs2decode(str);
    const inputLength = input.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for(let i = 0; i < input.length; i += 1){
        const currentValue = input[i];
        if (currentValue < 0x80) output.push(String.fromCharCode(currentValue));
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) output.push(punycode_delimiter);
    while(handledCPCount < inputLength){
        let m = maxInt;
        for(let i = 0; i < input.length; i += 1){
            const currentValue = input[i];
            if (currentValue >= n && currentValue < m) m = currentValue;
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > Math.floor((maxInt - delta) / handledCPCountPlusOne)) punycode_error('overflow');
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for(let i = 0; i < input.length; i += 1){
            const currentValue = input[i];
            if (currentValue < n && ++delta > maxInt) punycode_error('overflow');
            if (currentValue === n) {
                let q = delta;
                for(let k = punycode_base;; k += punycode_base){
                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) break;
                    const qMinusT = q - t;
                    const baseMinusT = punycode_base - t;
                    output.push(String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = Math.floor(qMinusT / baseMinusT);
                }
                output.push(String.fromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join('');
}
function toASCII(input) {
    const labels = input.replace(regexSeparators, '\x2E').split('.');
    const encoded = [];
    for(let i = 0; i < labels.length; i += 1)encoded.push(regexNonASCII.test(labels[i]) ? 'xn--' + encode(labels[i]) : labels[i]);
    return encoded.join('.');
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ class Domains {
    static parse(value, { delimiter = ',', debug = false } = {}) {
        const parts = value.split(delimiter);
        if (0 === parts.length) return;
        for (const part of parts)if (0 === part.length || part.startsWith(delimiter) || part.endsWith(delimiter)) return;
        const entities = [];
        const notEntities = [];
        const hostnames = [];
        const notHostnames = [];
        const rawParts = [];
        for (const rawHostname of parts){
            let hostname = rawHostname;
            if (hasUnicode(hostname)) hostname = toASCII(hostname);
            const negation = 126 === hostname.charCodeAt(0);
            const entity = 42 === hostname.charCodeAt(hostname.length - 1) && 46 === hostname.charCodeAt(hostname.length - 2);
            const start = negation ? 1 : 0;
            const end = entity ? hostname.length - 2 : hostname.length;
            const hash = hashHostnameBackward(true === negation || true === entity ? hostname.slice(start, end) : hostname);
            if (negation) {
                if (entity) notEntities.push(hash);
                else notHostnames.push(hash);
                if (debug) rawParts.push(negation ? rawHostname : `~${rawHostname}`);
            } else {
                if (entity) entities.push(hash);
                else hostnames.push(hash);
                if (debug) rawParts.push(negation ? rawHostname.slice(1) : rawHostname);
            }
        }
        return new Domains({
            entities: 0 !== entities.length ? new Uint32Array(entities).sort() : void 0,
            hostnames: 0 !== hostnames.length ? new Uint32Array(hostnames).sort() : void 0,
            notEntities: 0 !== notEntities.length ? new Uint32Array(notEntities).sort() : void 0,
            notHostnames: 0 !== notHostnames.length ? new Uint32Array(notHostnames).sort() : void 0,
            parts: true === debug ? rawParts.join(delimiter) : void 0
        });
    }
    static deserialize(buffer) {
        const optionalParts = buffer.getUint8();
        return new Domains({
            entities: (1 & optionalParts) === 1 ? buffer.getUint32Array() : void 0,
            hostnames: (2 & optionalParts) === 2 ? buffer.getUint32Array() : void 0,
            notEntities: (4 & optionalParts) === 4 ? buffer.getUint32Array() : void 0,
            notHostnames: (8 & optionalParts) === 8 ? buffer.getUint32Array() : void 0,
            parts: (16 & optionalParts) === 16 ? buffer.getUTF8() : void 0
        });
    }
    constructor({ entities, hostnames, notEntities, notHostnames, parts }){
        this.entities = entities;
        this.hostnames = hostnames;
        this.notEntities = notEntities;
        this.notHostnames = notHostnames;
        this.parts = parts;
    }
    updateId(hash) {
        const { hostnames, entities, notHostnames, notEntities } = this;
        if (void 0 !== hostnames) for (const hostname of hostnames)hash = hash * HASH_INTERNAL_MULT ^ hostname;
        if (void 0 !== entities) for (const entity of entities)hash = hash * HASH_INTERNAL_MULT ^ entity;
        if (void 0 !== notHostnames) for (const notHostname of notHostnames)hash = hash * HASH_INTERNAL_MULT ^ notHostname;
        if (void 0 !== notEntities) for (const notEntity of notEntities)hash = hash * HASH_INTERNAL_MULT ^ notEntity;
        return hash;
    }
    serialize(buffer) {
        const index = buffer.getPos();
        buffer.pushUint8(0);
        let optionalParts = 0;
        if (void 0 !== this.entities) {
            optionalParts |= 1;
            buffer.pushUint32Array(this.entities);
        }
        if (void 0 !== this.hostnames) {
            optionalParts |= 2;
            buffer.pushUint32Array(this.hostnames);
        }
        if (void 0 !== this.notEntities) {
            optionalParts |= 4;
            buffer.pushUint32Array(this.notEntities);
        }
        if (void 0 !== this.notHostnames) {
            optionalParts |= 8;
            buffer.pushUint32Array(this.notHostnames);
        }
        if (void 0 !== this.parts) {
            optionalParts |= 16;
            buffer.pushUTF8(this.parts);
        }
        buffer.setByte(index, optionalParts);
    }
    getSerializedSize() {
        let estimate = 1;
        if (void 0 !== this.entities) estimate += sizeOfUint32Array(this.entities);
        if (void 0 !== this.hostnames) estimate += sizeOfUint32Array(this.hostnames);
        if (void 0 !== this.notHostnames) estimate += sizeOfUint32Array(this.notHostnames);
        if (void 0 !== this.notEntities) estimate += sizeOfUint32Array(this.notEntities);
        if (void 0 !== this.parts) estimate += sizeOfUTF8(this.parts);
        return estimate;
    }
    match(hostnameHashes, entityHashes) {
        if (void 0 !== this.notHostnames) {
            for (const hash of hostnameHashes)if (binLookup(this.notHostnames, hash)) return false;
        }
        if (void 0 !== this.notEntities) {
            for (const hash of entityHashes)if (binLookup(this.notEntities, hash)) return false;
        }
        if (void 0 !== this.hostnames || void 0 !== this.entities) {
            if (void 0 !== this.hostnames) {
                for (const hash of hostnameHashes)if (binLookup(this.hostnames, hash)) return true;
            }
            if (void 0 !== this.entities) {
                for (const hash of entityHashes)if (binLookup(this.entities, hash)) return true;
            }
            return false;
        }
        return true;
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function extractHTMLSelectorFromRule(rule) {
    if (false === rule.startsWith("^script")) return;
    const prefix = ':has-text(';
    const selectors = [];
    let index = 7;
    while(rule.startsWith(prefix, index)){
        index += prefix.length;
        let currentParsingDepth = 1;
        const startOfSelectorIndex = index;
        let prev = -1;
        for(; index < rule.length && 0 !== currentParsingDepth; index += 1){
            const code = rule.charCodeAt(index);
            if (92 !== prev) {
                if (40 === code) currentParsingDepth += 1;
                if (41 === code) currentParsingDepth -= 1;
            }
            prev = code;
        }
        selectors.push(rule.slice(startOfSelectorIndex, index - 1));
    }
    if (index !== rule.length) return;
    return [
        "script",
        selectors
    ];
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const EMPTY_TOKENS = [
    EMPTY_UINT32_ARRAY
];
const DEFAULT_HIDING_STYLE = 'display: none !important;';
const REGEXP_UNICODE_COMMA = new RegExp(/\\u002C/, 'g');
const REGEXP_UNICODE_BACKSLASH = new RegExp(/\\u005C/, 'g');
const REGEXP_ESCAPED_COMMA = new RegExp(/\\,/, 'g');
function isSimpleSelector(selector) {
    for(let i = 1; i < selector.length; i += 1){
        const code = selector.charCodeAt(i);
        if (!(45 === code || 95 === code || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
            if (i < selector.length - 1) {
                const nextCode = selector.charCodeAt(i + 1);
                if (91 === code || 46 === code || 58 === code || 32 === code && (62 === nextCode || 43 === nextCode || 126 === nextCode || 46 === nextCode || 35 === nextCode)) return true;
            }
            return false;
        }
    }
    return true;
}
function isSimpleHrefSelector(selector, start) {
    return selector.startsWith('href^="', start) || selector.startsWith('href*="', start) || selector.startsWith('href="', start);
}
const isValidCss = (()=>{
    const div = 'undefined' != typeof document ? document.createElement('div') : {
        matches: ()=>{}
    };
    const matches = (selector)=>div.matches(selector);
    const validSelectorRe = /^[#.]?[\w-.]+$/;
    return function(selector) {
        if (validSelectorRe.test(selector)) return true;
        try {
            matches(selector);
        } catch (ex) {
            return false;
        }
        return true;
    };
})();
var cosmetic_COSMETICS_MASK;
(function(COSMETICS_MASK) {
    COSMETICS_MASK[COSMETICS_MASK["unhide"] = 1] = "unhide";
    COSMETICS_MASK[COSMETICS_MASK["scriptInject"] = 2] = "scriptInject";
    COSMETICS_MASK[COSMETICS_MASK["isUnicode"] = 4] = "isUnicode";
    COSMETICS_MASK[COSMETICS_MASK["isClassSelector"] = 8] = "isClassSelector";
    COSMETICS_MASK[COSMETICS_MASK["isIdSelector"] = 16] = "isIdSelector";
    COSMETICS_MASK[COSMETICS_MASK["isHrefSelector"] = 32] = "isHrefSelector";
    COSMETICS_MASK[COSMETICS_MASK["remove"] = 64] = "remove";
    COSMETICS_MASK[COSMETICS_MASK["extended"] = 128] = "extended";
    COSMETICS_MASK[COSMETICS_MASK["isPureHasSelector"] = 256] = "isPureHasSelector";
})(cosmetic_COSMETICS_MASK || (cosmetic_COSMETICS_MASK = {}));
function computeFilterId(mask, selector, domains, style) {
    let hash = HASH_SEED * HASH_INTERNAL_MULT ^ mask;
    if (void 0 !== selector) for(let i = 0; i < selector.length; i += 1)hash = hash * HASH_INTERNAL_MULT ^ selector.charCodeAt(i);
    if (void 0 !== domains) hash = domains.updateId(hash);
    if (void 0 !== style) for(let i = 0; i < style.length; i += 1)hash = hash * HASH_INTERNAL_MULT ^ style.charCodeAt(i);
    return hash >>> 0;
}
function normalizeSelector(filter, getScriptletCanonicalName) {
    let selector = filter.getSelector();
    if (void 0 !== filter.style) selector += filter.style;
    if (false === filter.isScriptInject()) return selector;
    const parsed = filter.parseScript();
    if (void 0 === parsed) return selector;
    const canonicalName = getScriptletCanonicalName(parsed.name);
    if (void 0 === canonicalName) return selector;
    return selector.replace(parsed.name, canonicalName);
}
class cosmetic_CosmeticFilter {
    static parse(line, debug = false) {
        const rawLine = line;
        let mask = 0;
        let selector;
        let domains;
        let style;
        const sharpIndex = line.indexOf('#');
        const afterSharpIndex = sharpIndex + 1;
        let suffixStartIndex = afterSharpIndex + 1;
        if (line.length > afterSharpIndex) {
            if ('@' === line[afterSharpIndex]) {
                mask = setBit(mask, cosmetic_COSMETICS_MASK.unhide);
                suffixStartIndex += 1;
            } else if ('?' === line[afterSharpIndex]) suffixStartIndex += 1;
        }
        if (suffixStartIndex >= line.length) return null;
        if (sharpIndex > 0) domains = Domains.parse(line.slice(0, sharpIndex), {
            debug
        });
        if (line.endsWith(':remove()')) {
            mask = setBit(mask, cosmetic_COSMETICS_MASK.remove);
            mask = setBit(mask, cosmetic_COSMETICS_MASK.extended);
            line = line.slice(0, -9);
        } else if (line.length - suffixStartIndex >= 8 && line.endsWith(')') && -1 !== line.indexOf(':style(', suffixStartIndex)) {
            const indexOfStyle = line.indexOf(':style(', suffixStartIndex);
            style = line.slice(indexOfStyle + 7, -1);
            line = line.slice(0, indexOfStyle);
        }
        if (94 === line.charCodeAt(suffixStartIndex)) {
            if (false === line.startsWith("script:has-text(", suffixStartIndex + 1) || 41 !== line.charCodeAt(line.length - 1)) return null;
            selector = line.slice(suffixStartIndex, line.length);
            if (void 0 === extractHTMLSelectorFromRule(selector)) return null;
        } else if (line.length - suffixStartIndex > 4 && 43 === line.charCodeAt(suffixStartIndex) && line.startsWith('+js(', suffixStartIndex)) {
            if ((void 0 === domains || void 0 === domains.hostnames && void 0 === domains.entities) && false === getBit(mask, cosmetic_COSMETICS_MASK.unhide)) return null;
            mask = setBit(mask, cosmetic_COSMETICS_MASK.scriptInject);
            selector = line.slice(suffixStartIndex + 4, line.length - 1);
            if (false === getBit(mask, cosmetic_COSMETICS_MASK.unhide) && 0 === selector.length) return null;
        } else {
            selector = line.slice(suffixStartIndex);
            const selectorType = classifySelector(selector);
            if (selectorType === extended_SelectorType.Extended) {
                mask = setBit(mask, cosmetic_COSMETICS_MASK.extended);
                if (isPureHasSelector(selector)) mask = setBit(mask, cosmetic_COSMETICS_MASK.isPureHasSelector);
            } else if (selectorType === extended_SelectorType.Invalid || !isValidCss(selector)) return null;
        }
        if (void 0 === domains && true === getBit(mask, cosmetic_COSMETICS_MASK.extended)) return null;
        if (void 0 !== selector) {
            if (hasUnicode(selector)) mask = setBit(mask, cosmetic_COSMETICS_MASK.isUnicode);
            if (false === getBit(mask, cosmetic_COSMETICS_MASK.scriptInject) && false === getBit(mask, cosmetic_COSMETICS_MASK.remove) && false === getBit(mask, cosmetic_COSMETICS_MASK.extended) && false === selector.startsWith('^')) {
                const c0 = selector.charCodeAt(0);
                const c1 = selector.charCodeAt(1);
                const c2 = selector.charCodeAt(2);
                if (false === getBit(mask, cosmetic_COSMETICS_MASK.scriptInject)) {
                    if (46 === c0 && isSimpleSelector(selector)) mask = setBit(mask, cosmetic_COSMETICS_MASK.isClassSelector);
                    else if (35 === c0 && isSimpleSelector(selector)) mask = setBit(mask, cosmetic_COSMETICS_MASK.isIdSelector);
                    else if (97 === c0 && 91 === c1 && 104 === c2 && isSimpleHrefSelector(selector, 2)) mask = setBit(mask, cosmetic_COSMETICS_MASK.isHrefSelector);
                    else if (91 === c0 && 104 === c1 && isSimpleHrefSelector(selector, 1)) mask = setBit(mask, cosmetic_COSMETICS_MASK.isHrefSelector);
                }
            }
        }
        return new cosmetic_CosmeticFilter({
            mask,
            rawLine: true === debug ? rawLine : void 0,
            selector,
            style,
            domains
        });
    }
    static deserialize(buffer) {
        const mask = buffer.getUint16();
        const isUnicode = getBit(mask, cosmetic_COSMETICS_MASK.isUnicode);
        const optionalParts = buffer.getUint8();
        const selector = isUnicode ? buffer.getUTF8() : buffer.getCosmeticSelector();
        return new cosmetic_CosmeticFilter({
            mask,
            selector,
            domains: (1 & optionalParts) === 1 ? Domains.deserialize(buffer) : void 0,
            rawLine: (2 & optionalParts) === 2 ? buffer.getRawCosmetic() : void 0,
            style: (4 & optionalParts) === 4 ? buffer.getASCII() : void 0
        });
    }
    constructor({ mask, selector, domains, rawLine, style }){
        this.mask = mask;
        this.selector = selector;
        this.domains = domains;
        this.style = style;
        this.id = void 0;
        this.rawLine = rawLine;
        this.scriptletDetails = void 0;
    }
    isCosmeticFilter() {
        return true;
    }
    isNetworkFilter() {
        return false;
    }
    serialize(buffer) {
        buffer.pushUint16(this.mask);
        const index = buffer.getPos();
        buffer.pushUint8(0);
        if (this.isUnicode()) buffer.pushUTF8(this.selector);
        else buffer.pushCosmeticSelector(this.selector);
        let optionalParts = 0;
        if (void 0 !== this.domains) {
            optionalParts |= 1;
            this.domains.serialize(buffer);
        }
        if (void 0 !== this.rawLine) {
            optionalParts |= 2;
            buffer.pushRawCosmetic(this.rawLine);
        }
        if (void 0 !== this.style) {
            optionalParts |= 4;
            buffer.pushASCII(this.style);
        }
        buffer.setByte(index, optionalParts);
    }
    getSerializedSize(compression) {
        let estimate = 3;
        if (this.isUnicode()) estimate += sizeOfUTF8(this.selector);
        else estimate += sizeOfCosmeticSelector(this.selector, compression);
        if (void 0 !== this.domains) estimate += this.domains.getSerializedSize();
        if (void 0 !== this.rawLine) estimate += sizeOfRawCosmetic(this.rawLine, compression);
        if (void 0 !== this.style) estimate += sizeOfASCII(this.style);
        return estimate;
    }
    toString() {
        if (void 0 !== this.rawLine) return this.rawLine;
        let filter = '';
        if (void 0 !== this.domains) {
            if (void 0 !== this.domains.parts) filter += this.domains.parts;
            else filter += '<hostnames>';
        }
        if (this.isUnhide()) filter += '#@#';
        else filter += '##';
        if (this.isScriptInject()) {
            filter += '+js(';
            filter += this.selector;
            filter += ')';
        } else filter += this.selector;
        if (this.hasCustomStyle()) filter += ':style(' + this.getStyle() + ')';
        return filter;
    }
    match(hostname, domain) {
        if (false === this.hasHostnameConstraint()) return true;
        if (!hostname && this.hasHostnameConstraint()) return false;
        if (void 0 !== this.domains) return this.domains.match(0 === hostname.length ? EMPTY_UINT32_ARRAY : getHostnameHashesFromLabelsBackward(hostname, domain), 0 === hostname.length ? EMPTY_UINT32_ARRAY : getEntityHashesFromLabelsBackward(hostname, domain));
        return true;
    }
    getTokens() {
        const tokens = [];
        if (void 0 !== this.domains) {
            const { hostnames, entities } = this.domains;
            if (void 0 !== hostnames) for (const hostname of hostnames)tokens.push(new Uint32Array([
                hostname
            ]));
            if (void 0 !== entities) for (const entity of entities)tokens.push(new Uint32Array([
                entity
            ]));
        }
        if (0 === tokens.length && false === this.isUnhide()) {
            if (this.isIdSelector() || this.isClassSelector()) {
                let endOfSelector = 1;
                const selector = this.selector;
                for(; endOfSelector < selector.length; endOfSelector += 1){
                    const code = selector.charCodeAt(endOfSelector);
                    if (32 === code || 46 === code || 58 === code || 91 === code) break;
                }
                const arr = new Uint32Array(1);
                arr[0] = fastHashBetween(selector, 1, endOfSelector);
                tokens.push(arr);
            } else if (true === this.isHrefSelector()) {
                const selector = this.getSelector();
                let hrefIndex = selector.indexOf('href');
                if (-1 === hrefIndex) return EMPTY_TOKENS;
                hrefIndex += 4;
                let skipFirstToken = false;
                let skipLastToken = true;
                if (42 === selector.charCodeAt(hrefIndex)) {
                    skipFirstToken = true;
                    hrefIndex += 1;
                } else if (94 === selector.charCodeAt(hrefIndex)) hrefIndex += 1;
                else skipLastToken = false;
                hrefIndex += 2;
                const hrefEnd = selector.indexOf('"', hrefIndex);
                if (-1 === hrefEnd) return EMPTY_TOKENS;
                tokens.push(utils_tokenize(this.selector.slice(hrefIndex, hrefEnd), skipFirstToken, skipLastToken));
            }
        }
        if (0 === tokens.length) return EMPTY_TOKENS;
        return tokens;
    }
    parseScript() {
        if (void 0 !== this.scriptletDetails) return this.scriptletDetails;
        const selector = this.getSelector();
        if (0 === selector.length) return;
        const parts = [];
        let index = 0;
        let lastComaIndex = -1;
        let inDoubleQuotes = false;
        let inSingleQuotes = false;
        let inRegexp = false;
        let objectNesting = 0;
        let lastCharIsBackslash = false;
        let inArgument = false;
        for(; index < selector.length; index += 1){
            const char = selector[index];
            if (false === lastCharIsBackslash) {
                if (true === inDoubleQuotes) {
                    if ('"' === char) inDoubleQuotes = false;
                } else if (true === inSingleQuotes) {
                    if ("'" === char) inSingleQuotes = false;
                } else if (0 !== objectNesting) {
                    if ('{' === char) objectNesting += 1;
                    else if ('}' === char) objectNesting -= 1;
                    else if ('"' === char) inDoubleQuotes = true;
                    else if ("'" === char) inSingleQuotes = true;
                } else if (true === inRegexp) {
                    if ('/' === char) inRegexp = false;
                } else {
                    if (false === inArgument) {
                        if (' ' === char) ;
                        else if ('"' === char && selector.indexOf('"', index + 1) > 0) inDoubleQuotes = true;
                        else if ("'" === char && selector.indexOf("'", index + 1) > 0) inSingleQuotes = true;
                        else if ('{' === char && selector.indexOf('}', index + 1) > 0) objectNesting += 1;
                        else if ('/' === char && selector.indexOf('/', index + 1) > 0) inRegexp = true;
                        else inArgument = true;
                    }
                    if (',' === char) {
                        parts.push(selector.slice(lastComaIndex + 1, index).trim());
                        lastComaIndex = index;
                        inArgument = false;
                    }
                }
            }
            lastCharIsBackslash = '\\' === char;
        }
        parts.push(selector.slice(lastComaIndex + 1).trim());
        if (0 === parts.length) return;
        const args = parts.slice(1).map((part)=>{
            if (part.startsWith("'") && part.endsWith("'") || part.startsWith('"') && part.endsWith('"')) return part.substring(1, part.length - 1);
            return part;
        }).map((part)=>part.replace(REGEXP_UNICODE_COMMA, ',').replace(REGEXP_UNICODE_BACKSLASH, '\\').replace(REGEXP_ESCAPED_COMMA, ','));
        this.scriptletDetails = {
            name: parts[0],
            args
        };
        return this.scriptletDetails;
    }
    getScript(getScriptlet) {
        const parsed = this.parseScript();
        if (void 0 === parsed) return;
        const { name, args } = parsed;
        let script = getScriptlet(name);
        if (void 0 !== script) {
            for(let i = 0; i < args.length; i += 1){
                const arg = args[i].replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                script = script.replace(`{{${i + 1}}}`, arg);
            }
            return script;
        }
    }
    hasHostnameConstraint() {
        return void 0 !== this.domains;
    }
    getId() {
        if (void 0 === this.id) this.id = computeFilterId(this.mask, this.selector, this.domains, this.style);
        return this.id;
    }
    hasCustomStyle() {
        return void 0 !== this.style;
    }
    getStyle(defaultStyle = DEFAULT_HIDING_STYLE) {
        return this.style || defaultStyle;
    }
    getStyleAttributeHash() {
        return `s${fastHash(this.getStyle())}`;
    }
    getSelector() {
        return this.selector;
    }
    getSelectorAST() {
        return parse_parse(this.getSelector());
    }
    getExtendedSelector() {
        return extractHTMLSelectorFromRule(this.selector);
    }
    isExtended() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.extended);
    }
    isRemove() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.remove);
    }
    isPureHasSelector() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.isPureHasSelector);
    }
    isUnhide() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.unhide);
    }
    isScriptInject() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.scriptInject);
    }
    isCSS() {
        return false === this.isScriptInject();
    }
    isIdSelector() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.isIdSelector);
    }
    isClassSelector() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.isClassSelector);
    }
    isHrefSelector() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.isHrefSelector);
    }
    isUnicode() {
        return getBit(this.mask, cosmetic_COSMETICS_MASK.isUnicode);
    }
    isHtmlFiltering() {
        return this.getSelector().startsWith('^');
    }
    isGenericHide() {
        var _a, _b;
        return (null === (_a = this === null || void 0 === this ? void 0 : this.domains) || void 0 === _a ? void 0 : _a.hostnames) === void 0 && (null === (_b = this === null || void 0 === this ? void 0 : this.domains) || void 0 === _b ? void 0 : _b.entities) === void 0;
    }
}
class NetworkBuilder {
    constructor(){
        this.options = new Set();
        this.prefix = void 0;
        this.infix = void 0;
        this.suffix = void 0;
        this.redirect = void 0;
    }
    blockRequestsWithType(t) {
        if (this.options.has(t)) throw new Error(`Already blocking type ${t}`);
        this.options.add(t);
        return this;
    }
    images() {
        return this.blockRequestsWithType('image');
    }
    scripts() {
        return this.blockRequestsWithType("script");
    }
    frames() {
        return this.blockRequestsWithType('frame');
    }
    fonts() {
        return this.blockRequestsWithType('font');
    }
    medias() {
        return this.blockRequestsWithType('media');
    }
    styles() {
        return this.blockRequestsWithType('css');
    }
    redirectTo(redirect) {
        if (void 0 !== this.redirect) throw new Error(`Already redirecting: ${this.redirect}`);
        this.redirect = `redirect=${redirect}`;
        return this;
    }
    urlContains(infix) {
        if (void 0 !== this.infix) throw new Error(`Already matching pattern: ${this.infix}`);
        this.infix = infix;
        return this;
    }
    urlStartsWith(prefix) {
        if (void 0 !== this.prefix) throw new Error(`Already matching prefix: ${this.prefix}`);
        this.prefix = `|${prefix}`;
        return this;
    }
    urlEndsWith(suffix) {
        if (void 0 !== this.suffix) throw new Error(`Already matching suffix: ${this.suffix}`);
        this.suffix = `${suffix}|`;
        return this;
    }
    withHostname(hostname) {
        if (void 0 !== this.prefix) throw new Error(`Cannot match hostname if filter already has prefix: ${this.prefix}`);
        this.prefix = `||${hostname}^`;
        return this;
    }
    toString() {
        const parts = [];
        if (void 0 !== this.prefix) parts.push(this.prefix);
        if (void 0 !== this.infix) parts.push(this.infix);
        if (void 0 !== this.suffix) parts.push(this.suffix);
        const options = [
            'important'
        ];
        if (0 !== this.options.size) for (const option of this.options)options.push(option);
        if (void 0 !== this.redirect) options.push(this.redirect);
        return `${0 === parts.length ? '*' : parts.join('*')}$${options.join(',')}`;
    }
}
function block() {
    return new NetworkBuilder();
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const HTTP_HASH = fastHash('http');
const HTTPS_HASH = fastHash('https');
function isAllowedHostname(ch) {
    return utils_isDigit(ch) || isAlpha(ch) || 95 === ch || 45 === ch || 46 === ch;
}
var network_NETWORK_FILTER_MASK;
(function(NETWORK_FILTER_MASK) {
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromDocument"] = 1] = "fromDocument";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromFont"] = 2] = "fromFont";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromHttp"] = 4] = "fromHttp";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromHttps"] = 8] = "fromHttps";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromImage"] = 16] = "fromImage";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromMedia"] = 32] = "fromMedia";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromObject"] = 64] = "fromObject";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromOther"] = 128] = "fromOther";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromPing"] = 256] = "fromPing";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromScript"] = 512] = "fromScript";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromStylesheet"] = 1024] = "fromStylesheet";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromSubdocument"] = 2048] = "fromSubdocument";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromWebsocket"] = 4096] = "fromWebsocket";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["fromXmlHttpRequest"] = 8192] = "fromXmlHttpRequest";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["firstParty"] = 16384] = "firstParty";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["thirdParty"] = 32768] = "thirdParty";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isReplace"] = 65536] = "isReplace";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isBadFilter"] = 131072] = "isBadFilter";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isCSP"] = 262144] = "isCSP";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isGenericHide"] = 524288] = "isGenericHide";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isImportant"] = 1048576] = "isImportant";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isSpecificHide"] = 2097152] = "isSpecificHide";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isFullRegex"] = 4194304] = "isFullRegex";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isRegex"] = 8388608] = "isRegex";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isUnicode"] = 16777216] = "isUnicode";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isLeftAnchor"] = 33554432] = "isLeftAnchor";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isRightAnchor"] = 67108864] = "isRightAnchor";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isException"] = 134217728] = "isException";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isHostnameAnchor"] = 268435456] = "isHostnameAnchor";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isRedirectRule"] = 536870912] = "isRedirectRule";
    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK["isRedirect"] = 1073741824] = "isRedirect";
})(network_NETWORK_FILTER_MASK || (network_NETWORK_FILTER_MASK = {}));
const FROM_ANY = network_NETWORK_FILTER_MASK.fromDocument | network_NETWORK_FILTER_MASK.fromFont | network_NETWORK_FILTER_MASK.fromImage | network_NETWORK_FILTER_MASK.fromMedia | network_NETWORK_FILTER_MASK.fromObject | network_NETWORK_FILTER_MASK.fromOther | network_NETWORK_FILTER_MASK.fromPing | network_NETWORK_FILTER_MASK.fromScript | network_NETWORK_FILTER_MASK.fromStylesheet | network_NETWORK_FILTER_MASK.fromSubdocument | network_NETWORK_FILTER_MASK.fromWebsocket | network_NETWORK_FILTER_MASK.fromXmlHttpRequest;
const REQUEST_TYPE_TO_MASK = {
    beacon: network_NETWORK_FILTER_MASK.fromPing,
    document: network_NETWORK_FILTER_MASK.fromDocument,
    cspviolationreport: network_NETWORK_FILTER_MASK.fromOther,
    fetch: network_NETWORK_FILTER_MASK.fromXmlHttpRequest,
    font: network_NETWORK_FILTER_MASK.fromFont,
    image: network_NETWORK_FILTER_MASK.fromImage,
    imageset: network_NETWORK_FILTER_MASK.fromImage,
    json: network_NETWORK_FILTER_MASK.fromScript,
    mainFrame: network_NETWORK_FILTER_MASK.fromDocument,
    main_frame: network_NETWORK_FILTER_MASK.fromDocument,
    media: network_NETWORK_FILTER_MASK.fromMedia,
    object: network_NETWORK_FILTER_MASK.fromObject,
    object_subrequest: network_NETWORK_FILTER_MASK.fromObject,
    ping: network_NETWORK_FILTER_MASK.fromPing,
    script: network_NETWORK_FILTER_MASK.fromScript,
    stylesheet: network_NETWORK_FILTER_MASK.fromStylesheet,
    subFrame: network_NETWORK_FILTER_MASK.fromSubdocument,
    sub_frame: network_NETWORK_FILTER_MASK.fromSubdocument,
    webSocket: network_NETWORK_FILTER_MASK.fromWebsocket,
    websocket: network_NETWORK_FILTER_MASK.fromWebsocket,
    xhr: network_NETWORK_FILTER_MASK.fromXmlHttpRequest,
    xmlhttprequest: network_NETWORK_FILTER_MASK.fromXmlHttpRequest,
    cspReport: network_NETWORK_FILTER_MASK.fromOther,
    csp_report: network_NETWORK_FILTER_MASK.fromOther,
    eventsource: network_NETWORK_FILTER_MASK.fromOther,
    manifest: network_NETWORK_FILTER_MASK.fromOther,
    other: network_NETWORK_FILTER_MASK.fromOther,
    prefetch: network_NETWORK_FILTER_MASK.fromOther,
    preflight: network_NETWORK_FILTER_MASK.fromOther,
    signedexchange: network_NETWORK_FILTER_MASK.fromOther,
    speculative: network_NETWORK_FILTER_MASK.fromOther,
    texttrack: network_NETWORK_FILTER_MASK.fromOther,
    web_manifest: network_NETWORK_FILTER_MASK.fromOther,
    xml_dtd: network_NETWORK_FILTER_MASK.fromOther,
    xslt: network_NETWORK_FILTER_MASK.fromOther
};
function getListOfRequestTypesNegated(filter) {
    const types = [];
    if (false === filter.fromDocument()) types.push('document');
    if (false === filter.fromImage()) types.push('image');
    if (false === filter.fromMedia()) types.push('media');
    if (false === filter.fromObject()) types.push('object');
    if (false === filter.fromOther()) types.push('other');
    if (false === filter.fromPing()) types.push('ping');
    if (false === filter.fromScript()) types.push("script");
    if (false === filter.fromStylesheet()) types.push('stylesheet');
    if (false === filter.fromSubdocument()) types.push('sub_frame');
    if (false === filter.fromWebsocket()) types.push('websocket');
    if (false === filter.fromXmlHttpRequest()) types.push('xhr');
    if (false === filter.fromFont()) types.push('font');
    return types;
}
function getListOfRequestTypes(filter) {
    const types = [];
    if (filter.fromDocument()) types.push('document');
    if (filter.fromImage()) types.push('image');
    if (filter.fromMedia()) types.push('media');
    if (filter.fromObject()) types.push('object');
    if (filter.fromOther()) types.push('other');
    if (filter.fromPing()) types.push('ping');
    if (filter.fromScript()) types.push("script");
    if (filter.fromStylesheet()) types.push('stylesheet');
    if (filter.fromSubdocument()) types.push('sub_frame');
    if (filter.fromWebsocket()) types.push('websocket');
    if (filter.fromXmlHttpRequest()) types.push('xhr');
    if (filter.fromFont()) types.push('font');
    return types;
}
function network_computeFilterId(mask, filter, hostname, domains, denyallow, optionValue) {
    let hash = HASH_SEED * HASH_INTERNAL_MULT ^ mask;
    if (void 0 !== domains) hash = domains.updateId(hash);
    if (void 0 !== denyallow) hash = denyallow.updateId(hash);
    if (void 0 !== filter) for(let i = 0; i < filter.length; i += 1)hash = hash * HASH_INTERNAL_MULT ^ filter.charCodeAt(i);
    if (void 0 !== hostname) for(let i = 0; i < hostname.length; i += 1)hash = hash * HASH_INTERNAL_MULT ^ hostname.charCodeAt(i);
    if (void 0 !== optionValue) for(let i = 0; i < optionValue.length; i += 1)hash = hash * HASH_INTERNAL_MULT ^ optionValue.charCodeAt(i);
    return hash >>> 0;
}
function compileRegex(filter, isLeftAnchor, isRightAnchor, isFullRegex) {
    if (true === isFullRegex) return new RegExp(filter.slice(1, filter.length - 1), 'i');
    filter = filter.replace(/([|.$+?{}()[\]\\])/g, '\\$1');
    filter = filter.replace(/\*/g, '.*');
    filter = filter.replace(/\^/g, '(?:[^\\w\\d_.%-]|$)');
    if (isRightAnchor) filter = `${filter}$`;
    if (isLeftAnchor) filter = `^${filter}`;
    return new RegExp(filter);
}
function getFilterOptionName(line, pos, end) {
    const start = pos;
    for(; pos < end; pos++){
        const code = line.charCodeAt(pos);
        if (61 === code || 44 === code) {
            end = pos;
            break;
        }
    }
    return [
        pos,
        line.slice(start, end)
    ];
}
function getFilterOptionValue(line, pos, end) {
    let start = pos;
    let value = '';
    for(; pos < end; pos++){
        const code = line.charCodeAt(pos);
        if (92 === code) {
            value += line.slice(start, pos);
            start = ++pos;
        } else if (44 === code) break;
    }
    if (start - pos !== 0) value += line.slice(start, pos);
    return [
        pos,
        value
    ];
}
const REGEXP_CHARACTER_ESCAPES = new Set([
    102,
    110,
    114,
    116,
    118,
    48,
    94,
    36,
    92,
    46,
    42,
    43,
    63,
    40,
    41,
    91,
    93,
    123,
    125,
    124,
    47,
    100,
    68,
    119,
    87,
    115,
    83,
    98,
    66
]);
function isHexLiteral(code) {
    return code >= 48 && code <= 57 || code <= 65 && code <= 70 || code >= 97 && code <= 102;
}
function isCharacterEscapeInRegExp(line, pos, _end) {
    const code = line.charCodeAt(pos + 1);
    if (44 === code || REGEXP_CHARACTER_ESCAPES.has(code)) return [
        pos + 1,
        true
    ];
    if (99 === code) {
        const next = line.charCodeAt(pos + 2);
        if (next >= 65 && next <= 90 || next >= 97 && next <= 122) return [
            pos + 2,
            true
        ];
    }
    if (120 === code && isHexLiteral(line.charCodeAt(pos + 2)) && isHexLiteral(line.charCodeAt(pos + 3))) return [
        pos + 3,
        true
    ];
    if (117 === code) {
        if (123 === line.charCodeAt(pos + 2)) {
            const close = line.indexOf('}', pos + 3);
            const hexLiteralLength = close - pos + 3;
            if (hexLiteralLength >= 1 && hexLiteralLength <= 6) return [
                close,
                true
            ];
        } else if (isHexLiteral(line.charCodeAt(pos + 2)) && isHexLiteral(line.charCodeAt(pos + 3)) && isHexLiteral(line.charCodeAt(pos + 4)) && isHexLiteral(line.charCodeAt(pos + 5))) return [
            pos + 5,
            true
        ];
    }
    return [
        pos + 1,
        false
    ];
}
function isCharacterEscapeInReplace(line, pos, end) {
    const code = line.charCodeAt(pos + 1);
    if (44 === code || 47 === code) return [
        pos + 1,
        false
    ];
    return isCharacterEscapeInRegExp(line, pos, end);
}
function getFilterReplaceOptionValue(line, pos, end) {
    if (47 !== line.charCodeAt(pos++)) return [
        end,
        void 0
    ];
    const parts = [
        '',
        '',
        ''
    ];
    let start = pos;
    let slashes = 0;
    for(; pos < end; pos++){
        const code = line.charCodeAt(pos);
        if (92 === code) {
            parts[slashes] += line.slice(start, pos);
            const [posAfterCharacterEscape, isCharacterEscape] = isCharacterEscapeInReplace(line, pos, end);
            if (false === isCharacterEscape) ++pos;
            start = pos;
            pos = posAfterCharacterEscape;
        } else if (47 === code) {
            if (pos - start !== 0) parts[slashes] += line.slice(start, pos);
            start = pos + 1;
            if (2 === ++slashes) break;
        }
    }
    const valueEnd = line.indexOf(',', pos);
    if (-1 !== valueEnd) end = valueEnd;
    parts[2] = line.slice(start, end);
    pos = end;
    return [
        pos,
        parts
    ];
}
function getFilterOptions(line, pos, end) {
    const options = [];
    let name;
    let value;
    for(; pos < end; pos++){
        [pos, name] = getFilterOptionName(line, pos, end);
        if (void 0 !== name) {
            if (61 === line.charCodeAt(pos)) pos++;
            if ('replace' === name) {
                const result = getFilterReplaceOptionValue(line, pos, end);
                value = void 0 === result[1] ? '' : line.slice(pos, result[0]);
                pos = result[0];
            } else [pos, value] = getFilterOptionValue(line, pos, end);
            options.push([
                name,
                value
            ]);
        }
    }
    return options;
}
function replaceOptionValueToRegexp(value) {
    const [, values] = getFilterReplaceOptionValue(value, 0, value.length);
    if (void 0 === values) return null;
    try {
        return [
            new RegExp(values[0], values[2]),
            values[1]
        ];
    } catch (error) {
        return null;
    }
}
const MATCH_ALL = new RegExp('');
class network_NetworkFilter {
    static parse(line, debug = false) {
        let mask = network_NETWORK_FILTER_MASK.thirdParty | network_NETWORK_FILTER_MASK.firstParty | network_NETWORK_FILTER_MASK.fromHttps | network_NETWORK_FILTER_MASK.fromHttp;
        let cptMaskPositive = 0;
        let cptMaskNegative = FROM_ANY;
        let hostname;
        let domains;
        let denyallow;
        let optionValue;
        let filterIndexStart = 0;
        let filterIndexEnd = line.length;
        if (64 === line.charCodeAt(0) && 64 === line.charCodeAt(1)) {
            filterIndexStart += 2;
            mask = setBit(mask, network_NETWORK_FILTER_MASK.isException);
        }
        const optionsIndex = findLastIndexOfUnescapedCharacter(line, '$');
        if (-1 !== optionsIndex && 47 !== line.charCodeAt(optionsIndex + 1)) {
            filterIndexEnd = optionsIndex;
            for (const rawOption of getFilterOptions(line, optionsIndex + 1, line.length)){
                const negation = 126 === rawOption[0].charCodeAt(0);
                const option = true === negation ? rawOption[0].slice(1) : rawOption[0];
                const value = rawOption[1];
                switch(option){
                    case 'denyallow':
                        denyallow = Domains.parse(value, {
                            delimiter: '|',
                            debug
                        });
                        if (void 0 === denyallow) return null;
                        break;
                    case 'domain':
                    case 'from':
                        domains = Domains.parse(value, {
                            delimiter: '|',
                            debug
                        });
                        if (void 0 === domains) return null;
                        break;
                    case 'badfilter':
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isBadFilter);
                        break;
                    case 'important':
                        if (negation) return null;
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isImportant);
                        break;
                    case 'match-case':
                        if (negation) return null;
                        break;
                    case '3p':
                    case 'third-party':
                        mask = negation ? clearBit(mask, network_NETWORK_FILTER_MASK.thirdParty) : clearBit(mask, network_NETWORK_FILTER_MASK.firstParty);
                        break;
                    case '1p':
                    case 'first-party':
                        mask = negation ? clearBit(mask, network_NETWORK_FILTER_MASK.firstParty) : clearBit(mask, network_NETWORK_FILTER_MASK.thirdParty);
                        break;
                    case 'redirect-rule':
                    case 'redirect':
                        {
                            if (negation) return null;
                            if (0 === value.length) return null;
                            const priorityIndex = value.lastIndexOf(':');
                            if (0 === priorityIndex) return null;
                            if (-1 !== priorityIndex && (true === isNaN(Number(value.slice(priorityIndex + 1))) || priorityIndex + 1 === value.length)) return null;
                            mask = setBit(mask, network_NETWORK_FILTER_MASK.isRedirect);
                            if ('redirect-rule' === option) mask = setBit(mask, network_NETWORK_FILTER_MASK.isRedirectRule);
                            optionValue = value;
                            break;
                        }
                    case 'csp':
                        if (negation) return null;
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isCSP);
                        if (value.length > 0) optionValue = value;
                        break;
                    case 'ehide':
                    case 'elemhide':
                        if (negation) return null;
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isGenericHide);
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isSpecificHide);
                        break;
                    case 'shide':
                    case 'specifichide':
                        if (negation) return null;
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isSpecificHide);
                        break;
                    case 'ghide':
                    case 'generichide':
                        if (negation) return null;
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isGenericHide);
                        break;
                    case "inline-script":
                        if (negation) return null;
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isCSP);
                        optionValue = "script-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:";
                        break;
                    case 'inline-font':
                        if (negation) return null;
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isCSP);
                        optionValue = "font-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:";
                        break;
                    case 'replace':
                    case 'content':
                        if (negation || (0 === value.length ? false === getBit(mask, network_NETWORK_FILTER_MASK.isException) : null === replaceOptionValueToRegexp(value))) return null;
                        mask = setBit(mask, network_NETWORK_FILTER_MASK.isReplace);
                        optionValue = value;
                        break;
                    default:
                        {
                            let optionMask = 0;
                            switch(option){
                                case 'all':
                                    if (negation) return null;
                                    break;
                                case 'image':
                                    optionMask = network_NETWORK_FILTER_MASK.fromImage;
                                    break;
                                case 'media':
                                    optionMask = network_NETWORK_FILTER_MASK.fromMedia;
                                    break;
                                case 'object':
                                case 'object-subrequest':
                                    optionMask = network_NETWORK_FILTER_MASK.fromObject;
                                    break;
                                case 'other':
                                    optionMask = network_NETWORK_FILTER_MASK.fromOther;
                                    break;
                                case 'ping':
                                case 'beacon':
                                    optionMask = network_NETWORK_FILTER_MASK.fromPing;
                                    break;
                                case "script":
                                    optionMask = network_NETWORK_FILTER_MASK.fromScript;
                                    break;
                                case 'css':
                                case 'stylesheet':
                                    optionMask = network_NETWORK_FILTER_MASK.fromStylesheet;
                                    break;
                                case 'frame':
                                case 'subdocument':
                                    optionMask = network_NETWORK_FILTER_MASK.fromSubdocument;
                                    break;
                                case 'xhr':
                                case 'xmlhttprequest':
                                    optionMask = network_NETWORK_FILTER_MASK.fromXmlHttpRequest;
                                    break;
                                case 'websocket':
                                    optionMask = network_NETWORK_FILTER_MASK.fromWebsocket;
                                    break;
                                case 'font':
                                    optionMask = network_NETWORK_FILTER_MASK.fromFont;
                                    break;
                                case 'doc':
                                case 'document':
                                    optionMask = network_NETWORK_FILTER_MASK.fromDocument;
                                    break;
                                default:
                                    return null;
                            }
                            if (negation) cptMaskNegative = clearBit(cptMaskNegative, optionMask);
                            else cptMaskPositive = setBit(cptMaskPositive, optionMask);
                            break;
                        }
                }
            }
        }
        mask = 0 === cptMaskPositive ? setBit(mask, cptMaskNegative) : cptMaskNegative === FROM_ANY ? setBit(mask, cptMaskPositive) : setBit(mask, cptMaskPositive & cptMaskNegative);
        let filter;
        if (filterIndexEnd - filterIndexStart >= 2 && 47 === line.charCodeAt(filterIndexStart) && 47 === line.charCodeAt(filterIndexEnd - 1)) {
            filter = line.slice(filterIndexStart, filterIndexEnd);
            try {
                compileRegex(filter, false, false, true);
            } catch (ex) {
                return null;
            }
            mask = setBit(mask, network_NETWORK_FILTER_MASK.isFullRegex);
        } else {
            if (filterIndexEnd > 0 && 124 === line.charCodeAt(filterIndexEnd - 1)) {
                mask = setBit(mask, network_NETWORK_FILTER_MASK.isRightAnchor);
                filterIndexEnd -= 1;
            }
            if (filterIndexStart < filterIndexEnd && 124 === line.charCodeAt(filterIndexStart)) {
                if (filterIndexStart < filterIndexEnd - 1 && 124 === line.charCodeAt(filterIndexStart + 1)) {
                    mask = setBit(mask, network_NETWORK_FILTER_MASK.isHostnameAnchor);
                    filterIndexStart += 2;
                } else {
                    mask = setBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
                    filterIndexStart += 1;
                }
            }
            if (getBit(mask, network_NETWORK_FILTER_MASK.isHostnameAnchor)) {
                let firstSeparator = filterIndexStart;
                while(firstSeparator < filterIndexEnd && true === isAllowedHostname(line.charCodeAt(firstSeparator)))firstSeparator += 1;
                if (firstSeparator === filterIndexEnd) {
                    hostname = line.slice(filterIndexStart, filterIndexEnd);
                    filterIndexStart = filterIndexEnd;
                } else {
                    hostname = line.slice(filterIndexStart, firstSeparator);
                    filterIndexStart = firstSeparator;
                    const separatorCode = line.charCodeAt(firstSeparator);
                    if (94 === separatorCode) {
                        if (filterIndexEnd - filterIndexStart === 1) {
                            filterIndexStart = filterIndexEnd;
                            mask = setBit(mask, network_NETWORK_FILTER_MASK.isRightAnchor);
                        } else {
                            mask = setBit(mask, network_NETWORK_FILTER_MASK.isRegex);
                            mask = setBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
                        }
                    } else mask = 42 === separatorCode ? setBit(mask, network_NETWORK_FILTER_MASK.isRegex) : setBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
                }
            }
            if (filterIndexEnd - filterIndexStart > 0 && 42 === line.charCodeAt(filterIndexEnd - 1)) filterIndexEnd -= 1;
            if (false === getBit(mask, network_NETWORK_FILTER_MASK.isHostnameAnchor) && filterIndexEnd - filterIndexStart > 0 && 42 === line.charCodeAt(filterIndexStart)) {
                mask = clearBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
                filterIndexStart += 1;
            }
            if (getBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor)) {
                if (filterIndexEnd - filterIndexStart === 5 && line.startsWith('ws://', filterIndexStart)) {
                    mask = setBit(mask, network_NETWORK_FILTER_MASK.fromWebsocket);
                    mask = clearBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
                    mask = clearBit(mask, network_NETWORK_FILTER_MASK.fromHttp);
                    mask = clearBit(mask, network_NETWORK_FILTER_MASK.fromHttps);
                    filterIndexStart = filterIndexEnd;
                } else if (filterIndexEnd - filterIndexStart === 7 && line.startsWith('http://', filterIndexStart)) {
                    mask = setBit(mask, network_NETWORK_FILTER_MASK.fromHttp);
                    mask = clearBit(mask, network_NETWORK_FILTER_MASK.fromHttps);
                    mask = clearBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
                    filterIndexStart = filterIndexEnd;
                } else if (filterIndexEnd - filterIndexStart === 8 && line.startsWith('https://', filterIndexStart)) {
                    mask = setBit(mask, network_NETWORK_FILTER_MASK.fromHttps);
                    mask = clearBit(mask, network_NETWORK_FILTER_MASK.fromHttp);
                    mask = clearBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
                    filterIndexStart = filterIndexEnd;
                } else if (filterIndexEnd - filterIndexStart === 8 && line.startsWith('http*://', filterIndexStart)) {
                    mask = setBit(mask, network_NETWORK_FILTER_MASK.fromHttps);
                    mask = setBit(mask, network_NETWORK_FILTER_MASK.fromHttp);
                    mask = clearBit(mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
                    filterIndexStart = filterIndexEnd;
                }
            }
            if (filterIndexEnd - filterIndexStart > 0) {
                filter = line.slice(filterIndexStart, filterIndexEnd).toLowerCase();
                mask = setNetworkMask(mask, network_NETWORK_FILTER_MASK.isUnicode, hasUnicode(filter));
                if (false === getBit(mask, network_NETWORK_FILTER_MASK.isRegex)) mask = setNetworkMask(mask, network_NETWORK_FILTER_MASK.isRegex, checkIsRegex(filter, 0, filter.length));
            }
            if (void 0 !== hostname) {
                hostname = hostname.toLowerCase();
                if (hasUnicode(hostname)) {
                    mask = setNetworkMask(mask, network_NETWORK_FILTER_MASK.isUnicode, true);
                    hostname = toASCII(hostname);
                }
            }
        }
        return new network_NetworkFilter({
            filter,
            hostname,
            mask,
            domains,
            denyallow,
            optionValue,
            rawLine: true === debug ? line : void 0,
            regex: void 0
        });
    }
    static deserialize(buffer) {
        const mask = buffer.getUint32();
        const optionalParts = buffer.getUint8();
        const isUnicode = getBit(mask, network_NETWORK_FILTER_MASK.isUnicode);
        return new network_NetworkFilter({
            mask,
            filter: (1 & optionalParts) === 1 ? isUnicode ? buffer.getUTF8() : buffer.getNetworkFilter() : void 0,
            hostname: (2 & optionalParts) === 2 ? buffer.getNetworkHostname() : void 0,
            domains: (4 & optionalParts) === 4 ? Domains.deserialize(buffer) : void 0,
            rawLine: (8 & optionalParts) === 8 ? buffer.getRawNetwork() : void 0,
            denyallow: (16 & optionalParts) === 16 ? Domains.deserialize(buffer) : void 0,
            optionValue: (32 & optionalParts) === 32 ? getBit(mask, network_NETWORK_FILTER_MASK.isCSP) ? buffer.getNetworkCSP() : getBit(mask, network_NETWORK_FILTER_MASK.isRedirect) ? buffer.getNetworkRedirect() : buffer.getUTF8() : void 0,
            regex: void 0
        });
    }
    constructor({ filter, hostname, mask, domains, denyallow, optionValue, rawLine, regex }){
        this.filter = filter;
        this.hostname = hostname;
        this.mask = setBit(mask, 0);
        this.domains = domains;
        this.denyallow = denyallow;
        this.optionValue = optionValue;
        this.rawLine = rawLine;
        this.id = void 0;
        this.regex = regex;
    }
    get csp() {
        if (!this.isCSP()) return;
        return this.optionValue;
    }
    get redirect() {
        if (!this.isRedirect()) return;
        return this.optionValue;
    }
    isCosmeticFilter() {
        return false;
    }
    isNetworkFilter() {
        return true;
    }
    match(request) {
        return checkOptions(this, request) && checkPattern(this, request);
    }
    serialize(buffer) {
        buffer.pushUint32(this.mask);
        const index = buffer.getPos();
        buffer.pushUint8(0);
        let optionalParts = 0;
        if (void 0 !== this.filter) {
            optionalParts |= 1;
            if (this.isUnicode()) buffer.pushUTF8(this.filter);
            else buffer.pushNetworkFilter(this.filter);
        }
        if (void 0 !== this.hostname) {
            optionalParts |= 2;
            buffer.pushNetworkHostname(this.hostname);
        }
        if (void 0 !== this.domains) {
            optionalParts |= 4;
            this.domains.serialize(buffer);
        }
        if (void 0 !== this.rawLine) {
            optionalParts |= 8;
            buffer.pushRawNetwork(this.rawLine);
        }
        if (void 0 !== this.denyallow) {
            optionalParts |= 16;
            this.denyallow.serialize(buffer);
        }
        if (void 0 !== this.optionValue) {
            optionalParts |= 32;
            if (this.isCSP()) buffer.pushNetworkCSP(this.optionValue);
            else if (this.isRedirect()) buffer.pushNetworkRedirect(this.optionValue);
            else buffer.pushUTF8(this.optionValue);
        }
        buffer.setByte(index, optionalParts);
    }
    getSerializedSize(compression) {
        let estimate = 5;
        if (void 0 !== this.filter) {
            if (true === this.isUnicode()) estimate += sizeOfUTF8(this.filter);
            else estimate += sizeOfNetworkFilter(this.filter, compression);
        }
        if (void 0 !== this.hostname) estimate += sizeOfNetworkHostname(this.hostname, compression);
        if (void 0 !== this.domains) estimate += this.domains.getSerializedSize();
        if (void 0 !== this.rawLine) estimate += sizeOfRawNetwork(this.rawLine, compression);
        if (void 0 !== this.denyallow) estimate += this.denyallow.getSerializedSize();
        if (void 0 !== this.optionValue) {
            if (this.isCSP()) estimate += sizeOfNetworkCSP(this.optionValue, compression);
            else if (this.isRedirect()) estimate += sizeOfNetworkRedirect(this.optionValue, compression);
            else estimate += sizeOfUTF8(this.optionValue);
        }
        return estimate;
    }
    toString(modifierReplacer) {
        if (void 0 !== this.rawLine) return this.rawLine;
        let filter = '';
        if (this.isException()) filter += '@@';
        if (this.isHostnameAnchor()) filter += '||';
        else if (this.fromHttp() !== this.fromHttps()) {
            if (this.fromHttp()) filter += '|http://';
            else filter += '|https://';
        } else if (this.isLeftAnchor()) filter += '|';
        if (this.hasHostname()) {
            filter += this.getHostname();
            filter += '^';
        }
        if (this.isFullRegex()) filter += `/${this.getRegex().source}/`;
        else if (this.isRegex()) filter += this.getRegex().source;
        else filter += this.getFilter();
        if (this.isRightAnchor() && '^' !== filter[filter.length - 1]) filter += '|';
        const options = [];
        if (false === this.fromAny()) {
            const numberOfCptOptions = bitCount(this.getCptMask());
            const numberOfNegatedOptions = bitCount(FROM_ANY) - numberOfCptOptions;
            if (numberOfNegatedOptions < numberOfCptOptions) for (const type of getListOfRequestTypesNegated(this))options.push(`~${type}`);
            else for (const type of getListOfRequestTypes(this))options.push(type);
        }
        if (this.isImportant()) options.push('important');
        if (this.isRedirectRule()) {
            if ('' === this.optionValue) options.push('redirect-rule');
            else options.push(`redirect-rule=${this.optionValue}`);
        } else if (this.isRedirect()) {
            if ('' === this.optionValue) options.push('redirect');
            else options.push(`redirect=${this.optionValue}`);
        }
        if (this.isCSP()) options.push(`csp=${this.optionValue}`);
        if (this.isElemHide()) options.push('elemhide');
        if (this.isSpecificHide()) options.push('specifichide');
        if (this.isGenericHide()) options.push('generichide');
        if (this.firstParty() !== this.thirdParty()) {
            if (this.firstParty()) options.push('1p');
            if (this.thirdParty()) options.push('3p');
        }
        if (void 0 !== this.domains) {
            if (void 0 !== this.domains.parts) options.push(`domain=${this.domains.parts}`);
            else options.push('domain=<hashed>');
        }
        if (void 0 !== this.denyallow) {
            if (void 0 !== this.denyallow.parts) options.push(`denyallow=${this.denyallow.parts}`);
            else options.push('denyallow=<hashed>');
        }
        if (this.isBadFilter()) options.push('badfilter');
        if (options.length > 0) {
            if ('function' == typeof modifierReplacer) filter += `$${options.map(modifierReplacer).join(',')}`;
            else filter += `$${options.join(',')}`;
        }
        return filter;
    }
    getIdWithoutBadFilter() {
        return network_computeFilterId(this.mask & ~network_NETWORK_FILTER_MASK.isBadFilter, this.filter, this.hostname, this.domains, this.denyallow, this.optionValue);
    }
    getId() {
        if (void 0 === this.id) this.id = network_computeFilterId(this.mask, this.filter, this.hostname, this.domains, this.denyallow, this.optionValue);
        return this.id;
    }
    hasFilter() {
        return void 0 !== this.filter;
    }
    hasDomains() {
        return void 0 !== this.domains;
    }
    getMask() {
        return this.mask;
    }
    getCptMask() {
        return this.getMask() & FROM_ANY;
    }
    isRedirect() {
        return getBit(this.getMask(), network_NETWORK_FILTER_MASK.isRedirect);
    }
    isRedirectRule() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isRedirectRule);
    }
    getRedirect() {
        var _a;
        return null !== (_a = this.optionValue) && void 0 !== _a ? _a : '';
    }
    isReplace() {
        return getBit(this.getMask(), network_NETWORK_FILTER_MASK.isReplace);
    }
    getHtmlModifier() {
        var _a;
        if ((null === (_a = this.optionValue) || void 0 === _a ? void 0 : _a.length) === 0) return null;
        return replaceOptionValueToRegexp(this.optionValue);
    }
    isHtmlFilteringRule() {
        return this.isReplace();
    }
    getRedirectResource() {
        const redirect = this.getRedirect();
        const priorityIndex = redirect.lastIndexOf(':');
        if (-1 === priorityIndex) return redirect;
        return redirect.slice(0, priorityIndex);
    }
    getRedirectPriority() {
        const redirect = this.getRedirect();
        const priorityIndex = redirect.lastIndexOf(':');
        if (-1 === priorityIndex) return 0;
        return Number(redirect.slice(priorityIndex + 1));
    }
    hasHostname() {
        return void 0 !== this.hostname;
    }
    getHostname() {
        return this.hostname || '';
    }
    getFilter() {
        return this.filter || '';
    }
    getRegex() {
        if (void 0 === this.regex) this.regex = void 0 !== this.filter && this.isRegex() ? compileRegex(this.filter, this.isLeftAnchor(), this.isRightAnchor(), this.isFullRegex()) : MATCH_ALL;
        return this.regex;
    }
    getTokens() {
        tokens_buffer_TOKENS_BUFFER.reset();
        if (void 0 !== this.domains && void 0 !== this.domains.hostnames && void 0 === this.domains.entities && void 0 === this.domains.notHostnames && void 0 === this.domains.notEntities && 1 === this.domains.hostnames.length) tokens_buffer_TOKENS_BUFFER.push(this.domains.hostnames[0]);
        if (false === this.isFullRegex()) {
            if (void 0 !== this.filter) {
                const skipLastToken = !this.isRightAnchor();
                const skipFirstToken = !this.isLeftAnchor();
                tokenizeWithWildcardsInPlace(this.filter, skipFirstToken, skipLastToken, tokens_buffer_TOKENS_BUFFER);
            }
            if (void 0 !== this.hostname) tokenizeInPlace(this.hostname, false, void 0 !== this.filter && 42 === this.filter.charCodeAt(0), tokens_buffer_TOKENS_BUFFER);
        } else if (void 0 !== this.filter) tokenizeRegexInPlace(this.filter, tokens_buffer_TOKENS_BUFFER);
        if (true === tokens_buffer_TOKENS_BUFFER.empty() && void 0 !== this.domains && void 0 !== this.domains.hostnames && void 0 === this.domains.entities && void 0 === this.domains.notHostnames && void 0 === this.domains.notEntities) {
            const result = [];
            for (const hostname of this.domains.hostnames){
                const arr = new Uint32Array(1);
                arr[0] = hostname;
                result.push(arr);
            }
            return result;
        }
        if (true === tokens_buffer_TOKENS_BUFFER.empty() && false === this.fromAny()) {
            const types = getListOfRequestTypes(this);
            if (0 !== types.length) {
                const result = [];
                for (const type of types){
                    const arr = new Uint32Array(1);
                    arr[0] = NORMALIZED_TYPE_TOKEN[type];
                    result.push(arr);
                }
                return result;
            }
        }
        if (true === this.fromHttp() && false === this.fromHttps()) tokens_buffer_TOKENS_BUFFER.push(HTTP_HASH);
        else if (true === this.fromHttps() && false === this.fromHttp()) tokens_buffer_TOKENS_BUFFER.push(HTTPS_HASH);
        return [
            tokens_buffer_TOKENS_BUFFER.slice()
        ];
    }
    isCptAllowed(cpt) {
        const mask = REQUEST_TYPE_TO_MASK[cpt];
        if (void 0 !== mask) return getBit(this.mask, mask);
        return this.fromAny();
    }
    isException() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isException);
    }
    isHostnameAnchor() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isHostnameAnchor);
    }
    isRightAnchor() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isRightAnchor);
    }
    isLeftAnchor() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isLeftAnchor);
    }
    isImportant() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isImportant);
    }
    isFullRegex() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isFullRegex);
    }
    isRegex() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isRegex) || getBit(this.mask, network_NETWORK_FILTER_MASK.isFullRegex);
    }
    isPlain() {
        return !this.isRegex();
    }
    isCSP() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isCSP);
    }
    isElemHide() {
        return this.isSpecificHide() && this.isGenericHide();
    }
    isSpecificHide() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isSpecificHide);
    }
    isGenericHide() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isGenericHide);
    }
    isBadFilter() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isBadFilter);
    }
    isUnicode() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.isUnicode);
    }
    fromAny() {
        return this.getCptMask() === FROM_ANY;
    }
    thirdParty() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.thirdParty);
    }
    firstParty() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.firstParty);
    }
    fromImage() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromImage);
    }
    fromMedia() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromMedia);
    }
    fromObject() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromObject);
    }
    fromOther() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromOther);
    }
    fromPing() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromPing);
    }
    fromScript() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromScript);
    }
    fromStylesheet() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromStylesheet);
    }
    fromDocument() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromDocument);
    }
    fromSubdocument() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromSubdocument);
    }
    fromWebsocket() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromWebsocket);
    }
    fromHttp() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromHttp);
    }
    fromHttps() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromHttps);
    }
    fromXmlHttpRequest() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromXmlHttpRequest);
    }
    fromFont() {
        return getBit(this.mask, network_NETWORK_FILTER_MASK.fromFont);
    }
}
function setNetworkMask(mask, m, value) {
    if (true === value) return setBit(mask, m);
    return clearBit(mask, m);
}
function checkIsRegex(filter, start, end) {
    const indexOfSeparator = filter.indexOf('^', start);
    if (-1 !== indexOfSeparator && indexOfSeparator < end) return true;
    const indexOfWildcard = filter.indexOf('*', start);
    return -1 !== indexOfWildcard && indexOfWildcard < end;
}
function isAnchoredByHostname(filterHostname, hostname, isFollowedByWildcard) {
    if (0 === filterHostname.length) return true;
    if (filterHostname.length > hostname.length) return false;
    if (filterHostname.length === hostname.length) return filterHostname === hostname;
    const matchIndex = hostname.indexOf(filterHostname);
    if (-1 === matchIndex) return false;
    if (0 === matchIndex) return true === isFollowedByWildcard || 46 === hostname.charCodeAt(filterHostname.length) || 46 === filterHostname.charCodeAt(filterHostname.length - 1);
    if (hostname.length === matchIndex + filterHostname.length) return 46 === hostname.charCodeAt(matchIndex - 1) || 46 === filterHostname.charCodeAt(0);
    return (true === isFollowedByWildcard || 46 === hostname.charCodeAt(filterHostname.length) || 46 === filterHostname.charCodeAt(filterHostname.length - 1)) && (46 === hostname.charCodeAt(matchIndex - 1) || 46 === filterHostname.charCodeAt(0));
}
function checkPattern(filter, request) {
    const pattern = filter.getFilter();
    if (true === filter.isHostnameAnchor()) {
        const filterHostname = filter.getHostname();
        if (false === isAnchoredByHostname(filterHostname, request.hostname, void 0 !== filter.filter && 42 === filter.filter.charCodeAt(0))) return false;
        if (filter.isRegex()) return filter.getRegex().test(request.url.slice(request.url.indexOf(filterHostname) + filterHostname.length));
        if (filter.isRightAnchor() && filter.isLeftAnchor()) {
            const urlAfterHostname = request.url.slice(request.url.indexOf(filterHostname) + filterHostname.length);
            return pattern === urlAfterHostname;
        }
        if (filter.isRightAnchor()) {
            const requestHostname = request.hostname;
            if (false === filter.hasFilter()) return filterHostname.length === requestHostname.length || requestHostname.endsWith(filterHostname);
            return request.url.endsWith(pattern);
        } else if (filter.isLeftAnchor()) return request.url.startsWith(pattern, request.url.indexOf(filterHostname) + filterHostname.length);
        if (false === filter.hasFilter()) return true;
        return -1 !== request.url.indexOf(pattern, request.url.indexOf(filterHostname) + filterHostname.length);
    }
    if (filter.isRegex()) return filter.getRegex().test(request.url);
    if (filter.isLeftAnchor() && filter.isRightAnchor()) return request.url === pattern;
    if (filter.isLeftAnchor()) return request.url.startsWith(pattern);
    if (filter.isRightAnchor()) return request.url.endsWith(pattern);
    if (false === filter.hasFilter()) return true;
    return -1 !== request.url.indexOf(pattern);
}
function checkOptions(filter, request) {
    if (false === filter.isCptAllowed(request.type) || true === request.isHttps && false === filter.fromHttps() || true === request.isHttp && false === filter.fromHttp() || false === filter.firstParty() && true === request.isFirstParty || false === filter.thirdParty() && true === request.isThirdParty) return false;
    if (void 0 !== filter.domains && false === filter.domains.match(request.sourceHostnameHashes, request.sourceEntityHashes)) return false;
    if (void 0 !== filter.denyallow && true === filter.denyallow.match(request.getHostnameHashes(), request.getEntityHashes())) return false;
    return true;
}
class Env extends Map {
}
var preprocessor_PreprocessorTokens;
(function(PreprocessorTokens) {
    PreprocessorTokens[PreprocessorTokens["INVALID"] = 0] = "INVALID";
    PreprocessorTokens[PreprocessorTokens["BEGIF"] = 1] = "BEGIF";
    PreprocessorTokens[PreprocessorTokens["ELSE"] = 2] = "ELSE";
    PreprocessorTokens[PreprocessorTokens["ENDIF"] = 3] = "ENDIF";
})(preprocessor_PreprocessorTokens || (preprocessor_PreprocessorTokens = {}));
function detectPreprocessor(line) {
    if (line.length < 6 || 33 !== line.charCodeAt(0) || 35 !== line.charCodeAt(1)) return preprocessor_PreprocessorTokens.INVALID;
    if (line.startsWith('!#if ')) return preprocessor_PreprocessorTokens.BEGIF;
    if (line.startsWith('!#else')) return preprocessor_PreprocessorTokens.ELSE;
    if (line.startsWith('!#endif')) return preprocessor_PreprocessorTokens.ENDIF;
    return preprocessor_PreprocessorTokens.INVALID;
}
const tokenizerPattern = /(!|&&|\|\||\(|\)|[a-zA-Z0-9_]+)/g;
const identifierPattern = /^[a-zA-Z0-9_]+$/;
const preprocessor_tokenize = (expression)=>expression.match(tokenizerPattern);
const isIdentifier = (expression)=>identifierPattern.test(expression);
const precedence = {
    '!': 2,
    '&&': 1,
    '||': 0
};
const isOperator = (token)=>Object.prototype.hasOwnProperty.call(precedence, token);
const testIdentifier = (identifier, env)=>{
    if ('true' === identifier && !env.has('true')) return true;
    if ('false' === identifier && !env.has('false')) return false;
    return !!env.get(identifier);
};
const evaluate = (expression, env)=>{
    if (0 === expression.length) return false;
    if (isIdentifier(expression)) {
        if ('!' === expression[0]) return !testIdentifier(expression.slice(1), env);
        return testIdentifier(expression, env);
    }
    const tokens = preprocessor_tokenize(expression);
    if (!tokens || 0 === tokens.length) return false;
    if (expression.length !== tokens.reduce((partialSum, token)=>partialSum + token.length, 0)) return false;
    const output = [];
    const stack = [];
    for (const token of tokens)if ('(' === token) stack.push(token);
    else if (')' === token) {
        while(0 !== stack.length && '(' !== stack[stack.length - 1])output.push(stack.pop());
        if (0 === stack.length) return false;
        stack.pop();
    } else if (isOperator(token)) {
        while(stack.length && isOperator(stack[stack.length - 1]) && precedence[token] <= precedence[stack[stack.length - 1]])output.push(stack.pop());
        stack.push(token);
    } else output.push(testIdentifier(token, env));
    if ('(' === stack[0] || ')' === stack[0]) return false;
    while(0 !== stack.length)output.push(stack.pop());
    for (const token of output)if (true === token || false === token) stack.push(token);
    else if ('!' === token) stack.push(!stack.pop());
    else if (isOperator(token)) {
        const right = stack.pop();
        const left = stack.pop();
        if ('&&' === token) stack.push(left && right);
        else stack.push(left || right);
    }
    return true === stack[0];
};
class Preprocessor {
    static getCondition(line) {
        return line.slice(5).replace(/\s/g, '');
    }
    static parse(line, filterIDs) {
        return new this({
            condition: Preprocessor.getCondition(line),
            filterIDs
        });
    }
    static deserialize(view) {
        const condition = view.getUTF8();
        const filterIDs = new Set();
        for(let i = 0, l = view.getUint32(); i < l; i++)filterIDs.add(view.getUint32());
        return new this({
            condition,
            filterIDs
        });
    }
    constructor({ condition, filterIDs = new Set() }){
        this.condition = condition;
        this.filterIDs = filterIDs;
    }
    evaluate(env) {
        return evaluate(this.condition, env);
    }
    serialize(view) {
        view.pushUTF8(this.condition);
        view.pushUint32(this.filterIDs.size);
        for (const filterID of this.filterIDs)view.pushUint32(filterID);
    }
    getSerializedSize() {
        let estimatedSize = sizeOfUTF8(this.condition);
        estimatedSize += (1 + this.filterIDs.size) * 4;
        return estimatedSize;
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ var lists_FilterType;
(function(FilterType) {
    FilterType[FilterType["NOT_SUPPORTED"] = 0] = "NOT_SUPPORTED";
    FilterType[FilterType["NETWORK"] = 1] = "NETWORK";
    FilterType[FilterType["COSMETIC"] = 2] = "COSMETIC";
    FilterType[FilterType["NOT_SUPPORTED_EMPTY"] = 100] = "NOT_SUPPORTED_EMPTY";
    FilterType[FilterType["NOT_SUPPORTED_COMMENT"] = 101] = "NOT_SUPPORTED_COMMENT";
    FilterType[FilterType["NOT_SUPPORTED_ADGUARD"] = 102] = "NOT_SUPPORTED_ADGUARD";
})(lists_FilterType || (lists_FilterType = {}));
function detectFilterType(line, { extendedNonSupportedTypes = false } = {}) {
    if (0 === line.length || 1 === line.length) {
        if (extendedNonSupportedTypes) return lists_FilterType.NOT_SUPPORTED_EMPTY;
        return lists_FilterType.NOT_SUPPORTED;
    }
    const firstCharCode = line.charCodeAt(0);
    const secondCharCode = line.charCodeAt(1);
    if (33 === firstCharCode || 35 === firstCharCode && secondCharCode <= 32 || 91 === firstCharCode && line.startsWith('[Adblock')) {
        if (extendedNonSupportedTypes) return lists_FilterType.NOT_SUPPORTED_COMMENT;
        return lists_FilterType.NOT_SUPPORTED;
    }
    const lastCharCode = line.charCodeAt(line.length - 1);
    if (36 === firstCharCode && 36 !== secondCharCode && 64 !== secondCharCode || 38 === firstCharCode || 42 === firstCharCode || 45 === firstCharCode || 46 === firstCharCode || 47 === firstCharCode || 58 === firstCharCode || 61 === firstCharCode || 63 === firstCharCode || 64 === firstCharCode || 95 === firstCharCode || 124 === firstCharCode || 124 === lastCharCode) return lists_FilterType.NETWORK;
    const dollarIndex = line.indexOf('$');
    if (-1 !== dollarIndex && dollarIndex !== line.length - 1) {
        const afterDollarIndex = dollarIndex + 1;
        const afterDollarCharCode = line.charCodeAt(afterDollarIndex);
        if (36 === afterDollarCharCode || 64 === afterDollarCharCode && line.startsWith('@$', afterDollarIndex)) {
            if (extendedNonSupportedTypes) return lists_FilterType.NOT_SUPPORTED_ADGUARD;
            return lists_FilterType.NOT_SUPPORTED;
        }
    }
    const sharpIndex = line.indexOf('#');
    if (-1 !== sharpIndex && sharpIndex !== line.length - 1) {
        const afterSharpIndex = sharpIndex + 1;
        const afterSharpCharCode = line.charCodeAt(afterSharpIndex);
        if (35 === afterSharpCharCode || 64 === afterSharpCharCode && line.startsWith('@#', afterSharpIndex)) return lists_FilterType.COSMETIC;
        if (64 === afterSharpCharCode && (line.startsWith('@$#', afterSharpIndex) || line.startsWith('@%#', afterSharpIndex) || line.startsWith('@?#', afterSharpIndex)) || 37 === afterSharpCharCode && line.startsWith('%#', afterSharpIndex) || 36 === afterSharpCharCode && (line.startsWith('$#', afterSharpIndex) || line.startsWith('$?#', afterSharpIndex)) || 63 === afterSharpCharCode && line.startsWith('?#', afterSharpIndex)) {
            if (extendedNonSupportedTypes) return lists_FilterType.NOT_SUPPORTED_ADGUARD;
            return lists_FilterType.NOT_SUPPORTED;
        }
    }
    return lists_FilterType.NETWORK;
}
function parseFilters(list, config = new config_Config()) {
    config = new config_Config(config);
    const networkFilters = [];
    const cosmeticFilters = [];
    const notSupportedFilters = [];
    const lines = list.split('\n');
    const preprocessors = [];
    const preprocessorStack = [];
    for(let i = 0; i < lines.length; i += 1){
        let line = lines[i];
        if (0 !== line.length && line.charCodeAt(0) <= 32) line = line.trim();
        if (line.length > 2) while(i < lines.length - 1 && 92 === line.charCodeAt(line.length - 1) && 32 === line.charCodeAt(line.length - 2)){
            line = line.slice(0, -2);
            const nextLine = lines[i + 1];
            if (nextLine.length > 4 && 32 === nextLine.charCodeAt(0) && 32 === nextLine.charCodeAt(1) && 32 === nextLine.charCodeAt(2) && 32 === nextLine.charCodeAt(3) && 32 !== nextLine.charCodeAt(4)) {
                line += nextLine.slice(4);
                i += 1;
            } else break;
        }
        if (0 !== line.length && line.charCodeAt(line.length - 1) <= 32) line = line.trim();
        const filterType = detectFilterType(line, {
            extendedNonSupportedTypes: true
        });
        if (filterType === lists_FilterType.NETWORK && true === config.loadNetworkFilters) {
            const filter = network_NetworkFilter.parse(line, config.debug);
            if (null !== filter) {
                networkFilters.push(filter);
                if (preprocessorStack.length > 0) preprocessorStack[preprocessorStack.length - 1].filterIDs.add(filter.getId());
            } else notSupportedFilters.push({
                lineNumber: i,
                filter: line,
                filterType
            });
        } else if (filterType === lists_FilterType.COSMETIC && true === config.loadCosmeticFilters) {
            const filter = cosmetic_CosmeticFilter.parse(line, config.debug);
            if (null !== filter) {
                if (true === config.loadGenericCosmeticsFilters || false === filter.isGenericHide()) {
                    cosmeticFilters.push(filter);
                    if (preprocessorStack.length > 0) preprocessorStack[preprocessorStack.length - 1].filterIDs.add(filter.getId());
                }
            } else notSupportedFilters.push({
                lineNumber: i,
                filter: line,
                filterType: lists_FilterType.COSMETIC
            });
        } else if (config.loadPreprocessors) {
            const preprocessorToken = detectPreprocessor(line);
            if (preprocessorToken === preprocessor_PreprocessorTokens.BEGIF) {
                if (preprocessorStack.length > 0) preprocessorStack.push(new Preprocessor({
                    condition: `(${preprocessorStack[preprocessorStack.length - 1].condition})&&(${Preprocessor.getCondition(line)})`
                }));
                else preprocessorStack.push(Preprocessor.parse(line));
            } else if ((preprocessorToken === preprocessor_PreprocessorTokens.ENDIF || preprocessorToken === preprocessor_PreprocessorTokens.ELSE) && preprocessorStack.length > 0) {
                const lastPreprocessor = preprocessorStack.pop();
                preprocessors.push(lastPreprocessor);
                if (preprocessorToken === preprocessor_PreprocessorTokens.ELSE) preprocessorStack.push(new Preprocessor({
                    condition: `!(${lastPreprocessor.condition})`
                }));
            } else if (filterType === lists_FilterType.NOT_SUPPORTED_ADGUARD) notSupportedFilters.push({
                lineNumber: i,
                filter: line,
                filterType
            });
        } else if (filterType === lists_FilterType.NOT_SUPPORTED_ADGUARD) notSupportedFilters.push({
            lineNumber: i,
            filter: line,
            filterType
        });
    }
    return {
        networkFilters,
        cosmeticFilters,
        preprocessors: preprocessors.filter((preprocessor)=>preprocessor.filterIDs.size > 0),
        notSupportedFilters
    };
}
const CONTENT_TYPE = 'video/flv';
const flv = {
    contentType: `${CONTENT_TYPE};base64`,
    aliases: [
        CONTENT_TYPE,
        '.flv',
        'flv'
    ],
    body: 'RkxWAQEAAAAJAAAAABIAALgAAAAAAAAAAgAKb25NZXRhRGF0YQgAAAAIAAhkdXJhdGlvbgAAAAAAAAAAAAAFd2lkdGgAP/AAAAAAAAAABmhlaWdodAA/8AAAAAAAAAANdmlkZW9kYXRhcmF0ZQBAaGoAAAAAAAAJZnJhbWVyYXRlAEBZAAAAAAAAAAx2aWRlb2NvZGVjaWQAQAAAAAAAAAAAB2VuY29kZXICAA1MYXZmNTcuNDEuMTAwAAhmaWxlc2l6ZQBAaoAAAAAAAAAACQAAAMM='
};
const gif_CONTENT_TYPE = 'image/gif';
const gif = {
    contentType: `${gif_CONTENT_TYPE};base64`,
    aliases: [
        gif_CONTENT_TYPE,
        '.gif',
        'gif'
    ],
    body: 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
};
const html_CONTENT_TYPE = 'text/html';
const esm_html = {
    contentType: html_CONTENT_TYPE,
    aliases: [
        html_CONTENT_TYPE,
        '.html',
        'html',
        '.htm',
        'htm',
        'noopframe',
        'noop.html'
    ],
    body: '<!DOCTYPE html>'
};
const ico_CONTENT_TYPE = 'image/vnd.microsoft.icon';
const ico = {
    contentType: `${ico_CONTENT_TYPE};base64`,
    aliases: [
        ico_CONTENT_TYPE,
        '.ico',
        'ico'
    ],
    body: 'AAABAAEAAQEAAAEAGAAwAAAAFgAAACgAAAABAAAAAgAAAAEAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAAAAA=='
};
const jpeg_CONTENT_TYPE = 'image/jpeg';
const jpeg = {
    contentType: `${jpeg_CONTENT_TYPE};base64`,
    aliases: [
        jpeg_CONTENT_TYPE,
        '.jpg',
        'jpg',
        '.jpeg',
        'jpeg'
    ],
    body: '/9j/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/yQALCAABAAEBAREA/8wABgAQEAX/2gAIAQEAAD8A0s8g/9k='
};
const javascript_CONTENT_TYPE = "application/javascript";
const javascript = {
    contentType: javascript_CONTENT_TYPE,
    aliases: [
        javascript_CONTENT_TYPE,
        '.js',
        'js',
        "javascript",
        '.jsx',
        'jsx',
        "typescript",
        '.ts',
        'ts',
        'noop.js',
        'noopjs'
    ],
    body: ''
};
const json_CONTENT_TYPE = 'application/json';
const json = {
    contentType: json_CONTENT_TYPE,
    aliases: [
        json_CONTENT_TYPE,
        '.json',
        'json'
    ],
    body: '0'
};
const mp3_CONTENT_TYPE = 'audio/mpeg';
const mp3 = {
    contentType: `${mp3_CONTENT_TYPE};base64`,
    aliases: [
        mp3_CONTENT_TYPE,
        '.mp3',
        'mp3',
        'noop-0.1s.mp3',
        'noopmp3-0.1s'
    ],
    body: '/+MYxAAAAANIAAAAAExBTUUzLjk4LjIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
};
const mp4_CONTENT_TYPE = 'video/mp4';
const mp4 = {
    contentType: `${mp4_CONTENT_TYPE};base64`,
    aliases: [
        mp4_CONTENT_TYPE,
        '.mp4',
        'mp4',
        '.m4a',
        'm4a',
        '.m4p',
        'm4p',
        '.m4b',
        'm4b',
        '.m4r',
        'm4r',
        '.m4v',
        'm4v',
        'noop-1s.mp4',
        'noopmp4-1s'
    ],
    body: 'AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAC721kYXQhEAUgpBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcCEQBSCkG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAsJtb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAALwABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAB7HRyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAIAAAAAAAAALwAAAAAAAAAAAAAAAQEAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAAC8AAAAAAAEAAAAAAWRtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAAKxEAAAIAFXEAAAAAAAtaGRscgAAAAAAAAAAc291bgAAAAAAAAAAAAAAAFNvdW5kSGFuZGxlcgAAAAEPbWluZgAAABBzbWhkAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAADTc3RibAAAAGdzdHNkAAAAAAAAAAEAAABXbXA0YQAAAAAAAAABAAAAAAAAAAAAAgAQAAAAAKxEAAAAAAAzZXNkcwAAAAADgICAIgACAASAgIAUQBUAAAAAAfQAAAHz+QWAgIACEhAGgICAAQIAAAAYc3R0cwAAAAAAAAABAAAAAgAABAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAIAAAABAAAAHHN0c3oAAAAAAAAAAAAAAAIAAAFzAAABdAAAABRzdGNvAAAAAAAAAAEAAAAsAAAAYnVkdGEAAABabWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAtaWxzdAAAACWpdG9vAAAAHWRhdGEAAAABAAAAAExhdmY1Ni40MC4xMDE='
};
const pdf_CONTENT_TYPE = 'application/pdf';
const pdf = {
    contentType: `${pdf_CONTENT_TYPE};base64`,
    aliases: [
        pdf_CONTENT_TYPE,
        '.pdf',
        'pdf'
    ],
    body: 'JVBERi0xLgoxIDAgb2JqPDwvUGFnZXMgMiAwIFI+PmVuZG9iagoyIDAgb2JqPDwvS2lkc1szIDAgUl0vQ291bnQgMT4+ZW5kb2JqCjMgMCBvYmo8PC9QYXJlbnQgMiAwIFI+PmVuZG9iagp0cmFpbGVyIDw8L1Jvb3QgMSAwIFI+Pg=='
};
const png_CONTENT_TYPE = 'image/png';
const png = {
    contentType: `${png_CONTENT_TYPE};base64`,
    aliases: [
        png_CONTENT_TYPE,
        '.png',
        'png'
    ],
    body: 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg=='
};
const svg_CONTENT_TYPE = 'image/svg+xml';
const svg = {
    contentType: svg_CONTENT_TYPE,
    aliases: [
        svg_CONTENT_TYPE,
        '.svg',
        'svg'
    ],
    body: 'https://raw.githubusercontent.com/mathiasbynens/small/master/svg.svg'
};
const txt_CONTENT_TYPE = 'text/plain';
const txt = {
    contentType: txt_CONTENT_TYPE,
    aliases: [
        txt_CONTENT_TYPE,
        '.txt',
        'txt',
        'text',
        'nooptext',
        'noop.txt'
    ],
    body: ''
};
const wav_CONTENT_TYPE = 'audio/wav';
const wav = {
    contentType: `${wav_CONTENT_TYPE};base64`,
    aliases: [
        wav_CONTENT_TYPE,
        '.wav',
        'wav'
    ],
    body: 'UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA='
};
const webm_CONTENT_TYPE = 'video/webm';
const webm = {
    contentType: `${webm_CONTENT_TYPE};base64`,
    aliases: [
        webm_CONTENT_TYPE,
        '.webm',
        'webm'
    ],
    body: 'GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA='
};
const webp_CONTENT_TYPE = 'image/webp';
const webp = {
    contentType: `${webp_CONTENT_TYPE};base64`,
    aliases: [
        webp_CONTENT_TYPE,
        '.webp',
        'webp'
    ],
    body: 'UklGRhIAAABXRUJQVlA4TAYAAAAvQWxvAGs='
};
const wmv_CONTENT_TYPE = 'video/wmv';
const wmv = {
    contentType: `${wmv_CONTENT_TYPE};base64`,
    aliases: [
        wmv_CONTENT_TYPE,
        '.wmv',
        'wmv'
    ],
    body: 'MCaydY5mzxGm2QCqAGLObOUBAAAAAAAABQAAAAECodyrjEepzxGO5ADADCBTZWgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABcCAAAAAAAAAIA+1d6xnQEAAAAAAAAAAMAF2QEAAAAAAAAAAAAAAAAcDAAAAAAAAAIAAACADAAAgAwAAEANAwC1A79fLqnPEY7jAMAMIFNlLgAAAAAAAAAR0tOruqnPEY7mAMAMIFNlBgAAAAAAQKTQ0gfj0hGX8ACgyV6oUGQAAAAAAAAAAQAoAFcATQAvAEUAbgBjAG8AZABpAG4AZwBTAGUAdAB0AGkAbgBnAHMAAAAAABwATABhAHYAZgA1ADcALgA0ADEALgAxADAAMAAAAJEH3Le3qc8RjuYAwAwgU2WBAAAAAAAAAMDvGbxNW88RqP0AgF9cRCsAV/sgVVvPEaj9AIBfXEQrAAAAAAAAAAAzAAAAAAAAAAEAAAAAAAEAAAABAAAAAigAKAAAAAEAAAABAAAAAQAYAE1QNDMDAAAAAAAAAAAAAAAAAAAAAAAAAEBS0YYdMdARo6QAoMkDSPZMAAAAAAAAAEFS0YYdMdARo6QAoMkDSPYBAAAAAQAKAG0AcwBtAHAAZQBnADQAdgAzAAAAAAAEAE1QNDM2JrJ1jmbPEabZAKoAYs5sMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQ=='
};
const MIME_TO_RESOURCE = (()=>{
    const resources = {};
    for (const fake of [
        flv,
        gif,
        esm_html,
        ico,
        jpeg,
        javascript,
        json,
        mp3,
        mp4,
        pdf,
        png,
        svg,
        txt,
        wav,
        webm,
        webp,
        wmv
    ])for (const alias of fake.aliases)resources[alias] = fake;
    return resources;
})();
function getFallbackTextResource() {
    return txt;
}
function getResourceForMime(mime) {
    return MIME_TO_RESOURCE[mime] || getFallbackTextResource();
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function btoaPolyfill(buffer) {
    if ('undefined' != typeof btoa) return btoa(buffer);
    if ('undefined' != typeof Buffer) return Buffer.from(buffer).toString('base64');
    return buffer;
}
function isResourceValid(resource) {
    if (null === resource) return false;
    if ('object' != typeof resource) return false;
    const { name, aliases, body, contentType } = resource;
    if ('string' != typeof name) return false;
    if (!Array.isArray(aliases) || !aliases.every((alias)=>'string' == typeof alias)) return false;
    if ('string' != typeof body) return false;
    if ('string' != typeof contentType) return false;
    return true;
}
function isScriptletValid(scriptlet) {
    if (null === scriptlet) return false;
    if ('object' != typeof scriptlet) return false;
    const { name, aliases, body, dependencies, executionWorld, requiresTrust } = scriptlet;
    if ('string' != typeof name) return false;
    if (!Array.isArray(aliases) || !aliases.every((alias)=>'string' == typeof alias)) return false;
    if ('string' != typeof body) return false;
    if (!Array.isArray(dependencies) || !dependencies.every((depencency)=>'string' == typeof depencency)) return false;
    if (void 0 !== executionWorld && 'MAIN' !== executionWorld && 'ISOLATED' !== executionWorld) return false;
    if (void 0 !== requiresTrust && 'boolean' != typeof requiresTrust) return false;
    return true;
}
const assembleScript = (script, dependencies = [])=>[
        "if (typeof scriptletGlobals === 'undefined') { var scriptletGlobals = {}; }",
        ...dependencies,
        `(${script})(...['{{1}}','{{2}}','{{3}}','{{4}}','{{5}}','{{6}}','{{7}}','{{8}}','{{9}}','{{10}}'].filter((a,i) => a !== '{{'+(i+1)+'}}').map((a) => decodeURIComponent(a)))`
    ].join(';');
class Resources {
    static deserialize(buffer) {
        const checksum = buffer.getASCII();
        const resources = [];
        const scriptlets = [];
        for(let i = 0, numberOfResources = buffer.getUint16(); i < numberOfResources; i++){
            const name = buffer.getASCII();
            const aliases = [];
            for(let i = 0, numberOfAliases = buffer.getUint16(); i < numberOfAliases; i++)aliases.push(buffer.getASCII());
            resources.push({
                name,
                aliases,
                body: buffer.getUTF8(),
                contentType: buffer.getASCII()
            });
        }
        for(let i = 0, numberOfScriptlets = buffer.getUint16(); i < numberOfScriptlets; i++){
            const name = buffer.getASCII();
            const aliases = [];
            for(let i = 0, numberOfAliases = buffer.getUint16(); i < numberOfAliases; i++)aliases.push(buffer.getASCII());
            const body = buffer.getUTF8();
            const hasExecutionWorld = buffer.getBool();
            const isExecutionWorldIsolated = buffer.getBool();
            const hasRequiresTrust = buffer.getBool();
            const requiresTrust = buffer.getBool();
            const dependencies = [];
            for(let i = 0, numberOfDependencies = buffer.getUint16(); i < numberOfDependencies; i++)dependencies.push(buffer.getASCII());
            const scriptlet = {
                name,
                aliases,
                body,
                dependencies
            };
            if (hasExecutionWorld) scriptlet.executionWorld = true === isExecutionWorldIsolated ? 'ISOLATED' : 'MAIN';
            if (hasRequiresTrust) scriptlet.requiresTrust = requiresTrust;
            scriptlets.push(scriptlet);
        }
        return new Resources({
            checksum,
            scriptlets,
            resources
        });
    }
    static parse(data, { checksum }) {
        const distribution = JSON.parse(data);
        if (null === distribution || 'object' != typeof distribution) throw new Error("Cannot parse resources.json");
        const { scriptlets: rawScriplets, redirects: rawResources } = distribution;
        const resources = [];
        if (Array.isArray(rawResources)) for (const redirect of rawResources)if (isResourceValid(redirect)) resources.push(redirect);
        else throw new Error(`Cannot parse redirect resource: ${JSON.stringify(redirect)}`);
        const scriptlets = [];
        if (Array.isArray(rawScriplets)) for (const scriptlet of rawScriplets)if (isScriptletValid(scriptlet)) scriptlets.push(scriptlet);
        else throw new Error(`Cannot parse scriptlet: ${JSON.stringify(scriptlet)}`);
        return new Resources({
            checksum,
            scriptlets,
            resources
        });
    }
    static copy(sourceResources) {
        const checksum = sourceResources.checksum;
        const resources = [];
        const scriptlets = [];
        for (const resource of sourceResources.resources)resources.push(structuredClone(resource));
        for (const scriptlet of sourceResources.scriptlets)scriptlets.push(structuredClone(scriptlet));
        return new this({
            checksum,
            resources,
            scriptlets
        });
    }
    constructor({ checksum = '', resources = [], scriptlets = [] } = {}){
        this.checksum = checksum;
        this.resources = resources;
        this.scriptlets = scriptlets;
        this.scriptletsCache = new Map();
        this.resourcesByName = new Map();
        this.scriptletsByName = new Map();
        this.updateAliases();
    }
    updateAliases() {
        this.scriptletsCache.clear();
        this.resourcesByName.clear();
        this.scriptletsByName.clear();
        for (const resource of this.resources)for (const name of [
            resource.name,
            ...resource.aliases
        ]){
            if (this.resourcesByName.has(name)) throw new Error(`Resource with a name or alias "${name}" already exists`);
            this.resourcesByName.set(name, resource);
        }
        for (const scriptlet of this.scriptlets)for (const name of [
            scriptlet.name,
            ...scriptlet.aliases
        ]){
            if (this.scriptletsByName.has(name)) throw new Error(`Scriptlet with a name or alias "${name}" already exists`);
            this.scriptletsByName.set(name, scriptlet);
        }
        for (const scriptlet of this.scriptlets)for (const dependencyName of scriptlet.dependencies)if (!this.scriptletsByName.has(dependencyName)) throw new Error(`Scriptlet with a name or alias "${scriptlet.name}" has a missing depencency "${dependencyName}"`);
    }
    getResource(name) {
        const { body, contentType } = this.resourcesByName.get(name) || getResourceForMime(name);
        let dataUrl;
        dataUrl = -1 !== contentType.indexOf(';') ? `data:${contentType},${body}` : `data:${contentType};base64,${btoaPolyfill(body)}`;
        return {
            body,
            contentType,
            dataUrl
        };
    }
    getScriptlet(name) {
        const scriptlet = this.getRawScriptlet(name);
        if (void 0 === scriptlet) return this.getSurrogate(name);
        let script = this.scriptletsCache.get(scriptlet.name);
        if (void 0 !== script) {
            if (0 === script.length) return;
            return script;
        }
        const dependencies = this.getScriptletDependencies(scriptlet);
        script = assembleScript(scriptlet.body, dependencies);
        this.scriptletsCache.set(scriptlet.name, script);
        return script;
    }
    getSurrogate(name) {
        const resource = this.resourcesByName.get(name.endsWith('.js') ? name : `${name}.js`);
        if (void 0 === resource || "application/javascript" !== resource.contentType) return;
        return resource.body;
    }
    getScriptletCanonicalName(name) {
        var _a;
        return null === (_a = this.getRawScriptlet(name)) || void 0 === _a ? void 0 : _a.name;
    }
    getRawScriptlet(name) {
        if (name.endsWith('.fn')) return;
        return this.scriptletsByName.get(name.endsWith('.js') ? name : `${name}.js`);
    }
    getScriptletDependencies(scriptlet) {
        const dependencies = new Map();
        const queue = [
            ...scriptlet.dependencies
        ];
        while(queue.length > 0){
            const dependencyName = queue.pop();
            if (dependencies.has(dependencyName)) continue;
            const dependency = this.scriptletsByName.get(dependencyName);
            dependencies.set(dependencyName, dependency.body);
            queue.push(...dependency.dependencies);
        }
        return Array.from(dependencies.values());
    }
    getSerializedSize() {
        let estimatedSize = sizeOfASCII(this.checksum);
        estimatedSize += 2 * sizeOfByte();
        for (const { name, aliases, body: content, contentType } of this.resources){
            estimatedSize += sizeOfASCII(name);
            estimatedSize += aliases.reduce((state, alias)=>state + sizeOfASCII(alias), 2 * sizeOfByte());
            estimatedSize += sizeOfUTF8(content);
            estimatedSize += sizeOfASCII(contentType);
        }
        estimatedSize += 2 * sizeOfByte();
        for (const { name, aliases, body: content, dependencies } of this.scriptlets){
            estimatedSize += sizeOfASCII(name);
            estimatedSize += aliases.reduce((state, alias)=>state + sizeOfASCII(alias), 2 * sizeOfByte());
            estimatedSize += sizeOfUTF8(content);
            estimatedSize += sizeOfBool();
            estimatedSize += sizeOfBool();
            estimatedSize += sizeOfBool();
            estimatedSize += sizeOfBool();
            estimatedSize += dependencies.reduce((state, dependency)=>state + sizeOfASCII(dependency), 2 * sizeOfByte());
        }
        return estimatedSize;
    }
    serialize(buffer) {
        buffer.pushASCII(this.checksum);
        buffer.pushUint16(this.resources.length);
        for (const { name, aliases, body: content, contentType } of this.resources){
            buffer.pushASCII(name);
            buffer.pushUint16(aliases.length);
            for (const alias of aliases)buffer.pushASCII(alias);
            buffer.pushUTF8(content);
            buffer.pushASCII(contentType);
        }
        buffer.pushUint16(this.scriptlets.length);
        for (const { name, aliases, body: content, dependencies, executionWorld, requiresTrust } of this.scriptlets){
            buffer.pushASCII(name);
            buffer.pushUint16(aliases.length);
            for (const alias of aliases)buffer.pushASCII(alias);
            buffer.pushUTF8(content);
            buffer.pushBool(void 0 !== executionWorld);
            buffer.pushBool('ISOLATED' === executionWorld);
            buffer.pushBool(void 0 !== requiresTrust);
            buffer.pushBool(true === requiresTrust);
            buffer.pushUint16(dependencies.length);
            dependencies.forEach((dependency)=>buffer.pushASCII(dependency));
        }
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function compactTokens(tokens) {
    const sorted = tokens.sort();
    let lastIndex = 1;
    for(let i = 1; i < sorted.length; i += 1)if (sorted[lastIndex - 1] !== sorted[i]) sorted[lastIndex++] = sorted[i];
    return sorted.subarray(0, lastIndex);
}
const compact_set_EMPTY_UINT32_ARRAY = new Uint32Array(0);
function concatTypedArrays(arrays) {
    if (0 === arrays.length) return compact_set_EMPTY_UINT32_ARRAY;
    if (1 === arrays.length) return arrays[0];
    let totalSize = 0;
    for(let i = 0; i < arrays.length; i += 1)totalSize += arrays[i].length;
    const result = new Uint32Array(totalSize);
    let index = 0;
    for(let i = 0; i < arrays.length; i += 1){
        const array = arrays[i];
        for(let j = 0; j < array.length; j += 1)result[index++] = array[j];
    }
    return result;
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function processRegex(r) {
    return `(?:${r.source})`;
}
function optimizer_escape(s) {
    return `(?:${s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')})`;
}
function setWithDefault(map, key, value) {
    let bucket = map.get(key);
    if (void 0 === bucket) {
        bucket = [];
        map.set(key, bucket);
    }
    bucket.push(value);
}
function groupBy(filters, criteria) {
    const grouped = new Map();
    for (const filter of filters)setWithDefault(grouped, criteria(filter), filter);
    return Array.from(grouped.values());
}
function splitBy(filters, condition) {
    const positive = [];
    const negative = [];
    for (const filter of filters)if (condition(filter)) positive.push(filter);
    else negative.push(filter);
    return {
        negative,
        positive
    };
}
const OPTIMIZATIONS = [
    {
        description: 'Remove duplicated filters by ID',
        fusion: (filters)=>filters[0],
        groupByCriteria: (filter)=>'' + filter.getId(),
        select: ()=>true
    },
    {
        description: 'Group idential filter with same mask but different domains in single filters',
        fusion: (filters)=>{
            const parts = [];
            const hostnames = new Set();
            const notHostnames = new Set();
            const entities = new Set();
            const notEntities = new Set();
            for (const { domains } of filters)if (void 0 !== domains) {
                if (void 0 !== domains.parts) parts.push(domains.parts);
                if (void 0 !== domains.hostnames) for (const hash of domains.hostnames)hostnames.add(hash);
                if (void 0 !== domains.entities) for (const hash of domains.entities)entities.add(hash);
                if (void 0 !== domains.notHostnames) for (const hash of domains.notHostnames)notHostnames.add(hash);
                if (void 0 !== domains.notEntities) for (const hash of domains.notEntities)notEntities.add(hash);
            }
            return new network_NetworkFilter(Object.assign({}, filters[0], {
                domains: new Domains({
                    hostnames: 0 !== hostnames.size ? new Uint32Array(hostnames).sort() : void 0,
                    entities: 0 !== entities.size ? new Uint32Array(entities).sort() : void 0,
                    notHostnames: 0 !== notHostnames.size ? new Uint32Array(notHostnames).sort() : void 0,
                    notEntities: 0 !== notEntities.size ? new Uint32Array(notEntities).sort() : void 0,
                    parts: 0 !== parts.length ? parts.join(',') : void 0
                }),
                rawLine: void 0 !== filters[0].rawLine ? filters.map(({ rawLine })=>rawLine).join(' <+> ') : void 0
            }));
        },
        groupByCriteria: (filter)=>{
            var _a;
            return filter.getHostname() + filter.getFilter() + filter.getMask() + (null !== (_a = filter.optionValue) && void 0 !== _a ? _a : '');
        },
        select: (filter)=>!filter.isCSP() && void 0 === filter.denyallow && void 0 !== filter.domains
    },
    {
        description: 'Group simple patterns, into a single filter',
        fusion: (filters)=>{
            const patterns = [];
            for (const f of filters)if (f.isRegex()) patterns.push(processRegex(f.getRegex()));
            else if (f.isRightAnchor()) patterns.push(`${optimizer_escape(f.getFilter())}$`);
            else if (f.isLeftAnchor()) patterns.push(`^${optimizer_escape(f.getFilter())}`);
            else patterns.push(optimizer_escape(f.getFilter()));
            return new network_NetworkFilter(Object.assign({}, filters[0], {
                mask: setBit(filters[0].mask, network_NETWORK_FILTER_MASK.isRegex),
                rawLine: void 0 !== filters[0].rawLine ? filters.map(({ rawLine })=>rawLine).join(' <+> ') : void 0,
                regex: new RegExp(patterns.join('|'))
            }));
        },
        groupByCriteria: (filter)=>'' + (filter.getMask() & ~network_NETWORK_FILTER_MASK.isRegex & ~network_NETWORK_FILTER_MASK.isFullRegex),
        select: (filter)=>void 0 === filter.domains && void 0 === filter.denyallow && !filter.isHostnameAnchor() && !filter.isRedirect() && !filter.isCSP()
    }
];
function noopOptimizeNetwork(filters) {
    return filters;
}
function noopOptimizeCosmetic(filters) {
    return filters;
}
function optimizeNetwork(filters) {
    const fused = [];
    let toFuse = filters;
    for (const { select, fusion, groupByCriteria } of OPTIMIZATIONS){
        const { positive, negative } = splitBy(toFuse, select);
        toFuse = negative;
        const groups = groupBy(positive, groupByCriteria);
        for (const group of groups)if (group.length > 1) fused.push(fusion(group));
        else toFuse.push(group[0]);
    }
    for (const filter of toFuse)fused.push(filter);
    return fused;
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function nextPow2(v) {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}
let UID = 1;
function getNextId() {
    const id = UID;
    UID = (UID + 1) % 1000000000;
    return id;
}
const EMPTY_BUCKET = Number.MAX_SAFE_INTEGER >>> 0;
class ReverseIndex {
    static deserialize(buffer, deserialize, optimize, config) {
        const tokensLookupIndexSize = buffer.getUint32();
        const bucketsIndexSize = buffer.getUint32();
        const numberOfFilters = buffer.getUint32();
        const view = StaticDataView.fromUint8Array(buffer.getBytes(true), config);
        const tokensLookupIndex = view.getUint32ArrayView(tokensLookupIndexSize);
        const bucketsIndex = view.getUint32ArrayView(bucketsIndexSize);
        const filtersIndexStart = view.pos;
        view.seekZero();
        return new ReverseIndex({
            config,
            deserialize,
            filters: [],
            optimize
        }).updateInternals({
            bucketsIndex,
            filtersIndexStart,
            numberOfFilters,
            tokensLookupIndex,
            view
        });
    }
    constructor({ deserialize, filters, optimize, config }){
        this.bucketsIndex = EMPTY_UINT32_ARRAY;
        this.filtersIndexStart = 0;
        this.numberOfFilters = 0;
        this.tokensLookupIndex = EMPTY_UINT32_ARRAY;
        this.cache = new Map();
        this.view = StaticDataView.empty(config);
        this.deserializeFilter = deserialize;
        this.optimize = optimize;
        this.config = config;
        if (0 !== filters.length) this.update(filters, void 0);
    }
    getFilters() {
        const filters = [];
        if (0 === this.numberOfFilters) return filters;
        this.view.setPos(this.filtersIndexStart);
        for(let i = 0; i < this.numberOfFilters; i += 1)filters.push(this.deserializeFilter(this.view));
        this.view.seekZero();
        return filters;
    }
    getTokens() {
        const tokens = new Set();
        for(let i = 0; i < this.bucketsIndex.length; i += 2)tokens.add(this.bucketsIndex[i]);
        return new Uint32Array(tokens);
    }
    getSerializedSize() {
        return 12 + sizeOfBytes(this.view.buffer, true);
    }
    serialize(buffer) {
        buffer.pushUint32(this.tokensLookupIndex.length);
        buffer.pushUint32(this.bucketsIndex.length);
        buffer.pushUint32(this.numberOfFilters);
        buffer.pushBytes(this.view.buffer, true);
    }
    iterMatchingFilters(tokens, cb) {
        const requestId = getNextId();
        for (const token of tokens)if (false === this.iterBucket(token, requestId, cb)) return;
        this.iterBucket(0, requestId, cb);
    }
    update(newFilters, removedFilters) {
        if (0 !== this.cache.size) this.cache.clear();
        const compression = this.config.enableCompression;
        let totalNumberOfTokens = 0;
        let totalNumberOfIndexedFilters = 0;
        const filtersTokens = [];
        let bucketsIndexSize = 0;
        let estimatedBufferSize = this.view.buffer.byteLength - this.filtersIndexStart;
        let filters = this.getFilters();
        if (0 !== filters.length) {
            if (void 0 !== removedFilters && 0 !== removedFilters.size) filters = filters.filter((f)=>{
                if (removedFilters.has(f.getId())) {
                    estimatedBufferSize -= f.getSerializedSize(compression);
                    return false;
                }
                return true;
            });
            for (const filter of newFilters){
                estimatedBufferSize += filter.getSerializedSize(compression);
                filters.push(filter);
            }
        } else {
            filters = newFilters;
            for (const filter of newFilters)estimatedBufferSize += filter.getSerializedSize(compression);
        }
        if (0 === filters.length) {
            this.updateInternals({
                bucketsIndex: EMPTY_UINT32_ARRAY,
                filtersIndexStart: 0,
                numberOfFilters: 0,
                tokensLookupIndex: EMPTY_UINT32_ARRAY,
                view: StaticDataView.empty(this.config)
            });
            return;
        }
        if (true === this.config.debug) filters.sort((f1, f2)=>f1.getId() - f2.getId());
        const histogram = new Uint32Array(Math.max(nextPow2(2 * filters.length), 256));
        for (const filter of filters){
            const multiTokens = filter.getTokens();
            filtersTokens.push(multiTokens);
            bucketsIndexSize += 2 * multiTokens.length;
            totalNumberOfIndexedFilters += multiTokens.length;
            for (const tokens of multiTokens){
                totalNumberOfTokens += tokens.length;
                for (const token of tokens)histogram[token % histogram.length] += 1;
            }
        }
        estimatedBufferSize += 4 * bucketsIndexSize;
        const tokensLookupIndexSize = Math.max(2, nextPow2(totalNumberOfIndexedFilters));
        const mask = tokensLookupIndexSize - 1;
        const suffixes = [];
        for(let i = 0; i < tokensLookupIndexSize; i += 1)suffixes.push([]);
        estimatedBufferSize += 4 * tokensLookupIndexSize;
        const buffer = StaticDataView.allocate(estimatedBufferSize, this.config);
        const tokensLookupIndex = buffer.getUint32ArrayView(tokensLookupIndexSize);
        const bucketsIndex = buffer.getUint32ArrayView(bucketsIndexSize);
        const filtersIndexStart = buffer.getPos();
        for(let i = 0; i < filtersTokens.length; i += 1){
            const filter = filters[i];
            const multiTokens = filtersTokens[i];
            const filterIndex = buffer.pos;
            filter.serialize(buffer);
            for (const tokens of multiTokens){
                let bestToken = 0;
                let minCount = totalNumberOfTokens + 1;
                for (const token of tokens){
                    const tokenCount = histogram[token % histogram.length];
                    if (tokenCount < minCount) {
                        minCount = tokenCount;
                        bestToken = token;
                        if (1 === minCount) break;
                    }
                }
                suffixes[bestToken & mask].push([
                    bestToken,
                    filterIndex
                ]);
            }
        }
        let indexInBucketsIndex = 0;
        for(let i = 0; i < tokensLookupIndexSize; i += 1){
            const filtersForMask = suffixes[i];
            tokensLookupIndex[i] = indexInBucketsIndex;
            for (const [token, filterIndex] of filtersForMask){
                bucketsIndex[indexInBucketsIndex++] = token;
                bucketsIndex[indexInBucketsIndex++] = filterIndex;
            }
        }
        buffer.seekZero();
        this.updateInternals({
            bucketsIndex,
            filtersIndexStart,
            numberOfFilters: filtersTokens.length,
            tokensLookupIndex,
            view: buffer
        });
    }
    updateInternals({ bucketsIndex, filtersIndexStart, numberOfFilters, tokensLookupIndex, view }) {
        this.bucketsIndex = bucketsIndex;
        this.filtersIndexStart = filtersIndexStart;
        this.numberOfFilters = numberOfFilters;
        this.tokensLookupIndex = tokensLookupIndex;
        this.view = view;
        view.seekZero();
        return this;
    }
    iterBucket(token, requestId, cb) {
        let bucket = true === this.config.enableInMemoryCache ? this.cache.get(token) : void 0;
        if (void 0 === bucket) {
            const offset = token & this.tokensLookupIndex.length - 1;
            const startOfBucket = this.tokensLookupIndex[offset];
            if (startOfBucket === EMPTY_BUCKET) return true;
            const endOfBucket = offset === this.tokensLookupIndex.length - 1 ? this.bucketsIndex.length : this.tokensLookupIndex[offset + 1];
            const filtersIndices = [];
            for(let i = startOfBucket; i < endOfBucket; i += 2){
                const currentToken = this.bucketsIndex[i];
                if (currentToken === token) filtersIndices.push(this.bucketsIndex[i + 1]);
            }
            if (0 === filtersIndices.length) return true;
            const filters = [];
            const view = this.view;
            for(let i = 0; i < filtersIndices.length; i += 1){
                view.setPos(filtersIndices[i]);
                filters.push(this.deserializeFilter(view));
            }
            bucket = {
                filters: filters.length > 1 ? this.optimize(filters) : filters,
                lastRequestSeen: -1
            };
            if (true === this.config.enableInMemoryCache) this.cache.set(token, bucket);
        }
        if (bucket.lastRequestSeen !== requestId) {
            bucket.lastRequestSeen = requestId;
            const filters = bucket.filters;
            for(let i = 0; i < filters.length; i += 1)if (false === cb(filters[i])) {
                if (i > 0) {
                    const filter = filters[i];
                    filters[i] = filters[i - 1];
                    filters[i - 1] = filter;
                }
                return false;
            }
        }
        return true;
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const EMPTY_FILTERS = new Uint8Array(4);
class FiltersContainer {
    static deserialize(buffer, deserialize, config) {
        const container = new FiltersContainer({
            deserialize,
            config,
            filters: []
        });
        container.filters = buffer.getBytes();
        return container;
    }
    constructor({ config, deserialize, filters }){
        this.deserialize = deserialize;
        this.filters = EMPTY_FILTERS;
        this.config = config;
        if (0 !== filters.length) this.update(filters, void 0);
    }
    update(newFilters, removedFilters) {
        let bufferSizeEstimation = this.filters.byteLength;
        let selected = [];
        const compression = this.config.enableCompression;
        const currentFilters = this.getFilters();
        if (0 !== currentFilters.length) {
            if (void 0 === removedFilters || 0 === removedFilters.size) selected = currentFilters;
            else for (const filter of currentFilters)if (false === removedFilters.has(filter.getId())) selected.push(filter);
            else bufferSizeEstimation -= filter.getSerializedSize(compression);
        }
        const storedFiltersRemoved = selected.length !== currentFilters.length;
        const numberOfExistingFilters = selected.length;
        for (const filter of newFilters){
            bufferSizeEstimation += filter.getSerializedSize(compression);
            selected.push(filter);
        }
        const storedFiltersAdded = selected.length > numberOfExistingFilters;
        if (0 === selected.length) this.filters = EMPTY_FILTERS;
        else if (true === storedFiltersAdded || true === storedFiltersRemoved) {
            const buffer = StaticDataView.allocate(bufferSizeEstimation, this.config);
            buffer.pushUint32(selected.length);
            if (true === this.config.debug) selected.sort((f1, f2)=>f1.getId() - f2.getId());
            for (const filter of selected)filter.serialize(buffer);
            this.filters = buffer.buffer;
        }
    }
    getSerializedSize() {
        return sizeOfBytes(this.filters, false);
    }
    serialize(buffer) {
        buffer.pushBytes(this.filters);
    }
    getFilters() {
        if (this.filters.byteLength <= 4) return [];
        const filters = [];
        const buffer = StaticDataView.fromUint8Array(this.filters, this.config);
        const numberOfFilters = buffer.getUint32();
        for(let i = 0; i < numberOfFilters; i += 1)filters.push(this.deserialize(buffer));
        return filters;
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function createStylesheet(rules, style = DEFAULT_HIDING_STYLE) {
    if (0 === rules.length) return '';
    const maximumNumberOfSelectors = 1024;
    const parts = [];
    const styleStr = ` { ${style} }`;
    for(let i = 0; i < rules.length; i += maximumNumberOfSelectors){
        let selector = rules[i];
        for(let j = i + 1, end = Math.min(rules.length, i + maximumNumberOfSelectors); j < end; j += 1)selector += ',\n' + rules[j];
        selector += styleStr;
        if (rules.length < maximumNumberOfSelectors) return selector;
        parts.push(selector);
    }
    return parts.join('\n');
}
function createStylesheetFromRulesWithCustomStyles(rules, hidingStyle = DEFAULT_HIDING_STYLE) {
    const selectorsPerStyle = new Map();
    for (const rule of rules){
        const style = rule.getStyle(hidingStyle);
        const selectors = selectorsPerStyle.get(style);
        if (void 0 === selectors) selectorsPerStyle.set(style, [
            rule.getSelector()
        ]);
        else selectors.push(rule.getSelector());
    }
    const stylesheets = [];
    const selectorsPerStyleArray = Array.from(selectorsPerStyle.entries());
    for (const [style, selectors] of selectorsPerStyleArray)stylesheets.push(createStylesheet(selectors, style));
    return stylesheets.join('\n\n');
}
function createStylesheetFromRules(rules, hidingStyle = DEFAULT_HIDING_STYLE) {
    const selectors = [];
    for (const rule of rules){
        if (rule.hasCustomStyle()) return createStylesheetFromRulesWithCustomStyles(rules, hidingStyle);
        selectors.push(rule.selector);
    }
    return createStylesheet(selectors, hidingStyle);
}
function createLookupTokens(hostname, domain) {
    const hostnamesHashes = getHostnameHashesFromLabelsBackward(hostname, domain);
    const entitiesHashes = getEntityHashesFromLabelsBackward(hostname, domain);
    const tokens = new Uint32Array(hostnamesHashes.length + entitiesHashes.length);
    let index = 0;
    for (const hash of hostnamesHashes)tokens[index++] = hash;
    for (const hash of entitiesHashes)tokens[index++] = hash;
    return tokens;
}
class CosmeticFilterBucket {
    static deserialize(buffer, config) {
        const bucket = new CosmeticFilterBucket({
            config
        });
        bucket.genericRules = FiltersContainer.deserialize(buffer, cosmetic_CosmeticFilter.deserialize, config);
        bucket.classesIndex = ReverseIndex.deserialize(buffer, cosmetic_CosmeticFilter.deserialize, noopOptimizeCosmetic, config);
        bucket.hostnameIndex = ReverseIndex.deserialize(buffer, cosmetic_CosmeticFilter.deserialize, noopOptimizeCosmetic, config);
        bucket.hrefsIndex = ReverseIndex.deserialize(buffer, cosmetic_CosmeticFilter.deserialize, noopOptimizeCosmetic, config);
        bucket.idsIndex = ReverseIndex.deserialize(buffer, cosmetic_CosmeticFilter.deserialize, noopOptimizeCosmetic, config);
        bucket.unhideIndex = ReverseIndex.deserialize(buffer, cosmetic_CosmeticFilter.deserialize, noopOptimizeCosmetic, config);
        return bucket;
    }
    constructor({ filters = [], config }){
        this.genericRules = new FiltersContainer({
            config,
            deserialize: cosmetic_CosmeticFilter.deserialize,
            filters: []
        });
        this.classesIndex = new ReverseIndex({
            config,
            deserialize: cosmetic_CosmeticFilter.deserialize,
            filters: [],
            optimize: noopOptimizeCosmetic
        });
        this.hostnameIndex = new ReverseIndex({
            config,
            deserialize: cosmetic_CosmeticFilter.deserialize,
            filters: [],
            optimize: noopOptimizeCosmetic
        });
        this.hrefsIndex = new ReverseIndex({
            config,
            deserialize: cosmetic_CosmeticFilter.deserialize,
            filters: [],
            optimize: noopOptimizeCosmetic
        });
        this.idsIndex = new ReverseIndex({
            config,
            deserialize: cosmetic_CosmeticFilter.deserialize,
            filters: [],
            optimize: noopOptimizeCosmetic
        });
        this.unhideIndex = new ReverseIndex({
            config,
            deserialize: cosmetic_CosmeticFilter.deserialize,
            filters: [],
            optimize: noopOptimizeCosmetic
        });
        this.baseStylesheet = null;
        this.extraGenericRules = null;
        if (0 !== filters.length) this.update(filters, void 0, config);
    }
    getFilters() {
        const filters = [];
        return filters.concat(this.genericRules.getFilters(), this.classesIndex.getFilters(), this.hostnameIndex.getFilters(), this.hrefsIndex.getFilters(), this.idsIndex.getFilters(), this.unhideIndex.getFilters());
    }
    update(newFilters, removedFilters, config) {
        const classSelectors = [];
        const genericHideRules = [];
        const hostnameSpecificRules = [];
        const hrefSelectors = [];
        const idSelectors = [];
        const unHideRules = [];
        for (const rule of newFilters)if (rule.isUnhide()) unHideRules.push(rule);
        else if (rule.isGenericHide()) {
            if (rule.isClassSelector()) classSelectors.push(rule);
            else if (rule.isIdSelector()) idSelectors.push(rule);
            else if (rule.isHrefSelector()) hrefSelectors.push(rule);
            else genericHideRules.push(rule);
        } else if (false === rule.isExtended() || true === config.loadExtendedSelectors || rule.isPureHasSelector()) hostnameSpecificRules.push(rule);
        this.genericRules.update(genericHideRules, removedFilters);
        this.classesIndex.update(classSelectors, removedFilters);
        this.hostnameIndex.update(hostnameSpecificRules, removedFilters);
        this.hrefsIndex.update(hrefSelectors, removedFilters);
        this.idsIndex.update(idSelectors, removedFilters);
        this.unhideIndex.update(unHideRules, removedFilters);
    }
    getSerializedSize() {
        return this.genericRules.getSerializedSize() + this.classesIndex.getSerializedSize() + this.hostnameIndex.getSerializedSize() + this.hrefsIndex.getSerializedSize() + this.idsIndex.getSerializedSize() + this.unhideIndex.getSerializedSize();
    }
    serialize(buffer) {
        this.genericRules.serialize(buffer);
        this.classesIndex.serialize(buffer);
        this.hostnameIndex.serialize(buffer);
        this.hrefsIndex.serialize(buffer);
        this.idsIndex.serialize(buffer);
        this.unhideIndex.serialize(buffer);
    }
    getCosmeticsFilters({ domain, hostname, classes = [], hrefs = [], ids = [], allowGenericHides = true, allowSpecificHides = true, getRulesFromDOM = true, getRulesFromHostname = true, isFilterExcluded }) {
        const hostnameTokens = createLookupTokens(hostname, domain);
        const filters = [];
        if (true === getRulesFromHostname) this.hostnameIndex.iterMatchingFilters(hostnameTokens, (filter)=>{
            if ((true === allowSpecificHides || true === filter.isScriptInject()) && filter.match(hostname, domain) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) filters.push(filter);
            return true;
        });
        if (true === allowGenericHides && true === getRulesFromHostname) {
            const genericRules = this.getGenericRules();
            for (const filter of genericRules)if (true === filter.match(hostname, domain) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) filters.push(filter);
        }
        if (true === allowGenericHides && true === getRulesFromDOM && 0 !== classes.length) this.classesIndex.iterMatchingFilters(hashStrings(classes), (filter)=>{
            if (filter.match(hostname, domain) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) filters.push(filter);
            return true;
        });
        if (true === allowGenericHides && true === getRulesFromDOM && 0 !== ids.length) this.idsIndex.iterMatchingFilters(hashStrings(ids), (filter)=>{
            if (filter.match(hostname, domain) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) filters.push(filter);
            return true;
        });
        if (true === allowGenericHides && true === getRulesFromDOM && 0 !== hrefs.length) this.hrefsIndex.iterMatchingFilters(compactTokens(concatTypedArrays(hrefs.map((href)=>tokenizeNoSkip(href)))), (filter)=>{
            if (filter.match(hostname, domain) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) filters.push(filter);
            return true;
        });
        const unhides = [];
        if (0 !== filters.length) this.unhideIndex.iterMatchingFilters(hostnameTokens, (filter)=>{
            if (filter.match(hostname, domain) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) unhides.push(filter);
            return true;
        });
        return {
            filters,
            unhides
        };
    }
    getStylesheetsFromFilters({ filters, extendedFilters }, { getBaseRules, allowGenericHides, hidingStyle = DEFAULT_HIDING_STYLE }) {
        let stylesheet = false === getBaseRules || false === allowGenericHides ? '' : this.getBaseStylesheet();
        if (hidingStyle !== DEFAULT_HIDING_STYLE) stylesheet = stylesheet.replace(DEFAULT_HIDING_STYLE, hidingStyle);
        if (0 !== filters.length) {
            if (0 !== stylesheet.length) stylesheet += '\n\n';
            stylesheet += createStylesheetFromRules(filters, hidingStyle);
        }
        const extended = [];
        if (0 !== extendedFilters.length) {
            const extendedStyles = new Map();
            for (const filter of extendedFilters){
                const ast = filter.getSelectorAST();
                if (void 0 !== ast) {
                    const attribute = filter.isRemove() ? void 0 : filter.getStyleAttributeHash();
                    if (void 0 !== attribute) extendedStyles.set(filter.getStyle(hidingStyle), attribute);
                    extended.push({
                        ast,
                        remove: filter.isRemove(),
                        attribute
                    });
                }
            }
            if (0 !== extendedStyles.size) {
                if (0 !== stylesheet.length) stylesheet += '\n\n';
                stylesheet += [
                    ...extendedStyles.entries()
                ].map(([style, attribute])=>`[${attribute}] { ${style} }`).join('\n\n');
            }
        }
        return {
            stylesheet,
            extended
        };
    }
    getGenericRules() {
        if (null === this.extraGenericRules) return this.lazyPopulateGenericRulesCache().genericRules;
        return this.extraGenericRules;
    }
    getBaseStylesheet() {
        if (null === this.baseStylesheet) return this.lazyPopulateGenericRulesCache().baseStylesheet;
        return this.baseStylesheet;
    }
    lazyPopulateGenericRulesCache() {
        if (null === this.baseStylesheet || null === this.extraGenericRules) {
            const unHideRules = this.unhideIndex.getFilters();
            const canBeHiddenSelectors = new Set();
            for (const rule of unHideRules)canBeHiddenSelectors.add(rule.getSelector());
            const genericRules = this.genericRules.getFilters();
            const cannotBeHiddenRules = [];
            const canBeHiddenRules = [];
            for (const rule of genericRules)if (rule.hasCustomStyle() || rule.isScriptInject() || rule.hasHostnameConstraint() || canBeHiddenSelectors.has(rule.getSelector())) canBeHiddenRules.push(rule);
            else cannotBeHiddenRules.push(rule);
            this.baseStylesheet = createStylesheetFromRules(cannotBeHiddenRules);
            this.extraGenericRules = canBeHiddenRules;
        }
        return {
            baseStylesheet: this.baseStylesheet,
            genericRules: this.extraGenericRules
        };
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ class NetworkFilterBucket {
    static deserialize(buffer, config) {
        const bucket = new NetworkFilterBucket({
            config
        });
        bucket.index = ReverseIndex.deserialize(buffer, network_NetworkFilter.deserialize, config.enableOptimizations ? optimizeNetwork : noopOptimizeNetwork, config);
        bucket.badFilters = FiltersContainer.deserialize(buffer, network_NetworkFilter.deserialize, config);
        return bucket;
    }
    constructor({ filters = [], config }){
        this.index = new ReverseIndex({
            config,
            deserialize: network_NetworkFilter.deserialize,
            filters: [],
            optimize: config.enableOptimizations ? optimizeNetwork : noopOptimizeNetwork
        });
        this.badFiltersIds = null;
        this.badFilters = new FiltersContainer({
            config,
            deserialize: network_NetworkFilter.deserialize,
            filters: []
        });
        if (0 !== filters.length) this.update(filters, void 0);
    }
    getFilters() {
        const filters = [];
        return filters.concat(this.badFilters.getFilters(), this.index.getFilters());
    }
    update(newFilters, removedFilters) {
        const badFilters = [];
        const remaining = [];
        for (const filter of newFilters)if (filter.isBadFilter()) badFilters.push(filter);
        else remaining.push(filter);
        this.badFilters.update(badFilters, removedFilters);
        this.index.update(remaining, removedFilters);
        this.badFiltersIds = null;
    }
    getSerializedSize() {
        return this.badFilters.getSerializedSize() + this.index.getSerializedSize();
    }
    serialize(buffer) {
        this.index.serialize(buffer);
        this.badFilters.serialize(buffer);
    }
    matchAll(request, isFilterExcluded) {
        const filters = [];
        this.index.iterMatchingFilters(request.getTokens(), (filter)=>{
            if (filter.match(request) && false === this.isFilterDisabled(filter) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) filters.push(filter);
            return true;
        });
        return filters;
    }
    match(request, isFilterExcluded) {
        let match;
        this.index.iterMatchingFilters(request.getTokens(), (filter)=>{
            if (filter.match(request) && false === this.isFilterDisabled(filter) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) {
                match = filter;
                return false;
            }
            return true;
        });
        return match;
    }
    isFilterDisabled(filter) {
        if (null === this.badFiltersIds) {
            const badFilters = this.badFilters.getFilters();
            if (0 === badFilters.length) return false;
            const badFiltersIds = new Set();
            for (const badFilter of badFilters)badFiltersIds.add(badFilter.getIdWithoutBadFilter());
            this.badFiltersIds = badFiltersIds;
        }
        return this.badFiltersIds.has(filter.getId());
    }
}
class HTMLBucket {
    static deserialize(buffer, config) {
        const bucket = new HTMLBucket({
            config
        });
        bucket.networkIndex = ReverseIndex.deserialize(buffer, network_NetworkFilter.deserialize, config.enableOptimizations ? optimizeNetwork : noopOptimizeNetwork, config);
        bucket.exceptionsIndex = ReverseIndex.deserialize(buffer, network_NetworkFilter.deserialize, config.enableOptimizations ? optimizeNetwork : noopOptimizeNetwork, config);
        bucket.cosmeticIndex = ReverseIndex.deserialize(buffer, cosmetic_CosmeticFilter.deserialize, noopOptimizeCosmetic, config);
        bucket.unhideIndex = ReverseIndex.deserialize(buffer, cosmetic_CosmeticFilter.deserialize, noopOptimizeCosmetic, config);
        return bucket;
    }
    constructor({ filters = [], config }){
        this.config = config;
        this.networkIndex = new ReverseIndex({
            config,
            deserialize: network_NetworkFilter.deserialize,
            filters: [],
            optimize: config.enableOptimizations ? optimizeNetwork : noopOptimizeNetwork
        });
        this.exceptionsIndex = new ReverseIndex({
            config,
            deserialize: network_NetworkFilter.deserialize,
            filters: [],
            optimize: config.enableOptimizations ? optimizeNetwork : noopOptimizeNetwork
        });
        this.cosmeticIndex = new ReverseIndex({
            config,
            deserialize: cosmetic_CosmeticFilter.deserialize,
            filters: [],
            optimize: noopOptimizeCosmetic
        });
        this.unhideIndex = new ReverseIndex({
            config,
            deserialize: cosmetic_CosmeticFilter.deserialize,
            filters: [],
            optimize: noopOptimizeCosmetic
        });
        if (0 !== filters.length) this.update(filters, void 0);
    }
    update(newFilters, removedFilters) {
        const networkFilters = [];
        const exceptionFilters = [];
        const cosmeticFilters = [];
        const unhideFilters = [];
        for (const filter of newFilters)if (filter.isNetworkFilter()) {
            if (filter.isException()) exceptionFilters.push(filter);
            else networkFilters.push(filter);
        } else if (filter.isCosmeticFilter()) {
            if (filter.isUnhide()) unhideFilters.push(filter);
            else cosmeticFilters.push(filter);
        }
        this.networkIndex.update(networkFilters, removedFilters);
        this.exceptionsIndex.update(exceptionFilters, removedFilters);
        this.cosmeticIndex.update(cosmeticFilters, removedFilters);
        this.unhideIndex.update(unhideFilters, removedFilters);
    }
    serialize(buffer) {
        this.networkIndex.serialize(buffer);
        this.exceptionsIndex.serialize(buffer);
        this.cosmeticIndex.serialize(buffer);
        this.unhideIndex.serialize(buffer);
    }
    getSerializedSize() {
        return this.networkIndex.getSerializedSize() + this.exceptionsIndex.getSerializedSize() + this.cosmeticIndex.getSerializedSize() + this.unhideIndex.getSerializedSize();
    }
    getHTMLFilters(request, isFilterExcluded) {
        const networkFilters = [];
        const cosmeticFilters = [];
        const exceptions = [];
        const unhides = [];
        if (true === this.config.loadNetworkFilters) this.networkIndex.iterMatchingFilters(request.getTokens(), (filter)=>{
            if (filter.match(request) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) networkFilters.push(filter);
            return true;
        });
        if (0 !== networkFilters.length) this.exceptionsIndex.iterMatchingFilters(request.getTokens(), (filter)=>{
            if (filter.match(request) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) exceptions.push(filter);
            return true;
        });
        if (true === this.config.loadCosmeticFilters && request.isMainFrame()) {
            const { hostname, domain = '' } = request;
            const hostnameTokens = createLookupTokens(hostname, domain);
            this.cosmeticIndex.iterMatchingFilters(hostnameTokens, (filter)=>{
                if (filter.match(hostname, domain) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(filter))) cosmeticFilters.push(filter);
                return true;
            });
            if (0 !== cosmeticFilters.length) this.unhideIndex.iterMatchingFilters(hostnameTokens, (rule)=>{
                if (rule.match(hostname, domain) && !(null == isFilterExcluded ? void 0 : isFilterExcluded(rule))) unhides.push(rule);
                return true;
            });
        }
        return {
            networkFilters,
            cosmeticFilters,
            unhides,
            exceptions
        };
    }
    getFilters() {
        const filters = [];
        return filters.concat(this.networkIndex.getFilters(), this.exceptionsIndex.getFilters(), this.cosmeticIndex.getFilters(), this.unhideIndex.getFilters());
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const map_EMPTY_BUCKET = Number.MAX_SAFE_INTEGER >>> 0;
class CompactMap {
    static deserialize(buffer, deserialize) {
        const tokensLookupIndexSize = buffer.getUint32();
        const bucketsIndexSize = buffer.getUint32();
        const numberOfValues = buffer.getUint32();
        const view = StaticDataView.fromUint8Array(buffer.getBytes(true), {
            enableCompression: false
        });
        const tokensLookupIndex = view.getUint32ArrayView(tokensLookupIndexSize);
        const bucketsIndex = view.getUint32ArrayView(bucketsIndexSize);
        const valuesIndexStart = view.pos;
        view.seekZero();
        return new CompactMap({
            deserialize,
            values: [],
            getKeys: ()=>[],
            getSerializedSize: ()=>0,
            serialize: ()=>{}
        }).updateInternals({
            bucketsIndex,
            valuesIndexStart,
            numberOfValues,
            tokensLookupIndex,
            view
        });
    }
    constructor({ serialize, deserialize, getKeys, getSerializedSize, values }){
        this.cache = new Map();
        this.bucketsIndex = EMPTY_UINT32_ARRAY;
        this.tokensLookupIndex = EMPTY_UINT32_ARRAY;
        this.valuesIndexStart = 0;
        this.numberOfValues = 0;
        this.view = StaticDataView.empty({
            enableCompression: false
        });
        this.deserializeValue = deserialize;
        if (0 !== values.length) {
            const patternsKeys = [];
            let bucketsIndexSize = 0;
            let estimatedBufferSize = 0;
            for (const value of values)estimatedBufferSize += getSerializedSize(value);
            if (0 === values.length) {
                this.updateInternals({
                    bucketsIndex: EMPTY_UINT32_ARRAY,
                    valuesIndexStart: 0,
                    numberOfValues: 0,
                    tokensLookupIndex: EMPTY_UINT32_ARRAY,
                    view: StaticDataView.empty({
                        enableCompression: false
                    })
                });
                return;
            }
            for (const value of values){
                const keys = getKeys(value);
                patternsKeys.push(keys);
                bucketsIndexSize += 2 * keys.length;
            }
            estimatedBufferSize += 4 * bucketsIndexSize;
            const tokensLookupIndexSize = Math.max(2, nextPow2(values.length));
            const mask = tokensLookupIndexSize - 1;
            const suffixes = [];
            for(let i = 0; i < tokensLookupIndexSize; i += 1)suffixes.push([]);
            estimatedBufferSize += 4 * tokensLookupIndexSize;
            const buffer = StaticDataView.allocate(estimatedBufferSize, {
                enableCompression: false
            });
            const tokensLookupIndex = buffer.getUint32ArrayView(tokensLookupIndexSize);
            const bucketsIndex = buffer.getUint32ArrayView(bucketsIndexSize);
            const valuesIndexStart = buffer.getPos();
            for(let i = 0; i < patternsKeys.length; i += 1){
                const value = values[i];
                const keys = patternsKeys[i];
                const valueIndex = buffer.pos;
                serialize(value, buffer);
                for (const key of keys)suffixes[key & mask].push([
                    key,
                    valueIndex
                ]);
            }
            let indexInBucketsIndex = 0;
            for(let i = 0; i < tokensLookupIndexSize; i += 1){
                const valuesForMask = suffixes[i];
                tokensLookupIndex[i] = indexInBucketsIndex;
                for (const [token, valueIndex] of valuesForMask){
                    bucketsIndex[indexInBucketsIndex++] = token;
                    bucketsIndex[indexInBucketsIndex++] = valueIndex;
                }
            }
            this.updateInternals({
                bucketsIndex,
                valuesIndexStart,
                numberOfValues: patternsKeys.length,
                tokensLookupIndex,
                view: buffer
            });
        }
    }
    updateInternals({ bucketsIndex, valuesIndexStart, numberOfValues, tokensLookupIndex, view }) {
        this.bucketsIndex = bucketsIndex;
        this.valuesIndexStart = valuesIndexStart;
        this.numberOfValues = numberOfValues;
        this.tokensLookupIndex = tokensLookupIndex;
        this.view = view;
        view.seekZero();
        return this;
    }
    getValues() {
        const values = [];
        if (0 === this.numberOfValues) return values;
        this.view.setPos(this.valuesIndexStart);
        for(let i = 0; i < this.numberOfValues; i += 1)values.push(this.deserializeValue(this.view));
        this.view.seekZero();
        return values;
    }
    getSerializedSize() {
        return 12 + sizeOfBytes(this.view.buffer, true);
    }
    serialize(buffer) {
        buffer.pushUint32(this.tokensLookupIndex.length);
        buffer.pushUint32(this.bucketsIndex.length);
        buffer.pushUint32(this.numberOfValues);
        buffer.pushBytes(this.view.buffer, true);
    }
    get(key) {
        const cachedValues = this.cache.get(key);
        if (void 0 !== cachedValues) return cachedValues;
        const offset = key & this.tokensLookupIndex.length - 1;
        const startOfBucket = this.tokensLookupIndex[offset];
        if (startOfBucket === map_EMPTY_BUCKET) return [];
        const endOfBucket = offset === this.tokensLookupIndex.length - 1 ? this.bucketsIndex.length : this.tokensLookupIndex[offset + 1];
        const valuesIndices = [];
        for(let i = startOfBucket; i < endOfBucket; i += 2){
            const currentToken = this.bucketsIndex[i];
            if (currentToken === key) valuesIndices.push(this.bucketsIndex[i + 1]);
        }
        if (0 === valuesIndices.length) return [];
        const values = [];
        const view = this.view;
        for(let i = 0; i < valuesIndices.length; i += 1){
            view.setPos(valuesIndices[i]);
            values.push(this.deserializeValue(view));
        }
        this.cache.set(key, values);
        return values;
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function isValid(category) {
    if (null === category) return false;
    if ('object' != typeof category) return false;
    const { key, name, color, description } = category;
    if ('string' != typeof key) return false;
    if ('string' != typeof name) return false;
    if ('string' != typeof color) return false;
    if ('string' != typeof description) return false;
    return true;
}
function getKey(category) {
    return fastHash(category.key);
}
function categories_getSerializedSize(category) {
    return sizeOfUTF8(category.key) + sizeOfUTF8(category.name) + sizeOfUTF8(category.color) + sizeOfUTF8(category.description);
}
function categories_serialize(category, view) {
    view.pushUTF8(category.key);
    view.pushUTF8(category.name);
    view.pushUTF8(category.color);
    view.pushUTF8(category.description);
}
function categories_deserialize(view) {
    return {
        key: view.getUTF8(),
        name: view.getUTF8(),
        color: view.getUTF8(),
        description: view.getUTF8()
    };
}
function createMap(categories) {
    return new CompactMap({
        getSerializedSize: categories_getSerializedSize,
        getKeys: (category)=>[
                getKey(category)
            ],
        serialize: categories_serialize,
        deserialize: categories_deserialize,
        values: categories
    });
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function organizations_isValid(organization) {
    if (null === organization) return false;
    if ('object' != typeof organization) return false;
    const { key, name, description, country, website_url: websiteUrl, privacy_policy_url: privacyPolicyUrl, privacy_contact: privacyContact, ghostery_id: ghosteryId } = organization;
    if ('string' != typeof key) return false;
    if ('string' != typeof name) return false;
    if (null !== description && 'string' != typeof description) return false;
    if (null !== country && 'string' != typeof country) return false;
    if (null !== websiteUrl && 'string' != typeof websiteUrl) return false;
    if (null !== privacyPolicyUrl && 'string' != typeof privacyPolicyUrl) return false;
    if (null !== privacyContact && 'string' != typeof privacyContact) return false;
    if (null !== ghosteryId && 'string' != typeof ghosteryId) return false;
    return true;
}
function organizations_getKey(organization) {
    return fastHash(organization.key);
}
function organizations_getSerializedSize(organization) {
    return sizeOfUTF8(organization.key) + sizeOfUTF8(organization.name) + sizeOfUTF8(organization.description || '') + sizeOfUTF8(organization.website_url || '') + sizeOfUTF8(organization.country || '') + sizeOfUTF8(organization.privacy_policy_url || '') + sizeOfUTF8(organization.privacy_contact || '') + sizeOfUTF8(organization.ghostery_id || '');
}
function organizations_serialize(organization, view) {
    view.pushUTF8(organization.key);
    view.pushUTF8(organization.name);
    view.pushUTF8(organization.description || '');
    view.pushUTF8(organization.website_url || '');
    view.pushUTF8(organization.country || '');
    view.pushUTF8(organization.privacy_policy_url || '');
    view.pushUTF8(organization.privacy_contact || '');
    view.pushUTF8(organization.ghostery_id || '');
}
function organizations_deserialize(view) {
    return {
        key: view.getUTF8(),
        name: view.getUTF8(),
        description: view.getUTF8() || null,
        website_url: view.getUTF8() || null,
        country: view.getUTF8() || null,
        privacy_policy_url: view.getUTF8() || null,
        privacy_contact: view.getUTF8() || null,
        ghostery_id: view.getUTF8() || null
    };
}
function organizations_createMap(organizations) {
    return new CompactMap({
        getSerializedSize: organizations_getSerializedSize,
        getKeys: (organization)=>[
                organizations_getKey(organization)
            ],
        serialize: organizations_serialize,
        deserialize: organizations_deserialize,
        values: organizations
    });
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function patterns_isValid(pattern) {
    if (null === pattern) return false;
    if ('object' != typeof pattern) return false;
    const { key, name, category, organization, alias, website_url: websiteUrl, domains, filters } = pattern;
    if ('string' != typeof key) return false;
    if ('string' != typeof name) return false;
    if ('string' != typeof category) return false;
    if (null !== organization && 'string' != typeof organization) return false;
    if ('string' != typeof alias && null !== alias) return false;
    if (null !== websiteUrl && 'string' != typeof websiteUrl) return false;
    if (!Array.isArray(domains) || !domains.every((domain)=>'string' == typeof domain)) return false;
    if (!Array.isArray(filters) || !filters.every((filter)=>'string' == typeof filter)) return false;
    return true;
}
function patterns_getKeys(pattern) {
    const keys = [];
    for (const filter of pattern.filters){
        const parsedFilter = network_NetworkFilter.parse(filter);
        if (null !== parsedFilter) keys.push(parsedFilter.getId());
    }
    for (const domain of pattern.domains){
        const parsedFilter = network_NetworkFilter.parse(`||${domain}^`);
        if (null !== parsedFilter) keys.push(parsedFilter.getId());
    }
    return [
        ...new Set(keys)
    ];
}
function patterns_getSerializedSize(pattern) {
    let sizeOfDomains = sizeOfLength(pattern.domains.length);
    for (const domain of pattern.domains)sizeOfDomains += sizeOfUTF8(domain);
    let sizeOfFilters = sizeOfLength(pattern.filters.length);
    for (const filter of pattern.filters)sizeOfFilters += sizeOfUTF8(filter);
    return sizeOfUTF8(pattern.key) + sizeOfUTF8(pattern.name) + sizeOfUTF8(pattern.category) + sizeOfUTF8(pattern.organization || '') + sizeOfUTF8(pattern.alias || '') + sizeOfUTF8(pattern.website_url || '') + sizeOfUTF8(pattern.ghostery_id || '') + sizeOfDomains + sizeOfFilters;
}
function patterns_serialize(pattern, view) {
    view.pushUTF8(pattern.key);
    view.pushUTF8(pattern.name);
    view.pushUTF8(pattern.category);
    view.pushUTF8(pattern.organization || '');
    view.pushUTF8(pattern.alias || '');
    view.pushUTF8(pattern.website_url || '');
    view.pushUTF8(pattern.ghostery_id || '');
    view.pushLength(pattern.domains.length);
    for (const domain of pattern.domains)view.pushUTF8(domain);
    view.pushLength(pattern.filters.length);
    for (const filter of pattern.filters)view.pushUTF8(filter);
}
function patterns_deserialize(view) {
    const key = view.getUTF8();
    const name = view.getUTF8();
    const category = view.getUTF8();
    const organization = view.getUTF8() || null;
    const alias = view.getUTF8() || null;
    const website_url = view.getUTF8() || null;
    const ghostery_id = view.getUTF8() || null;
    const numberOfDomains = view.getLength();
    const domains = [];
    for(let i = 0; i < numberOfDomains; i += 1)domains.push(view.getUTF8());
    const numberOfFilters = view.getLength();
    const filters = [];
    for(let i = 0; i < numberOfFilters; i += 1)filters.push(view.getUTF8());
    return {
        key,
        name,
        category,
        organization,
        alias,
        website_url,
        ghostery_id,
        domains,
        filters
    };
}
function patterns_createMap(patterns) {
    return new CompactMap({
        getSerializedSize: patterns_getSerializedSize,
        getKeys: patterns_getKeys,
        serialize: patterns_serialize,
        deserialize: patterns_deserialize,
        values: patterns
    });
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ class Metadata {
    static deserialize(buffer) {
        const metadata = new Metadata(null);
        metadata.categories = CompactMap.deserialize(buffer, categories_deserialize);
        metadata.organizations = CompactMap.deserialize(buffer, organizations_deserialize);
        metadata.patterns = CompactMap.deserialize(buffer, patterns_deserialize);
        return metadata;
    }
    constructor(rawTrackerDB){
        if (!rawTrackerDB) {
            this.organizations = organizations_createMap([]);
            this.categories = createMap([]);
            this.patterns = patterns_createMap([]);
            return;
        }
        const { patterns: rawPatterns, organizations: rawOrganizations, categories: rawCategories } = rawTrackerDB;
        const categories = [];
        if ('object' == typeof rawCategories) for (const [key, category] of Object.entries(rawCategories)){
            if ('object' != typeof category) continue;
            const categoryWithKey = {
                key,
                ...category
            };
            if (isValid(categoryWithKey)) categories.push(categoryWithKey);
            else console.error('?? invalid category', categoryWithKey);
        }
        this.categories = createMap(categories);
        const organizations = [];
        if ('object' == typeof rawOrganizations) for (const [key, organization] of Object.entries(rawOrganizations)){
            if ('object' != typeof organization) continue;
            const organizationWithKey = {
                key,
                ...organization
            };
            if (organizations_isValid(organizationWithKey)) organizations.push(organizationWithKey);
            else console.error('?? invalid organization', organizationWithKey);
        }
        this.organizations = organizations_createMap(organizations);
        const patterns = [];
        if ('object' == typeof rawPatterns) for (const [key, pattern] of Object.entries(rawPatterns)){
            if ('object' != typeof pattern) continue;
            const patternWithKey = {
                key,
                ...pattern
            };
            if (patterns_isValid(patternWithKey)) patterns.push(patternWithKey);
            else console.error('?? invalid pattern', patternWithKey);
        }
        this.patterns = patterns_createMap(patterns);
    }
    getCategories() {
        return this.categories.getValues();
    }
    getOrganizations() {
        return this.organizations.getValues();
    }
    getPatterns() {
        return this.patterns.getValues();
    }
    getSerializedSize() {
        return this.categories.getSerializedSize() + this.organizations.getSerializedSize() + this.patterns.getSerializedSize();
    }
    serialize(buffer) {
        this.categories.serialize(buffer);
        this.organizations.serialize(buffer);
        this.patterns.serialize(buffer);
    }
    fromFilter(filter) {
        return this.fromId(filter.getId());
    }
    fromDomain(domain) {
        const domainParts = domain.split('.');
        for(; domainParts.length >= 2; domainParts.shift()){
            const subdomain = domainParts.join('.');
            const parsedDomainFilter = network_NetworkFilter.parse(`||${subdomain}^`);
            if (null === parsedDomainFilter) continue;
            const patterns = this.fromId(parsedDomainFilter.getId());
            if (patterns.length > 0) return patterns;
        }
        return [];
    }
    fromId(id) {
        var _a, _b;
        const results = [];
        for (const pattern of this.patterns.get(id))results.push({
            pattern,
            category: null === (_a = this.categories.get(getKey({
                key: pattern.category
            }))) || void 0 === _a ? void 0 : _a[0],
            organization: null !== pattern.organization ? null === (_b = this.organizations.get(organizations_getKey({
                key: pattern.organization
            }))) || void 0 === _b ? void 0 : _b[0] : null
        });
        return results;
    }
}
class PreprocessorBucket {
    static deserialize(view) {
        const excluded = new Set();
        for(let i = 0, l = view.getUint32(); i < l; i++)excluded.add(view.getUint32());
        const preprocessors = [];
        for(let i = 0, l = view.getUint32(); i < l; i++)preprocessors.push(Preprocessor.deserialize(view));
        return new this({
            excluded,
            preprocessors
        });
    }
    constructor({ excluded = new Set(), preprocessors = [] }){
        this.excluded = excluded;
        this.preprocessors = preprocessors;
    }
    isFilterExcluded(filter) {
        return this.excluded.has(filter.getId());
    }
    updateEnv(env) {
        this.excluded.clear();
        for (const preprocessor of this.preprocessors)if (!preprocessor.evaluate(env)) for (const filterID of preprocessor.filterIDs)this.excluded.add(filterID);
    }
    update({ added, removed }, env) {
        if (removed) for (const preprocessor of removed){
            const local = this.preprocessors.find((local)=>local.condition === preprocessor.condition);
            if (!!local) for (const filterID of preprocessor.filterIDs)local.filterIDs.delete(filterID);
        }
        if (added) for (const preprocessor of added){
            const local = this.preprocessors.find((local)=>local.condition === preprocessor.condition);
            if (!local) {
                this.preprocessors.push(preprocessor);
                continue;
            }
            for (const filterID of preprocessor.filterIDs)local.filterIDs.add(filterID);
        }
        if (removed && 0 !== removed.length || added && 0 !== added.length) this.updateEnv(env);
    }
    serialize(view) {
        view.pushUint32(this.excluded.size);
        for (const filterID of this.excluded)view.pushUint32(filterID);
        view.pushUint32(this.preprocessors.length);
        for (const preprocessor of this.preprocessors)preprocessor.serialize(view);
    }
    getSerializedSize() {
        let estimatedSize = (1 + this.excluded.size) * 4;
        estimatedSize += 4;
        for (const preprocessor of this.preprocessors)estimatedSize += preprocessor.getSerializedSize();
        return estimatedSize;
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const ENGINE_VERSION = 754;
function shouldApplyHideException(filters) {
    if (0 === filters.length) return false;
    let genericHideFilter;
    let currentScore = 0;
    for (const filter of filters){
        const score = (filter.isImportant() ? 4 : 0) | (filter.isException() ? 1 : 2);
        if (score >= currentScore) {
            currentScore = score;
            genericHideFilter = filter;
        }
    }
    if (void 0 === genericHideFilter) return false;
    return genericHideFilter.isException();
}
class FilterEngine extends EventEmitter {
    static fromCached(init, caching) {
        if (void 0 === caching) return init();
        const { path, read, write } = caching;
        return read(path).then((buffer)=>this.deserialize(buffer)).catch(()=>init().then((engine)=>write(path, engine.serialize()).then(()=>engine)));
    }
    static empty(config = {}) {
        return new this({
            config
        });
    }
    static fromLists(fetch1, urls, config = {}, caching) {
        return this.fromCached(()=>{
            const listsPromises = fetchLists(fetch1, urls);
            const resourcesPromise = fetchResources(fetch1);
            return Promise.all([
                listsPromises,
                resourcesPromise
            ]).then(([lists, resources])=>{
                const engine = this.parse(lists.join('\n'), config);
                if (void 0 !== resources) engine.updateResources(resources, '' + resources.length);
                return engine;
            });
        }, caching);
    }
    static fromPrebuiltAdsOnly(fetchImpl = fetch, caching) {
        return this.fromLists(fetchImpl, adsLists, {}, caching);
    }
    static fromPrebuiltAdsAndTracking(fetchImpl = fetch, caching) {
        return this.fromLists(fetchImpl, adsAndTrackingLists, {}, caching);
    }
    static fromPrebuiltFull(fetchImpl = fetch, caching) {
        return this.fromLists(fetchImpl, fullLists, {}, caching);
    }
    static fromTrackerDB(rawJsonDump, options = {}) {
        const config = new config_Config(options);
        const metadata = new Metadata(rawJsonDump);
        const filters = [];
        for (const pattern of metadata.getPatterns())filters.push(...pattern.filters);
        const engine = this.parse(filters.join('\n'), config);
        engine.metadata = metadata;
        return engine;
    }
    static merge(engines, { skipResources = false, overrideConfig = {} } = {}) {
        if (!engines || engines.length < 2) throw new Error('merging engines requires at least two engines');
        const config = engines[0].config;
        const lists = new Map();
        const networkFilters = new Map();
        const cosmeticFilters = new Map();
        const preprocessors = [];
        const metadata = {
            organizations: {},
            categories: {},
            patterns: {}
        };
        const compatibleConfigKeys = [];
        const configKeysMustMatch = Object.keys(config).filter(function(key) {
            return 'boolean' == typeof config[key] && !compatibleConfigKeys.includes(key) && !Object.hasOwnProperty.call(overrideConfig, key);
        });
        for (const engine of engines){
            for (const configKey of configKeysMustMatch)if (config[configKey] !== engine.config[configKey]) throw new Error(`config "${configKey}" of all merged engines must be the same`);
            const filters = engine.getFilters();
            for (const networkFilter of filters.networkFilters)networkFilters.set(networkFilter.getId(), networkFilter);
            for (const cosmeticFilter of filters.cosmeticFilters)cosmeticFilters.set(cosmeticFilter.getId(), cosmeticFilter);
            for (const preprocessor of engine.preprocessors.preprocessors)preprocessors.push(preprocessor);
            for (const [key, value] of engine.lists)if (!lists.has(key)) lists.set(key, value);
            if (void 0 !== engine.metadata) {
                for (const organization of engine.metadata.organizations.getValues())if (void 0 === metadata.organizations[organization.key]) metadata.organizations[organization.key] = organization;
                for (const category of engine.metadata.categories.getValues())if (void 0 === metadata.categories[category.key]) metadata.categories[category.key] = category;
                for (const pattern of engine.metadata.patterns.getValues())if (void 0 === metadata.patterns[pattern.key]) metadata.patterns[pattern.key] = pattern;
            }
        }
        const engine = new this({
            networkFilters: Array.from(networkFilters.values()),
            cosmeticFilters: Array.from(cosmeticFilters.values()),
            preprocessors,
            lists,
            config: new config_Config({
                ...config,
                ...overrideConfig
            })
        });
        if (Object.keys(metadata.categories).length + Object.keys(metadata.organizations).length + Object.keys(metadata.patterns).length !== 0) engine.metadata = new Metadata(metadata);
        if (true !== skipResources) {
            for (const engine of engines.slice(1))if (engine.resources.checksum !== engines[0].resources.checksum) throw new Error(`resource checksum of all merged engines must match with the first one: "${engines[0].resources.checksum}" but got: "${engine.resources.checksum}"`);
            engine.resources = Resources.copy(engines[0].resources);
        }
        return engine;
    }
    static parse(filters, options = {}) {
        const config = new config_Config(options);
        return new this({
            ...parseFilters(filters, config),
            config
        });
    }
    static deserialize(serialized) {
        const buffer = StaticDataView.fromUint8Array(serialized, {
            enableCompression: false
        });
        const serializedEngineVersion = buffer.getUint16();
        if (ENGINE_VERSION !== serializedEngineVersion) throw new Error(`serialized engine version mismatch, expected ${ENGINE_VERSION} but got ${serializedEngineVersion}`);
        const config = config_Config.deserialize(buffer);
        if (config.enableCompression) buffer.enableCompression();
        if (config.integrityCheck) {
            const currentPos = buffer.pos;
            buffer.pos = serialized.length - 4;
            const checksum = buffer.checksum();
            const expected = buffer.getUint32();
            if (checksum !== expected) throw new Error(`serialized engine checksum mismatch, expected ${expected} but got ${checksum}`);
            buffer.pos = currentPos;
        }
        const engine = new this({
            config
        });
        engine.resources = Resources.deserialize(buffer);
        const lists = new Map();
        const numberOfLists = buffer.getUint16();
        for(let i = 0; i < numberOfLists; i += 1)lists.set(buffer.getASCII(), buffer.getASCII());
        engine.lists = lists;
        engine.preprocessors = PreprocessorBucket.deserialize(buffer);
        engine.importants = NetworkFilterBucket.deserialize(buffer, config);
        engine.redirects = NetworkFilterBucket.deserialize(buffer, config);
        engine.filters = NetworkFilterBucket.deserialize(buffer, config);
        engine.exceptions = NetworkFilterBucket.deserialize(buffer, config);
        engine.csp = NetworkFilterBucket.deserialize(buffer, config);
        engine.cosmetics = CosmeticFilterBucket.deserialize(buffer, config);
        engine.hideExceptions = NetworkFilterBucket.deserialize(buffer, config);
        engine.htmlFilters = HTMLBucket.deserialize(buffer, config);
        const hasMetadata = buffer.getBool();
        if (hasMetadata) engine.metadata = Metadata.deserialize(buffer);
        buffer.seekZero();
        return engine;
    }
    constructor({ cosmeticFilters = [], networkFilters = [], preprocessors = [], config = new config_Config(), lists = new Map() } = {}){
        super();
        this.config = new config_Config(config);
        this.lists = lists;
        this.preprocessors = new PreprocessorBucket({});
        this.csp = new NetworkFilterBucket({
            config: this.config
        });
        this.hideExceptions = new NetworkFilterBucket({
            config: this.config
        });
        this.exceptions = new NetworkFilterBucket({
            config: this.config
        });
        this.importants = new NetworkFilterBucket({
            config: this.config
        });
        this.redirects = new NetworkFilterBucket({
            config: this.config
        });
        this.filters = new NetworkFilterBucket({
            config: this.config
        });
        this.cosmetics = new CosmeticFilterBucket({
            config: this.config
        });
        this.htmlFilters = new HTMLBucket({
            config: this.config
        });
        this.resources = new Resources();
        if (0 !== networkFilters.length || 0 !== cosmeticFilters.length) this.update({
            newCosmeticFilters: cosmeticFilters,
            newNetworkFilters: networkFilters,
            newPreprocessors: preprocessors
        });
    }
    isFilterExcluded(filter) {
        return this.preprocessors.isFilterExcluded(filter);
    }
    updateEnv(env) {
        this.preprocessors.updateEnv(env);
    }
    getSerializedSize() {
        let estimatedSize = sizeOfByte() + this.config.getSerializedSize() + this.resources.getSerializedSize() + this.preprocessors.getSerializedSize() + this.filters.getSerializedSize() + this.exceptions.getSerializedSize() + this.importants.getSerializedSize() + this.redirects.getSerializedSize() + this.csp.getSerializedSize() + this.cosmetics.getSerializedSize() + this.hideExceptions.getSerializedSize() + this.htmlFilters.getSerializedSize() + 4;
        for (const [name, checksum] of this.lists)estimatedSize += sizeOfASCII(name) + sizeOfASCII(checksum);
        estimatedSize += sizeOfBool();
        if (void 0 !== this.metadata) estimatedSize += this.metadata.getSerializedSize();
        return estimatedSize;
    }
    serialize(array) {
        const buffer = StaticDataView.fromUint8Array(array || new Uint8Array(this.getSerializedSize()), this.config);
        buffer.pushUint16(ENGINE_VERSION);
        this.config.serialize(buffer);
        this.resources.serialize(buffer);
        buffer.pushUint16(this.lists.size);
        for (const [name, value] of Array.from(this.lists.entries()).sort()){
            buffer.pushASCII(name);
            buffer.pushASCII(value);
        }
        this.preprocessors.serialize(buffer);
        this.importants.serialize(buffer);
        this.redirects.serialize(buffer);
        this.filters.serialize(buffer);
        this.exceptions.serialize(buffer);
        this.csp.serialize(buffer);
        this.cosmetics.serialize(buffer);
        this.hideExceptions.serialize(buffer);
        this.htmlFilters.serialize(buffer);
        buffer.pushBool(void 0 !== this.metadata);
        if (void 0 !== this.metadata) this.metadata.serialize(buffer);
        if (this.config.integrityCheck) buffer.pushUint32(buffer.checksum());
        return buffer.subarray();
    }
    loadedLists() {
        return Array.from(this.lists.keys());
    }
    hasList(name, checksum) {
        return this.lists.has(name) && this.lists.get(name) === checksum;
    }
    updateResources(data, checksum) {
        if (this.resources.checksum === checksum) return false;
        this.resources = Resources.parse(data, {
            checksum
        });
        return true;
    }
    getFilters() {
        const cosmeticFilters = this.cosmetics.getFilters();
        const networkFilters = [
            ...this.filters.getFilters(),
            ...this.exceptions.getFilters(),
            ...this.importants.getFilters(),
            ...this.redirects.getFilters(),
            ...this.csp.getFilters(),
            ...this.hideExceptions.getFilters()
        ];
        for (const filter of this.htmlFilters.getFilters())if (filter.isNetworkFilter()) networkFilters.push(filter);
        else if (filter.isCosmeticFilter()) cosmeticFilters.push(filter);
        return {
            cosmeticFilters,
            networkFilters
        };
    }
    update({ newNetworkFilters = [], newCosmeticFilters = [], newPreprocessors = [], removedCosmeticFilters = [], removedNetworkFilters = [], removedPreprocessors = [] }, env = new Env()) {
        let updated = false;
        if (this.config.loadPreprocessors && (0 !== newPreprocessors.length || 0 !== removedPreprocessors.length)) {
            updated = true;
            this.preprocessors.update({
                added: newPreprocessors,
                removed: removedPreprocessors
            }, env);
        }
        const htmlFilters = [];
        if (this.config.loadCosmeticFilters && (0 !== newCosmeticFilters.length || 0 !== removedCosmeticFilters.length)) {
            updated = true;
            const cosmeticFitlers = [];
            for (const filter of newCosmeticFilters)if (filter.isHtmlFiltering()) htmlFilters.push(filter);
            else cosmeticFitlers.push(filter);
            this.cosmetics.update(cosmeticFitlers, 0 === removedCosmeticFilters.length ? void 0 : new Set(removedCosmeticFilters), this.config);
        }
        if (this.config.loadNetworkFilters && (0 !== newNetworkFilters.length || 0 !== removedNetworkFilters.length)) {
            updated = true;
            const filters = [];
            const csp = [];
            const exceptions = [];
            const importants = [];
            const redirects = [];
            const hideExceptions = [];
            for (const filter of newNetworkFilters)if (filter.isCSP()) csp.push(filter);
            else if (filter.isHtmlFilteringRule()) htmlFilters.push(filter);
            else if (filter.isGenericHide() || filter.isSpecificHide()) hideExceptions.push(filter);
            else if (filter.isException()) exceptions.push(filter);
            else if (filter.isImportant()) importants.push(filter);
            else if (filter.isRedirect()) redirects.push(filter);
            else filters.push(filter);
            const removedNetworkFiltersSet = 0 === removedNetworkFilters.length ? void 0 : new Set(removedNetworkFilters);
            this.importants.update(importants, removedNetworkFiltersSet);
            this.redirects.update(redirects, removedNetworkFiltersSet);
            this.filters.update(filters, removedNetworkFiltersSet);
            if (true === this.config.loadExceptionFilters) this.exceptions.update(exceptions, removedNetworkFiltersSet);
            if (true === this.config.loadCSPFilters) this.csp.update(csp, removedNetworkFiltersSet);
            this.hideExceptions.update(hideExceptions, removedNetworkFiltersSet);
        }
        if (this.config.enableHtmlFiltering && (0 !== htmlFilters.length || 0 !== removedNetworkFilters.length || 0 !== removedCosmeticFilters.length)) {
            const removeFilters = new Set([
                ...removedNetworkFilters,
                ...removedCosmeticFilters
            ]);
            this.htmlFilters.update(htmlFilters, removeFilters);
        }
        return updated;
    }
    updateFromDiff({ added, removed, preprocessors }, env) {
        const newCosmeticFilters = [];
        const newNetworkFilters = [];
        const newPreprocessors = [];
        const removedCosmeticFilters = [];
        const removedNetworkFilters = [];
        const removedPreprocessors = [];
        if (void 0 !== removed && 0 !== removed.length) {
            const { networkFilters, cosmeticFilters } = parseFilters(removed.join('\n'), this.config);
            Array.prototype.push.apply(removedCosmeticFilters, cosmeticFilters);
            Array.prototype.push.apply(removedNetworkFilters, networkFilters);
        }
        if (void 0 !== added && 0 !== added.length) {
            const { networkFilters, cosmeticFilters } = parseFilters(added.join('\n'), this.config);
            Array.prototype.push.apply(newCosmeticFilters, cosmeticFilters);
            Array.prototype.push.apply(newNetworkFilters, networkFilters);
        }
        if (void 0 !== preprocessors) for (const [condition, details] of Object.entries(preprocessors)){
            if (void 0 !== details.removed && 0 !== details.removed.length) {
                const { networkFilters, cosmeticFilters } = parseFilters(details.removed.join('\n'), this.config);
                const filterIDs = new Set([].concat(cosmeticFilters.map((filter)=>filter.getId())).concat(networkFilters.map((filter)=>filter.getId())));
                removedPreprocessors.push(new Preprocessor({
                    condition,
                    filterIDs
                }));
            }
            if (void 0 !== details.added && 0 !== details.added.length) {
                const { networkFilters, cosmeticFilters } = parseFilters(details.added.join('\n'), this.config);
                const filterIDs = new Set([].concat(cosmeticFilters.map((filter)=>filter.getId())).concat(networkFilters.map((filter)=>filter.getId())));
                newPreprocessors.push(new Preprocessor({
                    condition,
                    filterIDs
                }));
            }
        }
        return this.update({
            newCosmeticFilters,
            newNetworkFilters,
            newPreprocessors,
            removedCosmeticFilters: removedCosmeticFilters.map((f)=>f.getId()),
            removedNetworkFilters: removedNetworkFilters.map((f)=>f.getId()),
            removedPreprocessors
        }, env);
    }
    getHtmlFilters(request) {
        const htmlSelectors = [];
        if (false === this.config.enableHtmlFiltering) return htmlSelectors;
        const { networkFilters, exceptions, cosmeticFilters, unhides } = this.htmlFilters.getHTMLFilters(request, this.isFilterExcluded.bind(this));
        if (0 !== cosmeticFilters.length) {
            const unhideMap = new Map(unhides.map((unhide)=>[
                    unhide.getSelector(),
                    unhide
                ]));
            for (const filter of cosmeticFilters){
                const extended = filter.getExtendedSelector();
                if (void 0 === extended) continue;
                const unhide = unhideMap.get(filter.getSelector());
                if (void 0 === unhide) htmlSelectors.push(extended);
                this.emit('filter-matched', {
                    filter,
                    exception: unhide
                }, {
                    request,
                    filterType: lists_FilterType.COSMETIC
                });
            }
        }
        if (0 !== networkFilters.length) {
            const exceptionsMap = new Map();
            let replaceDisabledException;
            for (const exception of exceptions){
                const optionValue = exception.optionValue;
                if ('' === optionValue) {
                    replaceDisabledException = exception;
                    break;
                }
                exceptionsMap.set(optionValue, exception);
            }
            for (const filter of networkFilters){
                const modifier = filter.getHtmlModifier();
                if (null === modifier) continue;
                const exception = replaceDisabledException || exceptionsMap.get(filter.optionValue);
                this.emit('filter-matched', {
                    filter,
                    exception
                }, {
                    request,
                    filterType: lists_FilterType.NETWORK
                });
                if (void 0 === exception) htmlSelectors.push([
                    'replace',
                    modifier
                ]);
            }
        }
        if (0 !== htmlSelectors.length) this.emit('html-filtered', htmlSelectors, request.url);
        return htmlSelectors;
    }
    getCosmeticsFilters({ url, hostname, domain, classes, hrefs, ids, getBaseRules = true, getInjectionRules = true, getExtendedRules = true, getRulesFromDOM = true, getRulesFromHostname = true, injectPureHasSafely = false, hidingStyle, callerContext }) {
        if (false === this.config.loadCosmeticFilters) return {
            active: false,
            extended: [],
            scripts: [],
            styles: ''
        };
        const { matches, allowGenericHides } = this.matchCosmeticFilters({
            url,
            hostname,
            domain,
            classes,
            hrefs,
            ids,
            getRulesFromDOM,
            getRulesFromHostname,
            getInjectionRules,
            getExtendedRules,
            getPureHasRules: injectPureHasSafely,
            callerContext
        });
        const filters = [];
        for (const { filter, exception } of matches)if (void 0 === exception) filters.push(filter);
        const { extended, scripts, styles } = this.injectCosmeticFilters(filters, {
            url,
            injectScriptlets: getInjectionRules,
            injectExtended: getExtendedRules,
            injectPureHasSafely,
            allowGenericHides,
            getBaseRules,
            hidingStyle
        });
        return {
            active: true,
            extended,
            scripts,
            styles
        };
    }
    injectCosmeticFilters(filters, { url, injectStyles = true, injectScriptlets, injectExtended, injectPureHasSafely, allowGenericHides = true, getBaseRules, hidingStyle }) {
        const scripts = [];
        const styleFilters = [];
        const extendedFilters = [];
        const pureHasFilters = [];
        for (const filter of filters)if (injectScriptlets && filter.isScriptInject()) {
            const script = filter.getScript(this.resources.getScriptlet.bind(this.resources));
            if (void 0 !== script) scripts.push(script);
        } else if (filter.isExtended()) {
            if (true === injectExtended && this.config.loadExtendedSelectors) extendedFilters.push(filter);
            if (injectPureHasSafely && filter.isPureHasSelector()) pureHasFilters.push(filter);
        } else if (true === injectStyles) styleFilters.push(filter);
        const stylesheets = this.cosmetics.getStylesheetsFromFilters({
            filters: styleFilters,
            extendedFilters
        }, {
            getBaseRules,
            allowGenericHides,
            hidingStyle
        });
        let styles = stylesheets.stylesheet;
        for (const filter of pureHasFilters)styles += `\n\n${createStylesheet([
            filter.getSelector()
        ], filter.hasCustomStyle() ? filter.getStyle() : hidingStyle)}`;
        for (const script of scripts)this.emit("script-injected", script, url);
        if (0 !== styles.length) this.emit('style-injected', styles, url);
        return {
            extended: stylesheets.extended,
            scripts,
            styles
        };
    }
    matchCosmeticFilters({ url, hostname, domain, classes, hrefs, ids, getRulesFromDOM = true, getRulesFromHostname = true, getInjectionRules, getExtendedRules, getPureHasRules, callerContext }) {
        domain || (domain = '');
        let allowGenericHides = true;
        let allowSpecificHides = true;
        const exceptions = this.hideExceptions.matchAll(Request.fromRawDetails({
            domain,
            hostname,
            url,
            sourceDomain: '',
            sourceHostname: '',
            sourceUrl: ''
        }), this.isFilterExcluded.bind(this));
        const genericHides = [];
        const specificHides = [];
        for (const filter of exceptions){
            if (filter.isElemHide()) {
                allowGenericHides = false;
                allowSpecificHides = false;
                break;
            }
            if (filter.isSpecificHide()) specificHides.push(filter);
            else if (filter.isGenericHide()) genericHides.push(filter);
        }
        if (true === allowGenericHides) allowGenericHides = false === shouldApplyHideException(genericHides);
        if (true === allowSpecificHides) allowSpecificHides = false === shouldApplyHideException(specificHides);
        const { filters, unhides } = this.cosmetics.getCosmeticsFilters({
            domain,
            hostname,
            classes,
            hrefs,
            ids,
            allowGenericHides,
            allowSpecificHides,
            getRulesFromDOM,
            getRulesFromHostname,
            isFilterExcluded: this.isFilterExcluded.bind(this)
        });
        let injectionsDisabledFilter;
        const unhideExceptions = new Map();
        for (const unhide of unhides)if (true === unhide.isScriptInject() && true === unhide.isUnhide() && 0 === unhide.getSelector().length) injectionsDisabledFilter = unhide;
        else unhideExceptions.set(normalizeSelector(unhide, this.resources.getScriptletCanonicalName.bind(this.resources)), unhide);
        const matches = [];
        for (const filter of filters){
            let exception = unhideExceptions.get(normalizeSelector(filter, this.resources.getScriptletCanonicalName.bind(this.resources)));
            if (filter.isScriptInject()) {
                if (void 0 !== injectionsDisabledFilter) exception = injectionsDisabledFilter;
                if (false === getInjectionRules) continue;
            }
            if (!filter.isExtended() || false !== getExtendedRules && false !== this.config.loadExtendedSelectors || !!(getPureHasRules && filter.isPureHasSelector())) {
                matches.push({
                    filter,
                    exception
                });
                this.emit('filter-matched', {
                    filter,
                    exception
                }, {
                    url,
                    callerContext,
                    filterType: lists_FilterType.COSMETIC
                });
            }
        }
        return {
            matches,
            allowGenericHides
        };
    }
    matchAll(request) {
        const filters = [];
        if (request.isSupported) {
            Array.prototype.push.apply(filters, this.importants.matchAll(request, this.isFilterExcluded.bind(this)));
            Array.prototype.push.apply(filters, this.filters.matchAll(request, this.isFilterExcluded.bind(this)));
            Array.prototype.push.apply(filters, this.exceptions.matchAll(request, this.isFilterExcluded.bind(this)));
            Array.prototype.push.apply(filters, this.csp.matchAll(request, this.isFilterExcluded.bind(this)));
            Array.prototype.push.apply(filters, this.hideExceptions.matchAll(request, this.isFilterExcluded.bind(this)));
            Array.prototype.push.apply(filters, this.redirects.matchAll(request, this.isFilterExcluded.bind(this)));
        }
        return new Set(filters);
    }
    getCSPDirectives(request) {
        if (!this.config.loadNetworkFilters) return;
        if (true !== request.isSupported || false === request.isMainFrame()) return;
        const matches = this.csp.matchAll(request, this.isFilterExcluded.bind(this));
        if (0 === matches.length) return;
        const cspExceptions = new Map();
        const cspFilters = [];
        for (const filter of matches)if (filter.isException()) {
            if (void 0 === filter.csp) {
                this.emit('filter-matched', {
                    exception: filter
                }, {
                    request,
                    filterType: lists_FilterType.NETWORK
                });
                return;
            }
            cspExceptions.set(filter.csp, filter);
        } else cspFilters.push(filter);
        if (0 === cspFilters.length) return;
        const enabledCsp = new Set();
        for (const filter of cspFilters.values()){
            const exception = cspExceptions.get(filter.csp);
            if (void 0 === exception) enabledCsp.add(filter.csp);
            this.emit('filter-matched', {
                filter,
                exception
            }, {
                request,
                filterType: lists_FilterType.NETWORK
            });
        }
        const csps = Array.from(enabledCsp).join('; ');
        if (csps.length > 0) this.emit('csp-injected', request, csps);
        return csps;
    }
    match(request, withMetadata = false) {
        const result = {
            exception: void 0,
            filter: void 0,
            match: false,
            redirect: void 0,
            metadata: void 0
        };
        if (!this.config.loadNetworkFilters) return result;
        if (request.isSupported) {
            result.filter = this.importants.match(request, this.isFilterExcluded.bind(this));
            let redirectNone;
            let redirectRule;
            if (void 0 === result.filter) {
                const redirects = this.redirects.matchAll(request, this.isFilterExcluded.bind(this)).sort((a, b)=>b.getRedirectPriority() - a.getRedirectPriority());
                if (0 !== redirects.length) {
                    for (const filter of redirects)if ('none' === filter.getRedirectResource()) redirectNone = filter;
                    else if (filter.isRedirectRule()) {
                        if (void 0 === redirectRule) redirectRule = filter;
                    } else if (void 0 === result.filter) result.filter = filter;
                }
                if (void 0 === result.filter) {
                    result.filter = this.filters.match(request, this.isFilterExcluded.bind(this));
                    if (void 0 !== redirectRule && void 0 !== result.filter) result.filter = redirectRule;
                }
                if (void 0 !== result.filter) result.exception = this.exceptions.match(request, this.isFilterExcluded.bind(this));
            }
            if (void 0 !== result.filter && void 0 === result.exception && result.filter.isRedirect()) {
                if (void 0 !== redirectNone) result.exception = redirectNone;
                else result.redirect = this.resources.getResource(result.filter.getRedirectResource());
            }
        }
        result.match = void 0 === result.exception && void 0 !== result.filter;
        if (result.filter) this.emit('filter-matched', {
            filter: result.filter,
            exception: result.exception
        }, {
            request,
            filterType: lists_FilterType.NETWORK
        });
        if (void 0 !== result.exception) this.emit('request-whitelisted', request, result);
        else if (void 0 !== result.redirect) this.emit('request-redirected', request, result);
        else if (void 0 !== result.filter) this.emit('request-blocked', request, result);
        else this.emit('request-allowed', request, result);
        if (true === withMetadata && void 0 !== result.filter && this.metadata) result.metadata = this.metadata.fromFilter(result.filter);
        return result;
    }
    getPatternMetadata(request, { getDomainMetadata = false } = {}) {
        if (void 0 === this.metadata) return [];
        const seenPatterns = new Set();
        const patterns = [];
        for (const filter of this.matchAll(request))for (const patternInfo of this.metadata.fromFilter(filter))if (!seenPatterns.has(patternInfo.pattern.key)) {
            seenPatterns.add(patternInfo.pattern.key);
            patterns.push(patternInfo);
        }
        if (getDomainMetadata) {
            for (const patternInfo of this.metadata.fromDomain(request.hostname))if (!seenPatterns.has(patternInfo.pattern.key)) {
                seenPatterns.add(patternInfo.pattern.key);
                patterns.push(patternInfo);
            }
        }
        return patterns;
    }
    blockScripts() {
        this.updateFromDiff({
            added: [
                block().scripts().redirectTo("javascript").toString()
            ]
        });
        return this;
    }
    blockImages() {
        this.updateFromDiff({
            added: [
                block().images().redirectTo('png').toString()
            ]
        });
        return this;
    }
    blockMedias() {
        this.updateFromDiff({
            added: [
                block().medias().redirectTo('mp4').toString()
            ]
        });
        return this;
    }
    blockFrames() {
        this.updateFromDiff({
            added: [
                block().frames().redirectTo('html').toString()
            ]
        });
        return this;
    }
    blockFonts() {
        this.updateFromDiff({
            added: [
                block().fonts().toString()
            ]
        });
        return this;
    }
    blockStyles() {
        this.updateFromDiff({
            added: [
                block().styles().toString()
            ]
        });
        return this;
    }
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ /*!
 * Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */ new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    8,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0xa,
    0x3,
    0x3,
    0x3,
    0x3,
    0x3,
    0x3,
    0x3,
    0x3,
    0x3,
    0x3,
    0x3,
    0x3,
    0x4,
    0x3,
    0x3,
    0xb,
    0x6,
    0x6,
    0x6,
    0x5,
    0x8,
    0x8,
    0x8,
    0x8,
    0x8,
    0x8,
    0x8,
    0x8,
    0x8,
    0x8,
    0x8,
    0x0,
    0x1,
    0x2,
    0x3,
    0x5,
    0x8,
    0x7,
    0x1,
    0x1,
    0x1,
    0x4,
    0x6,
    0x1,
    0x1,
    0x1,
    0x1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    3,
    1,
    3,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    3,
    1,
    1,
    1,
    1,
    1,
    3,
    1,
    3,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    3,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
]);
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ const SCRIPT_ID = "cliqz-adblocker-script";
const IGNORED_TAGS = new Set([
    'br',
    'head',
    'link',
    'meta',
    "script",
    'style',
    's'
]);
function debounce(fn, { waitFor, maxWait }) {
    let delayedTimer;
    let maxWaitTimer;
    const clear = ()=>{
        clearTimeout(delayedTimer);
        clearTimeout(maxWaitTimer);
        delayedTimer = void 0;
        maxWaitTimer = void 0;
    };
    const run = ()=>{
        clear();
        fn();
    };
    return [
        ()=>{
            if (maxWait > 0 && void 0 === maxWaitTimer) maxWaitTimer = setTimeout(run, maxWait);
            clearTimeout(delayedTimer);
            delayedTimer = setTimeout(run, waitFor);
        },
        clear
    ];
}
function isElement(node) {
    return 1 === node.nodeType;
}
function getElementsFromMutations(mutations) {
    const elements = [];
    for (const mutation of mutations)if ('attributes' === mutation.type) {
        if (isElement(mutation.target)) elements.push(mutation.target);
    } else if ('childList' === mutation.type) {
        for (const addedNode of mutation.addedNodes)if (isElement(addedNode) && addedNode.id !== SCRIPT_ID) elements.push(addedNode);
    }
    return elements;
}
function extractFeaturesFromDOM(roots) {
    const ignoredTags = new Set([
        'br',
        'head',
        'link',
        'meta',
        "script",
        'style',
        's'
    ]);
    const classes = new Set();
    const hrefs = new Set();
    const ids = new Set();
    const seenElements = new Set();
    for (const root of roots)for (const element of [
        root,
        ...root.querySelectorAll('[id]:not(html):not(body),[class]:not(html):not(body),[href]:not(html):not(body)')
    ]){
        if (seenElements.has(element)) continue;
        seenElements.add(element);
        if (ignoredTags.has(element.nodeName.toLowerCase())) continue;
        const id = element.getAttribute('id');
        if ('string' == typeof id) ids.add(id);
        const classList = element.classList;
        for (const classEntry of classList)classes.add(classEntry);
        const href = element.getAttribute('href');
        if ('string' == typeof href) hrefs.add(href);
    }
    return {
        classes: Array.from(classes),
        hrefs: Array.from(hrefs),
        ids: Array.from(ids)
    };
}
class DOMMonitor {
    constructor(cb){
        this.cb = cb;
        this.knownIds = new Set();
        this.knownHrefs = new Set();
        this.knownClasses = new Set();
        this.observer = null;
    }
    queryAll(window1) {
        this.cb({
            type: 'elements',
            elements: [
                window1.document.documentElement
            ]
        });
        this.handleUpdatedNodes([
            window1.document.documentElement
        ]);
    }
    start(window1) {
        if (null === this.observer && void 0 !== window1.MutationObserver) {
            const nodes = new Set();
            const handleUpdatedNodesCallback = ()=>{
                this.handleUpdatedNodes(Array.from(nodes));
                nodes.clear();
            };
            const [debouncedHandleUpdatedNodes, cancelHandleUpdatedNodes] = debounce(handleUpdatedNodesCallback, {
                waitFor: 25,
                maxWait: 1000
            });
            this.observer = new window1.MutationObserver((mutations)=>{
                getElementsFromMutations(mutations).forEach(nodes.add, nodes);
                if (nodes.size > 512) {
                    cancelHandleUpdatedNodes();
                    handleUpdatedNodesCallback();
                } else debouncedHandleUpdatedNodes();
            });
            this.observer.observe(window1.document.documentElement, {
                attributes: true,
                attributeFilter: [
                    'class',
                    'id',
                    'href'
                ],
                childList: true,
                subtree: true
            });
        }
    }
    stop() {
        if (null !== this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }
    }
    handleNewFeatures({ hrefs, ids, classes }) {
        const newIds = [];
        const newClasses = [];
        const newHrefs = [];
        for (const id of ids)if (false === this.knownIds.has(id)) {
            newIds.push(id);
            this.knownIds.add(id);
        }
        for (const cls of classes)if (false === this.knownClasses.has(cls)) {
            newClasses.push(cls);
            this.knownClasses.add(cls);
        }
        for (const href of hrefs)if (false === this.knownHrefs.has(href)) {
            newHrefs.push(href);
            this.knownHrefs.add(href);
        }
        if (0 !== newIds.length || 0 !== newClasses.length || 0 !== newHrefs.length) {
            this.cb({
                type: 'features',
                classes: newClasses,
                hrefs: newHrefs,
                ids: newIds
            });
            return true;
        }
        return false;
    }
    handleUpdatedNodes(elements) {
        if (0 !== elements.length) {
            this.cb({
                type: 'elements',
                elements: elements.filter((e)=>false === IGNORED_TAGS.has(e.nodeName.toLowerCase()))
            });
            return this.handleNewFeatures(extractFeaturesFromDOM(elements));
        }
        return false;
    }
}
function autoRemoveScript(script) {
    return `try{${script}}catch(c){}!function(){var c=document.currentScript,e=c&&c.parentNode;e&&e.removeChild(c)}();`;
}
/*!
 * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */ function esm_sleep(milliseconds) {
    return new Promise((resolve)=>{
        setTimeout(resolve, milliseconds);
    });
}
function getTopLevelUrl(frame) {
    let sourceUrl = '';
    while(null !== frame){
        sourceUrl = frame.url();
        if (0 !== sourceUrl.length) break;
        frame = frame.parentFrame();
    }
    return sourceUrl;
}
function fromPuppeteerDetails(details) {
    const sourceUrl = getTopLevelUrl(details.frame());
    const url = details.url();
    const type = details.resourceType();
    return Request.fromRawDetails({
        _originalRequestDetails: details,
        requestId: `${type}-${url}-${sourceUrl}`,
        sourceUrl,
        type,
        url
    });
}
class BlockingContext {
    constructor(page, blocker){
        this.page = page;
        this.blocker = blocker;
        this.onFrameNavigated = (frame)=>blocker.onFrameNavigated(frame);
        this.onDomContentLoaded = ()=>blocker.onFrameNavigated(this.page.mainFrame());
        this.onRequest = (request)=>blocker.onRequest(request);
    }
    async enable() {
        if (this.blocker.config.loadCosmeticFilters) {
            this.page.on('frameattached', this.onFrameNavigated);
            this.page.on('domcontentloaded', this.onDomContentLoaded);
        }
        if (this.blocker.config.loadNetworkFilters) {
            await this.page.setRequestInterception(true);
            this.page.on('request', this.onRequest);
        }
    }
    async disable() {
        if (this.blocker.config.loadNetworkFilters) {
            this.page.off('request', this.onRequest);
            await this.page.setRequestInterception(false);
        }
        if (this.blocker.config.loadCosmeticFilters) {
            this.page.off('frameattached', this.onFrameNavigated);
            this.page.off('domcontentloaded', this.onDomContentLoaded);
        }
    }
}
class PuppeteerBlocker extends FilterEngine {
    constructor(){
        super(...arguments);
        this.contexts = new WeakMap();
        this.priority = void 0;
        this.onFrameNavigated = async (frame)=>{
            try {
                await this.onFrame(frame);
            } catch (ex) {}
        };
        this.onFrame = async (frame)=>{
            const url = frame.url();
            if ('chrome-error://chromewebdata/' === url) return;
            this.removeBlockedFrames(frame).catch(()=>{});
            const parsed = parse(url);
            const hostname = parsed.hostname || '';
            const domain = parsed.domain || '';
            {
                const { active, styles, scripts } = this.getCosmeticsFilters({
                    domain,
                    hostname,
                    url,
                    getBaseRules: true,
                    getInjectionRules: true,
                    getExtendedRules: true,
                    getRulesFromHostname: true,
                    getRulesFromDOM: false
                });
                if (false === active) return;
                Promise.all([
                    this.injectScriptletsIntoFrame(frame, scripts),
                    this.injectStylesIntoFrame(frame, styles)
                ]).catch(()=>{});
            }
            const observer = new DOMMonitor((update)=>{
                if ('features' === update.type) {
                    const { active, styles } = this.getCosmeticsFilters({
                        domain,
                        hostname,
                        url,
                        ...update,
                        getBaseRules: false,
                        getInjectionRules: false,
                        getExtendedRules: false,
                        getRulesFromHostname: false,
                        getRulesFromDOM: true
                    });
                    if (false === active) return;
                    this.injectStylesIntoFrame(frame, styles).catch(()=>{});
                }
            });
            let numberOfIterations = 0;
            do {
                if (frame.detached) break;
                try {
                    const foundNewFeatures = observer.handleNewFeatures(await frame.$$eval(':root', extractFeaturesFromDOM));
                    numberOfIterations += 1;
                    if (10 === numberOfIterations) break;
                    if (false === foundNewFeatures) break;
                } catch (ex) {
                    break;
                }
                if (false === this.config.enableMutationObserver) break;
                await esm_sleep(500);
            }while (true);
        };
        this.setRequestInterceptionPriority = (defaultPriority = 0)=>this.priority = defaultPriority;
        this.onRequest = (details)=>{
            var _a, _b, _c;
            if (null === (_a = details.isInterceptResolutionHandled) || void 0 === _a ? void 0 : _a.call(details)) return;
            const request = fromPuppeteerDetails(details);
            if (true === this.config.guessRequestTypeFromUrl && 'other' === request.type) request.guessTypeOfRequest();
            const frame = details.frame();
            if (request.isMainFrame() || 'document' === request.type && null !== frame && null === frame.parentFrame()) {
                details.continue(null === (_b = details.continueRequestOverrides) || void 0 === _b ? void 0 : _b.call(details), 0);
                return;
            }
            const { redirect, match } = this.match(request);
            if (void 0 !== redirect) {
                if (redirect.contentType.endsWith(';base64')) details.respond({
                    status: 200,
                    headers: {},
                    body: Buffer.from(redirect.body, 'base64'),
                    contentType: redirect.contentType.slice(0, -7)
                }, this.priority);
                else details.respond({
                    status: 200,
                    headers: {},
                    body: redirect.body,
                    contentType: redirect.contentType
                }, this.priority);
            } else if (true === match) details.abort('blockedbyclient', this.priority);
            else details.continue(null === (_c = details.continueRequestOverrides) || void 0 === _c ? void 0 : _c.call(details), 0);
        };
    }
    async enableBlockingInPage(page) {
        let context = this.contexts.get(page);
        if (void 0 !== context) return context;
        context = new BlockingContext(page, this);
        this.contexts.set(page, context);
        await context.enable();
        return context;
    }
    async disableBlockingInPage(page) {
        const context = this.contexts.get(page);
        if (void 0 === context) throw new Error('Trying to disable blocking which was not enabled');
        this.contexts.delete(page);
        await context.disable();
    }
    isBlockingEnabled(page) {
        return this.contexts.has(page);
    }
    async injectStylesIntoFrame(frame, styles) {
        if (0 !== styles.length) await frame.addStyleTag({
            content: styles
        });
    }
    async injectScriptletsIntoFrame(frame, scripts) {
        const promises = [];
        if (0 !== scripts.length) for(let i = 0; i < scripts.length; i += 1)promises.push(frame.addScriptTag({
            content: autoRemoveScript(scripts[i])
        }).then(()=>{}));
        await Promise.all(promises);
    }
    async removeBlockedFrames(frame) {
        const promises = [];
        const sourceUrl = getTopLevelUrl(frame);
        for (const url of (await frame.$$eval('iframe[src],iframe[href]', (elements)=>elements.map(({ src, href })=>src || href)))){
            const { match } = this.match(Request.fromRawDetails({
                url,
                sourceUrl,
                type: 'sub_frame'
            }));
            if (match) promises.push(frame.$$eval(`iframe[src="${url}"],iframe[href="${url}"]`, (iframes)=>{
                var _a;
                for (const iframe of iframes)null === (_a = null == iframe ? void 0 : iframe.parentNode) || void 0 === _a || _a.removeChild(iframe);
            }).catch(()=>{}));
        }
        await Promise.all(promises);
    }
}
var node_ponyfill = __webpack_require__("../../../../node_modules/cross-fetch/dist/node-ponyfill.js");
var node_ponyfill_default = /*#__PURE__*/ __webpack_require__.n(node_ponyfill);
const ensureDirExists = async (dir)=>{
    if (dir && !__WEBPACK_EXTERNAL_MODULE_node_fs_5ea92f0c__["default"].existsSync(dir)) await __WEBPACK_EXTERNAL_MODULE_node_fs_5ea92f0c__["default"].promises.mkdir(dir, {
        recursive: true
    });
};
const getCurrentPage = async (browser)=>{
    const { logger } = store;
    const pages = await (null == browser ? void 0 : browser.pages());
    if (!(null == pages ? void 0 : pages.length)) return {
        activePage: await (null == browser ? void 0 : browser.newPage()),
        activePageId: 0
    };
    let activePage = null;
    let activePageId = 0;
    for(let idx = pages.length - 1; idx >= 0; idx--){
        const page = pages[idx];
        const [isVisible, isHealthy] = await Promise.all([
            Promise.race([
                page.evaluate(()=>'visible' === document.visibilityState),
                delayReject(5000)
            ]).catch((_)=>false),
            Promise.race([
                page.evaluate(()=>2).then((r)=>2 === r),
                delayReject(5000)
            ]).catch((_)=>false)
        ]);
        logger.info(`[getCurrentPage]: page: ${page.url()}, pageId: ${idx}, isVisible: ${isVisible}, isHealthy: ${isHealthy}`);
        if (isVisible) {
            activePage = page;
            activePageId = idx;
            break;
        }
        if (!isVisible && isHealthy) {
            activePage = page;
            activePageId = idx;
            continue;
        }
        try {
            await Promise.race([
                page.evaluate(()=>document.title),
                delayReject(2000)
            ]);
            activePage = page;
            activePageId = idx;
            logger.debug(`Page ${idx} is still responsive, keeping it`);
            break;
        } catch (finalError) {
            logger.error(`page ${page.url()} is completely unresponsive, will close it`);
            try {
                await page.close();
            } catch (closeError) {
                logger.warn(`Failed to close page ${idx}:`, closeError);
            }
        }
    }
    if (!activePage) {
        activePage = null == pages ? void 0 : pages[0];
        activePageId = 0;
    }
    return {
        activePage,
        activePageId
    };
};
const getTabList = async (browser, activePageId)=>{
    const pages = await (null == browser ? void 0 : browser.pages());
    return await Promise.all((null == pages ? void 0 : pages.map(async (page, idx)=>({
            index: idx,
            active: idx === activePageId,
            title: await page.title(),
            url: await page.url()
        }))) || []);
};
async function ensureBrowser() {
    var _store_globalConfig_contextOptions, _store_globalConfig_launchOptions;
    const { logger } = store;
    if (store.globalBrowser) try {
        var _store_globalBrowser;
        logger.info('starting to check if browser session is closed');
        const pages = await (null === (_store_globalBrowser = store.globalBrowser) || void 0 === _store_globalBrowser ? void 0 : _store_globalBrowser.pages());
        if (!(null == pages ? void 0 : pages.length)) throw new Error('browser session is closed');
        logger.info(`detected browser session is still open: ${pages.length}`);
    } catch (error) {
        logger.warn('detected browser session closed, will reinitialize browser', error);
        store.globalBrowser = null;
        store.globalPage = null;
    }
    if (!store.globalBrowser && store.globalConfig.externalBrowser) {
        var _store_globalConfig_externalBrowser;
        store.globalBrowser = await (null === (_store_globalConfig_externalBrowser = store.globalConfig.externalBrowser) || void 0 === _store_globalConfig_externalBrowser ? void 0 : _store_globalConfig_externalBrowser.getBrowser());
        logger.info('Using external browser instance');
    }
    if (!store.globalBrowser) {
        const browser = store.globalConfig.remoteOptions ? new RemoteBrowser(store.globalConfig.remoteOptions) : new LocalBrowser();
        await browser.launch(store.globalConfig.launchOptions);
        store.globalBrowser = browser.getBrowser();
    }
    let currTabsIdx = 0;
    if (store.globalPage) {
        const { activePage, activePageId } = await getCurrentPage(store.globalBrowser);
        store.globalPage = activePage || store.globalPage;
        currTabsIdx = activePageId || currTabsIdx;
    } else {
        var _store_globalBrowser1;
        const pages = await (null === (_store_globalBrowser1 = store.globalBrowser) || void 0 === _store_globalBrowser1 ? void 0 : _store_globalBrowser1.pages());
        store.globalPage = null == pages ? void 0 : pages[0];
        currTabsIdx = 0;
    }
    if (null === (_store_globalConfig_contextOptions = store.globalConfig.contextOptions) || void 0 === _store_globalConfig_contextOptions ? void 0 : _store_globalConfig_contextOptions.userAgent) store.globalPage.setUserAgent(store.globalConfig.contextOptions.userAgent);
    const injectScriptContent = __webpack_exports__getBuildDomTreeScript();
    await store.globalPage.evaluateOnNewDocument(injectScriptContent);
    if (store.globalConfig.enableAdBlocker) try {
        await Promise.race([
            PuppeteerBlocker.fromPrebuiltAdsAndTracking(node_ponyfill_default()).then((blocker)=>blocker.enableBlockingInPage(store.globalPage)),
            new Promise((_, reject)=>setTimeout(()=>reject(new Error('Blocking In Page timeout')), 1200))
        ]);
    } catch (e) {
        logger.error('Error enabling adblocker:', e);
    }
    if (null === (_store_globalConfig_launchOptions = store.globalConfig.launchOptions) || void 0 === _store_globalConfig_launchOptions ? void 0 : _store_globalConfig_launchOptions.proxy) {
        var _store_globalConfig_launchOptions1;
        const proxy = parseProxyUrl((null === (_store_globalConfig_launchOptions1 = store.globalConfig.launchOptions) || void 0 === _store_globalConfig_launchOptions1 ? void 0 : _store_globalConfig_launchOptions1.proxy) || '');
        if (proxy.username || proxy.password) await store.globalPage.authenticate({
            username: proxy.username,
            password: proxy.password
        });
    }
    if (!store.initialBrowserSetDownloadBehavior) {
        const client = await store.globalPage.createCDPSession();
        const { outputDir } = store.globalConfig;
        await client.send('Browser.setDownloadBehavior', {
            behavior: 'allow',
            downloadPath: outputDir,
            eventsEnabled: true
        });
        client.on('Browser.downloadWillBegin', async (event)=>{
            if (event.suggestedFilename && event.url && event.guid) {
                await ensureDirExists(outputDir);
                store.downloadedFiles.push({
                    guid: event.guid,
                    url: event.url,
                    suggestedFilename: event.suggestedFilename,
                    resourceUri: `download://${event.suggestedFilename}`,
                    createdAt: new Date().toISOString(),
                    progress: 0,
                    state: 'inProgress'
                });
                logger.info(`start to download file: ${event.suggestedFilename}`);
            }
        });
        client.on('Browser.downloadProgress', (event)=>{
            const idx = store.downloadedFiles.findIndex((file)=>file.guid === event.guid);
            const downloadInfo = store.downloadedFiles[idx];
            if (downloadInfo) {
                downloadInfo.state = event.state;
                downloadInfo.progress = event.totalBytes > 0 ? event.receivedBytes / event.totalBytes * 100 : 0;
                logger.info(` [${event.guid}]: ${downloadInfo.progress.toFixed(2)}%`);
                logger.info(`: ${event.state}, : ${event.receivedBytes}/${event.totalBytes}`);
                if ('canceled' === event.state) store.downloadedFiles.splice(idx, 1);
            }
        });
        store.initialBrowserSetDownloadBehavior = true;
        logger.info('set download behavior success');
    }
    return {
        browser: store.globalBrowser,
        page: store.globalPage,
        currTabsIdx
    };
}
class context_BrowserContext {
    async getResourceContext() {
        return {
            logger: store.logger
        };
    }
    async getToolContext() {
        const { logger, globalConfig } = store;
        const initialBrowser = await ensureBrowser();
        const { browser, currTabsIdx } = initialBrowser;
        let { page } = initialBrowser;
        null == page || page.removeAllListeners('popup');
        null == page || page.on('popup', async (popup)=>{
            if (popup) {
                logger.info(`popup page: ${popup.url()}`);
                await popup.bringToFront();
                page = popup;
                store.globalPage = popup;
            }
        });
        return {
            page,
            currTabsIdx,
            browser,
            logger,
            contextOptions: globalConfig.contextOptions || {},
            buildDomTree: this.buildDomTree
        };
    }
    async buildDomTree(page) {
        const logger = store.logger;
        try {
            const existBuildDomTreeScript = await page.evaluate(()=>'function' == typeof window.buildDomTree);
            if (!existBuildDomTreeScript) {
                const injectScriptContent = __webpack_exports__getBuildDomTreeScript();
                await page.evaluate((script)=>{
                    const scriptElement = document.createElement("script");
                    scriptElement.textContent = script;
                    document.head.appendChild(scriptElement);
                }, injectScriptContent);
            }
            const rawDomTree = await page.evaluate(()=>window.buildDomTree({
                    doHighlightElements: true,
                    focusHighlightIndex: -1,
                    viewportExpansion: 0
                }));
            if (null !== rawDomTree) {
                const elementTree = __webpack_exports__parseNode(rawDomTree);
                if (null !== elementTree && elementTree instanceof __webpack_exports__DOMElementNode) {
                    const clickableElements = elementTree.clickableElementsToString();
                    store.selectorMap = __webpack_exports__createSelectorMap(elementTree);
                    return {
                        clickableElements,
                        elementTree,
                        selectorMap: store.selectorMap
                    };
                }
            }
            return null;
        } catch (error) {
            logger.error('Error building DOM tree:', error);
            return null;
        }
    }
}
function defineTool(tool) {
    return tool;
}
const screenCaptureTool = defineTool({
    name: 'browser_vision_screen_capture',
    config: {
        description: 'Take a screenshot of the current page for vision mode',
        inputSchema: {}
    },
    handle: async (ctx, _)=>{
        const { page, logger } = ctx;
        const viewport = page.viewport();
        await Promise.race([
            page.waitForNetworkIdle({
                idleTime: 1000,
                concurrency: 2
            }),
            delayReject(5000)
        ]).catch((e)=>{
            logger.warn(`Network idle timeout, continue to take screenshot, error: ${e}`);
        });
        const screenshot = await page.screenshot({
            type: 'webp',
            optimizeForSpeed: true,
            fullPage: false,
            omitBackground: false,
            encoding: 'base64'
        });
        return {
            content: [
                {
                    type: 'text',
                    text: `Screenshot taken at ${null == viewport ? void 0 : viewport.width}x${null == viewport ? void 0 : viewport.height}`
                },
                {
                    type: 'image',
                    data: screenshot,
                    mimeType: 'image/webp'
                }
            ]
        };
    }
});
const screenClickTool = defineTool({
    name: 'browser_vision_screen_click',
    config: {
        description: 'Click left mouse button on the page with vision and snapshot, before calling this tool, you should call `browser_vision_screen_capture` first only once, fallback to `browser_click` if failed',
        inputSchema: {
            factors: lib.z.array(lib.z.number()).optional().describe("Vision model coordinate system scaling factors [width_factor, height_factor] for coordinate space normalization. Transformation formula: x = (x_model * screen_width * width_factor) / width_factor y = (y_model * screen_height * height_factor) / height_factor where x_model, y_model are normalized model output coordinates (0-1), screen_width/height are screen dimensions, width_factor/height_factor are quantization factors, If the factors are unknown, leave it blank. Most models do not require this parameter."),
            x: lib.z.number().describe('X pixel coordinate'),
            y: lib.z.number().describe('Y pixel coordinate')
        }
    },
    handle: async (ctx, args)=>{
        const { page, logger, contextOptions } = ctx;
        const factors = contextOptions.factors;
        try {
            let x = args.x;
            let y = args.y;
            if (Array.isArray(factors) && factors.length > 0) {
                var _parsed_;
                const actionParserModule = await import("@ui-tars/action-parser");
                const { actionParser } = (null == actionParserModule ? void 0 : actionParserModule.default) ?? actionParserModule;
                const viewport = page.viewport();
                const prediction = `Action: click(start_box='(${args.x},${args.y})')`;
                const { parsed } = actionParser({
                    prediction,
                    factor: factors,
                    screenContext: {
                        width: (null == viewport ? void 0 : viewport.width) ?? 0,
                        height: (null == viewport ? void 0 : viewport.height) ?? 0
                    }
                });
                const { start_coords } = (null == parsed ? void 0 : null === (_parsed_ = parsed[0]) || void 0 === _parsed_ ? void 0 : _parsed_.action_inputs) ?? {};
                logger.info('[vision] start_coords', start_coords);
                x = (null == start_coords ? void 0 : start_coords[0]) ?? x;
                y = (null == start_coords ? void 0 : start_coords[1]) ?? y;
            }
            logger.info(`[browser_vision_screen_click]: (${x}, ${y}), factors: ${factors}`);
            await page.mouse.move(x, y);
            await page.mouse.down();
            await page.mouse.up();
            return {
                content: [
                    {
                        type: 'text',
                        text: `Vision click at ${args.x}, ${args.y}`
                    }
                ],
                isError: false,
                _meta: {
                    factors,
                    screenCoords: [
                        x,
                        y
                    ]
                }
            };
        } catch (error) {
            logger.error("Failed to browser_vision_screen_click: ", args, error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Error clicking on the page: ${error.message}`
                    }
                ],
                isError: true,
                _meta: {
                    factors,
                    screenCoords: []
                }
            };
        }
    }
});
const vision = [
    screenCaptureTool,
    screenClickTool
];
const downloadTool = defineTool({
    name: 'browser_get_download_list',
    skipToolContext: true,
    config: {
        description: 'Get the list of downloaded files',
        outputSchema: {
            list: lib.z.array(lib.z.object({
                guid: lib.z.string(),
                url: lib.z.string(),
                suggestedFilename: lib.z.string(),
                resourceUri: lib.z.string(),
                createdAt: lib.z.string(),
                progress: lib.z.number(),
                state: lib.z.string()
            }).partial())
        }
    },
    handle: async (_ctx, _args)=>{
        const { downloadedFiles } = store;
        const content = {
            list: downloadedFiles
        };
        return {
            isError: false,
            structuredContent: content,
            content: [
                {
                    type: 'text',
                    text: JSON.stringify(content)
                }
            ]
        };
    }
});
const download = [
    downloadTool
];
const navigateTool = defineTool({
    name: 'browser_navigate',
    config: {
        description: 'Navigate to a URL',
        inputSchema: {
            url: lib.z.string()
        }
    },
    handle: async (ctx, args)=>{
        const { page, logger, buildDomTree } = ctx;
        try {
            await page.goto(args.url);
            logger.info('navigateTo complete');
            const { clickableElements } = await buildDomTree(page) || {};
            logger.info('clickableElements', clickableElements);
            await __webpack_exports__removeHighlights(page);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Navigated to ${args.url}` + (clickableElements ? `\nclickable elements(Might be outdated, if an error occurs with the index element, use \`browser_get_clickable_elements\` to refresh it): \n${clickableElements}` : 'No clickable elements found')
                    }
                ],
                isError: false
            };
        } catch (error) {
            var _error_message;
            if (error instanceof __WEBPACK_EXTERNAL_MODULE_puppeteer_core_17481843__.TimeoutError || (null == error ? void 0 : null === (_error_message = error.message) || void 0 === _error_message ? void 0 : _error_message.includes('timeout'))) {
                logger.warn('Navigation timeout, but page might still be usable:', error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: 'Navigation timeout, but page might still be usable:'
                        }
                    ],
                    isError: false
                };
            }
            logger.error('NavigationTo failed:', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Navigation failed ${error instanceof Error ? null == error ? void 0 : error.message : error}`
                    }
                ],
                isError: true
            };
        }
    }
});
const goBackTool = defineTool({
    name: 'browser_go_back',
    config: {
        description: 'Go back to the previous page'
    },
    handle: async (ctx, args)=>{
        const { page, logger } = ctx;
        try {
            await page.goBack();
            logger.info('Navigation back completed');
            return {
                content: [
                    {
                        type: 'text',
                        text: 'Navigated back'
                    }
                ],
                isError: false
            };
        } catch (error) {
            if (error instanceof Error && error.message.includes('timeout')) {
                logger.warn('Back navigation timeout, but page might still be usable:', error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: 'Back navigation timeout, but page might still be usable:'
                        }
                    ],
                    isError: false
                };
            }
            logger.error('Could not navigate back:', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: 'Could not navigate back'
                    }
                ],
                isError: true
            };
        }
    }
});
const goForwardTool = defineTool({
    name: 'browser_go_forward',
    config: {
        description: 'Go forward to the next page'
    },
    handle: async (ctx, args)=>{
        const { page, logger } = ctx;
        try {
            await page.goForward();
            logger.info('Navigation back completed');
            return {
                content: [
                    {
                        type: 'text',
                        text: 'Navigated forward'
                    }
                ],
                isError: false
            };
        } catch (error) {
            if (error instanceof Error && error.message.includes('timeout')) {
                logger.warn('forward navigation timeout, but page might still be usable:', error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: 'forward navigation timeout, but page might still be usable:'
                        }
                    ],
                    isError: false
                };
            }
            logger.error('Could not navigate forward:', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: 'Could not navigate forward'
                    }
                ],
                isError: true
            };
        }
    }
});
const tools_navigate = [
    navigateTool,
    goBackTool,
    goForwardTool
];
const getMarkdownTool = defineTool({
    name: 'browser_get_markdown',
    config: {
        description: 'Get the markdown content of the current page',
        inputSchema: {}
    },
    handle: async (ctx, _args)=>{
        const { page, logger } = ctx;
        try {
            await Promise.race([
                page.waitForNetworkIdle({
                    idleTime: 1000,
                    concurrency: 2
                }),
                delayReject(3000)
            ]).catch((e)=>{
                logger.warn(`Network idle timeout, continue to get markdown, error: ${e}`);
            });
            const { extractContent } = await import("@agent-infra/browser-context");
            const { title, content } = await extractContent(page);
            const markdown = title + '\n' + content || '';
            logger.info(`[browser_get_markdown]: title: ${markdown}`);
            return {
                content: [
                    {
                        type: 'text',
                        text: markdown
                    }
                ],
                isError: false
            };
        } catch (error) {
            logger.error('Failed to browser_get_markdown', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Failed to get markdown: ${error.message}`
                    }
                ]
            };
        }
    }
});
const getTextTool = defineTool({
    name: 'browser_get_text',
    config: {
        description: 'Get the text content of the current page',
        inputSchema: {}
    },
    handle: async (ctx, _args)=>{
        const { page, logger } = ctx;
        try {
            const text = await page.evaluate(()=>document.body.innerText);
            return {
                content: [
                    {
                        type: 'text',
                        text
                    }
                ],
                isError: false
            };
        } catch (error) {
            logger.error('Failed to browser_get_text', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Failed to get text: ${error.message}`
                    }
                ],
                isError: true
            };
        }
    }
});
const readLinksTool = defineTool({
    name: 'browser_read_links',
    config: {
        description: 'Get all links on the current page',
        outputSchema: {
            links: lib.z.array(lib.z.object({
                text: lib.z.string(),
                href: lib.z.string()
            }))
        }
    },
    handle: async (ctx, _args)=>{
        const { page, logger } = ctx;
        try {
            const links = await page.evaluate(()=>{
                const linkElements = document.querySelectorAll('a[href]');
                return Array.from(linkElements).map((el)=>({
                        text: el.innerText,
                        href: el.getAttribute('href') || ''
                    })).filter((link)=>link.href);
            });
            return {
                content: [
                    {
                        type: 'text',
                        text: JSON.stringify(links, null, 2)
                    }
                ],
                structuredContent: {
                    links
                },
                isError: false
            };
        } catch (error) {
            logger.error('Failed to browser_read_links', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Failed to read links: ${error.message}`
                    }
                ],
                structuredContent: {
                    links: []
                },
                isError: true
            };
        }
    }
});
const tools_content = [
    getMarkdownTool,
    getTextTool,
    readLinksTool
];
const newTabTool = defineTool({
    name: 'browser_new_tab',
    config: {
        description: 'Open a new tab',
        inputSchema: {
            url: lib.z.string().describe('URL to open in the new tab')
        }
    },
    handle: async (ctx, args)=>{
        const { browser, logger } = ctx;
        try {
            const newPage = await browser.newPage();
            await newPage.goto(args.url, {
                waitUntil: []
            });
            await newPage.bringToFront();
            store.globalBrowser = browser;
            store.globalPage = newPage;
            return {
                content: [
                    {
                        type: 'text',
                        text: `Opened new tab with URL: ${args.url}`
                    }
                ],
                isError: false
            };
        } catch (error) {
            logger.error('Failed to open new tab:', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Failed to open new tab: ${error.message}`
                    }
                ],
                isError: true
            };
        }
    }
});
const tabListTool = defineTool({
    name: 'browser_tab_list',
    config: {
        description: 'Get the list of tabs',
        outputSchema: {
            tabList: lib.z.array(lib.z.object({
                index: lib.z.number(),
                active: lib.z.boolean(),
                title: lib.z.string(),
                url: lib.z.string()
            }))
        }
    },
    handle: async (ctx)=>{
        const { browser, page: activePage, currTabsIdx: activePageId, logger } = ctx;
        try {
            const tabListList = await getTabList(browser, activePageId);
            const tabListSummary = (null == tabListList ? void 0 : tabListList.length) > 0 ? `Current Tab: [${activePageId}] ${await (null == activePage ? void 0 : activePage.title())}\nAll Tabs: \n${tabListList.map((tab)=>`[${tab.index}] Title: ${tab.title} (URL: ${tab.url})`).join('\n')}` : '';
            return {
                content: [
                    {
                        type: 'text',
                        text: tabListSummary
                    }
                ],
                isError: false,
                structuredContent: {
                    tabList: tabListList
                }
            };
        } catch (error) {
            logger.error('Failed to browser_tab_list:', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: "Failed to get tab list"
                    }
                ],
                structuredContent: {
                    tabList: []
                }
            };
        }
    }
});
const switchTabTool = defineTool({
    name: 'browser_switch_tab',
    config: {
        description: 'Switch to a specific tab',
        inputSchema: {
            index: lib.z.number().describe('Tab index to switch to')
        }
    },
    handle: async (ctx, args)=>{
        const { browser, currTabsIdx: activePageId, logger } = ctx;
        try {
            const pages = await browser.pages();
            if (args.index >= 0 && args.index < pages.length) {
                await pages[args.index].bringToFront();
                const tabListList = await getTabList(browser, activePageId);
                const tabListSummary = (null == tabListList ? void 0 : tabListList.length) > 0 ? `All Tabs: \n${tabListList.map((tab)=>`[${tab.index}] ${tab.title} (${tab.url})`).join('\n')}` : '';
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Switched to tab ${args.index}, ${tabListSummary}`
                        }
                    ],
                    isError: false
                };
            }
            return {
                content: [
                    {
                        type: 'text',
                        text: `Invalid tab index: ${args.index}`
                    }
                ],
                isError: true
            };
        } catch (error) {
            logger.error('Failed to browser_switch_tab:', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Failed to switch tab: ${error.message}`
                    }
                ],
                isError: true
            };
        }
    }
});
const closeTabTool = defineTool({
    name: 'browser_close_tab',
    config: {
        description: 'Close the current tab'
    },
    handle: async (ctx)=>{
        const { page, currTabsIdx, logger } = ctx;
        try {
            await page.close();
            if (page === store.globalPage) store.globalPage = null;
            return {
                content: [
                    {
                        type: 'text',
                        text: `Closed current tab [${currTabsIdx}]`
                    }
                ],
                isError: false
            };
        } catch (error) {
            logger.error(`Failed to browser_close_tab: [${currTabsIdx}]`, error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Failed to close tab [${currTabsIdx}]: ${error.message}`
                    }
                ],
                isError: true
            };
        }
    }
});
const tools_tabs = [
    newTabTool,
    tabListTool,
    switchTabTool,
    closeTabTool
];
const formInputFillTool = defineTool({
    name: 'browser_form_input_fill',
    config: {
        description: "Fill out an input field, before using the tool, Either 'index' or 'selector' must be provided",
        inputSchema: {
            selector: lib.z.string().optional().describe('CSS selector for input field, priority use index, if index is not provided, use selector'),
            index: lib.z.number().optional().describe('Index of the element to fill'),
            value: lib.z.string().describe('Value to fill'),
            clear: lib.z.boolean().optional().default(false).describe('Whether to clear existing text before filling')
        }
    },
    handle: async (ctx, args)=>{
        const { page, logger } = ctx;
        try {
            let element = null;
            let targetIdentifier = '';
            if (void 0 !== args.index) {
                var _store_selectorMap;
                const elementNode = null === (_store_selectorMap = store.selectorMap) || void 0 === _store_selectorMap ? void 0 : _store_selectorMap.get(Number(null == args ? void 0 : args.index));
                if ((null == elementNode ? void 0 : elementNode.highlightIndex) !== void 0) await __webpack_exports__removeHighlights(page);
                element = await locateElement(page, elementNode);
                targetIdentifier = `index ${args.index}`;
            } else {
                if (!args.selector) return {
                    content: [
                        {
                            type: 'text',
                            text: 'Either selector or index must be provided'
                        }
                    ],
                    isError: true
                };
                await page.waitForSelector(args.selector, {
                    timeout: 15000
                });
                element = await page.$(args.selector);
                targetIdentifier = `selector ${args.selector}`;
            }
            if (!element) return {
                content: [
                    {
                        type: 'text',
                        text: `No form input found for ${targetIdentifier}`
                    }
                ],
                isError: true
            };
            if (args.clear) {
                await element.click({
                    clickCount: 3
                });
                await page.keyboard.press('Backspace');
            }
            await element.type(args.value);
            const inputValue = await element.evaluate((el)=>(null == el ? void 0 : el.value) || (null == el ? void 0 : el.textContent) || '');
            logger.info('inputValue', inputValue);
            const isValidInput = (null == args ? void 0 : args.value) === '' ? '' === inputValue : inputValue.includes(args.value);
            return {
                content: [
                    {
                        type: 'text',
                        text: `${isValidInput ? 'Successfully' : 'Maybe failed'} filled ${targetIdentifier} with: "${args.value}"${args.clear ? ' (cleared existing text)' : ''}`
                    }
                ],
                isError: false
            };
        } catch (error) {
            logger.error('Failed to browser_form_input_fill: ', args, error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Failed to fill ${args.selector ? `selector ${args.selector}` : `index ${args.index}`}: ${error.message}`
                    }
                ],
                isError: true
            };
        }
    }
});
const tools_action = [
    formInputFillTool
];
const evaluateTool = defineTool({
    name: 'browser_evaluate',
    config: {
        description: 'Execute JavaScript in the browser console',
        inputSchema: {
            script: lib.z.string().describe('JavaScript code to execute, () => { /* code */ }')
        }
    },
    handle: async (ctx, args)=>{
        const { page, logger } = ctx;
        try {
            const result = await page.evaluate(`(${args.script})()`);
            logger.info('[browser_evaluate]', result);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Execution result:\n${JSON.stringify(result, null, 2)}\n`
                    }
                ],
                isError: false
            };
        } catch (error) {
            logger.error('Failed to browser_evaluate', error);
            return {
                content: [
                    {
                        type: 'text',
                        text: `Script execution failed: ${error.message}`
                    }
                ],
                isError: true
            };
        }
    }
});
const tools_evaluate = [
    evaluateTool
];
function setConfig(config = {}) {
    store.globalConfig = lodash_merge_default()({}, store.globalConfig, config);
    if (config.logger) store.logger = config.logger;
}
function getConfig() {
    return store.globalConfig;
}
async function setInitialBrowser(_browser, _page) {
    const { logger } = store;
    if (_browser) {
        logger.info('Using global browser');
        store.globalBrowser = _browser;
    }
    if (_page) store.globalPage = _page;
    return {
        browser: store.globalBrowser,
        page: store.globalPage
    };
}
const getBrowser = ()=>({
        browser: store.globalBrowser,
        page: store.globalPage
    });
const toolsMap = defineTools({
    browser_screenshot: {
        name: 'browser_screenshot',
        description: 'Take a screenshot of the current page or a specific element',
        inputSchema: lib.z.object({
            name: lib.z.string().optional().describe('Name for the screenshot'),
            selector: lib.z.string().optional().describe('CSS selector for element to screenshot'),
            index: lib.z.number().optional().describe('index of the element to screenshot'),
            width: lib.z.number().optional().describe('Width in pixels (default: viewport width)'),
            height: lib.z.number().optional().describe('Height in pixels (default: viewport height)'),
            fullPage: lib.z.boolean().optional().describe('Full page screenshot (default: false)'),
            highlight: lib.z.boolean().optional().default(false).describe('Highlight the element')
        })
    },
    browser_click: {
        name: 'browser_click',
        description: 'Click an element on the page, before using the tool, use `browser_get_clickable_elements` to get the index of the element, but not call `browser_get_clickable_elements` multiple times',
        inputSchema: lib.z.object({
            index: lib.z.number().optional().describe('Index of the element to click')
        })
    },
    browser_select: {
        name: 'browser_select',
        description: "Select an element on the page with index, Either 'index' or 'selector' must be provided",
        inputSchema: lib.z.object({
            index: lib.z.number().optional().describe('Index of the element to select'),
            selector: lib.z.string().optional().describe('CSS selector for element to select'),
            value: lib.z.string().describe('Value to select')
        })
    },
    browser_hover: {
        name: 'browser_hover',
        description: "Hover an element on the page, Either 'index' or 'selector' must be provided",
        inputSchema: lib.z.object({
            index: lib.z.number().optional().describe('Index of the element to hover'),
            selector: lib.z.string().optional().describe('CSS selector for element to hover')
        })
    },
    browser_get_clickable_elements: {
        name: 'browser_get_clickable_elements',
        description: "Get the clickable or hoverable or selectable elements on the current page, don't call this tool multiple times"
    },
    browser_scroll: {
        name: 'browser_scroll',
        description: 'Scroll the page',
        inputSchema: lib.z.object({
            amount: lib.z.number().optional().describe('Pixels to scroll (positive for down, negative for up), if the amount is not provided, scroll to the bottom of the page')
        })
    },
    browser_close: {
        name: 'browser_close',
        description: 'Close the browser when the task is done and the browser is not needed anymore'
    },
    browser_press_key: {
        name: 'browser_press_key',
        description: 'Press a key on the keyboard',
        inputSchema: lib.z.object({
            key: lib.z["enum"](keyInputValues).describe(`Name of the key to press or a character to generate, such as ${keyInputValues.join(', ')}`)
        })
    }
});
const handleToolCall = async (ctx, { name, arguments: toolArgs })=>{
    const toolCtx = await ctx.getToolContext();
    if (!(null == toolCtx ? void 0 : toolCtx.page)) return {
        content: [
            {
                type: 'text',
                text: 'Page not found'
            }
        ],
        isError: true
    };
    const { page, browser, logger } = toolCtx;
    const handlers = {
        browser_screenshot: async (args)=>{
            var _page_viewport, _page_viewport1;
            try {
                if (args.highlight) await ctx.buildDomTree(page);
                else await __webpack_exports__removeHighlights(page);
            } catch (error) {
                logger.warn('[browser_screenshot] Error building DOM tree:', error);
            }
            const width = args.width ?? (null === (_page_viewport = page.viewport()) || void 0 === _page_viewport ? void 0 : _page_viewport.width) ?? 800;
            const height = args.height ?? (null === (_page_viewport1 = page.viewport()) || void 0 === _page_viewport1 ? void 0 : _page_viewport1.height) ?? 600;
            await page.setViewport({
                width,
                height
            });
            let screenshot;
            if (args.selector) {
                var _this;
                screenshot = await (args.selector ? null === (_this = await page.$(args.selector)) || void 0 === _this ? void 0 : _this.screenshot({
                    encoding: 'base64'
                }) : void 0);
            } else if (void 0 !== args.index) {
                var _store_selectorMap;
                const elementNode = null === (_store_selectorMap = store.selectorMap) || void 0 === _store_selectorMap ? void 0 : _store_selectorMap.get(Number(null == args ? void 0 : args.index));
                const element = await locateElement(page, elementNode);
                screenshot = await (element ? element.screenshot({
                    encoding: 'base64'
                }) : void 0);
            }
            screenshot = screenshot || await page.screenshot({
                encoding: 'base64',
                fullPage: args.fullPage ?? false
            });
            if (!screenshot) return {
                content: [
                    {
                        type: 'text',
                        text: `Element not found: ${args.selector || args.index}`
                    }
                ],
                isError: true
            };
            const name = (null == args ? void 0 : args.name) ?? 'undefined';
            resources_screenshots.set(name, screenshot);
            const dimensions = args.fullPage ? await page.evaluate(()=>({
                    width: Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth, document.body.scrollWidth),
                    height: Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight, document.body.scrollHeight)
                })) : {
                width,
                height
            };
            return {
                content: [
                    {
                        type: 'text',
                        text: args.fullPage ? `Screenshot of the whole page taken at ${dimensions.width}x${dimensions.height}` : `Screenshot '${name}' taken at ${dimensions.width}x${dimensions.height}`
                    },
                    {
                        type: 'image',
                        data: screenshot,
                        mimeType: 'image/png'
                    }
                ],
                isError: false
            };
        },
        browser_get_clickable_elements: async (args)=>{
            if (!page) return {
                content: [
                    {
                        type: 'text',
                        text: 'Page not found'
                    }
                ],
                isError: true
            };
            try {
                const { clickableElements } = await ctx.buildDomTree(page) || {};
                await __webpack_exports__removeHighlights(page);
                if (clickableElements) return {
                    content: [
                        {
                            type: 'text',
                            text: clickableElements
                        }
                    ],
                    isError: false
                };
                return {
                    content: [
                        {
                            type: 'text',
                            text: 'Failed to parse DOM tree'
                        }
                    ],
                    isError: false
                };
            } catch (error) {
                logger.error('Failed to browser_get_clickable_elements:', error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: error.message
                        }
                    ],
                    isError: true
                };
            }
        },
        browser_click: async (args)=>{
            try {
                const downloadsBefore = store.downloadedFiles.length;
                let element = null;
                if ((null == args ? void 0 : args.index) === void 0) return {
                    content: [
                        {
                            type: 'text',
                            text: `Element index ${null == args ? void 0 : args.index} not found`
                        }
                    ],
                    isError: true
                };
                {
                    var _store_selectorMap;
                    const elementNode = null === (_store_selectorMap = store.selectorMap) || void 0 === _store_selectorMap ? void 0 : _store_selectorMap.get(Number(null == args ? void 0 : args.index));
                    if ((null == elementNode ? void 0 : elementNode.highlightIndex) !== void 0) await __webpack_exports__removeHighlights(page);
                    element = await locateElement(page, elementNode);
                }
                try {
                    await Promise.race([
                        null == element ? void 0 : element.click(),
                        new Promise((_, reject)=>setTimeout(()=>reject(new Error('Click timeout')), 5000))
                    ]);
                    await delay(200);
                    const currentDownloadSuggestion = getDownloadSuggestion(downloadsBefore, store.downloadedFiles, store.globalConfig.outputDir);
                    return {
                        content: [
                            {
                                type: 'text',
                                text: `Clicked element: ${args.index}${currentDownloadSuggestion}`
                            }
                        ],
                        isError: false
                    };
                } catch (error) {
                    logger.error('Failed to click element, trying again', error);
                    try {
                        await (null == element ? void 0 : element.evaluate((el)=>el.click()));
                        await delay(200);
                        const currentDownloadSuggestion = getDownloadSuggestion(downloadsBefore, store.downloadedFiles, store.globalConfig.outputDir);
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Clicked element: ${args.index}${currentDownloadSuggestion}`
                                }
                            ],
                            isError: false
                        };
                    } catch (secondError) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Failed to click element: ${secondError instanceof Error ? secondError.message : String(secondError)}`
                                }
                            ],
                            isError: true
                        };
                    }
                }
            } catch (error) {
                logger.error(`Failed to browser_click: ${args.index}`, error);
                return {
                    isError: true,
                    content: [
                        {
                            type: 'text',
                            text: `Failed to click element: ${args.index}. Error: ${error instanceof Error ? error.message : String(error)}`
                        }
                    ]
                };
            }
        },
        browser_select: async (args)=>{
            try {
                if (void 0 !== args.index) {
                    var _store_selectorMap;
                    const elementNode = null === (_store_selectorMap = store.selectorMap) || void 0 === _store_selectorMap ? void 0 : _store_selectorMap.get(Number(null == args ? void 0 : args.index));
                    if ((null == elementNode ? void 0 : elementNode.highlightIndex) !== void 0) await __webpack_exports__removeHighlights(page);
                    const element = await locateElement(page, elementNode);
                    if (!element) return {
                        content: [
                            {
                                type: 'text',
                                text: 'No form input found'
                            }
                        ],
                        isError: true
                    };
                    await (null == element ? void 0 : element.select(args.value));
                } else {
                    if (!args.selector) return {
                        content: [
                            {
                                type: 'text',
                                text: `No selector ${args.selector} or index ${args.index} provided`
                            }
                        ],
                        isError: true
                    };
                    await page.waitForSelector(args.selector);
                    await page.select(args.selector, args.value);
                }
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Selected ${args.selector ? args.selector : args.index} with: ${args.value}`
                        }
                    ],
                    isError: false
                };
            } catch (error) {
                logger.error(`Failed to browser_select: ${args.selector ? args.selector : args.index}`, error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Failed to select ${args.selector ? args.selector : args.index}: ${error.message}`
                        }
                    ],
                    isError: true
                };
            }
        },
        browser_hover: async (args)=>{
            try {
                if (void 0 !== args.index) {
                    var _store_selectorMap;
                    const elementNode = null === (_store_selectorMap = store.selectorMap) || void 0 === _store_selectorMap ? void 0 : _store_selectorMap.get(Number(null == args ? void 0 : args.index));
                    if ((null == elementNode ? void 0 : elementNode.highlightIndex) !== void 0) await __webpack_exports__removeHighlights(page);
                    const element = await locateElement(page, elementNode);
                    if (!element) return {
                        content: [
                            {
                                type: 'text',
                                text: 'No element found'
                            }
                        ],
                        isError: true
                    };
                    await (null == element ? void 0 : element.hover());
                } else {
                    if (!args.selector) return {
                        content: [
                            {
                                type: 'text',
                                text: `No selector ${args.selector} or index ${args.index} provided`
                            }
                        ],
                        isError: true
                    };
                    await page.waitForSelector(args.selector);
                    await page.hover(args.selector);
                }
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Hovered ${args.selector ? args.selector : args.index}`
                        }
                    ],
                    isError: false
                };
            } catch (error) {
                logger.error(`Failed to hover: ${args.selector ? args.selector : args.index}`, error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Failed to hover ${args.selector ? args.selector : args.index}: ${error.message}`
                        }
                    ],
                    isError: true
                };
            }
        },
        browser_scroll: async (args)=>{
            try {
                const scrollResult = await page.evaluate((amount)=>{
                    const beforeScrollY = window.scrollY;
                    if (amount) window.scrollBy(0, amount);
                    else window.scrollBy(0, window.innerHeight);
                    const actualScroll = window.scrollY - beforeScrollY;
                    const scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
                    const scrollTop = window.scrollY;
                    const clientHeight = window.innerHeight || document.documentElement.clientHeight;
                    const isAtBottom = Math.abs(scrollHeight - scrollTop - clientHeight) <= 1;
                    return {
                        actualScroll,
                        isAtBottom
                    };
                }, args.amount);
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Scrolled ${scrollResult.actualScroll} pixels. ${scrollResult.isAtBottom ? 'Reached the bottom of the page.' : 'Did not reach the bottom of the page.'}`
                        }
                    ],
                    isError: false
                };
            } catch (error) {
                logger.error(`Failed to browser_scroll: ${args.amount}`, error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Failed to scroll: ${args.amount}`
                        }
                    ],
                    isError: true
                };
            }
        },
        browser_close: async (args)=>{
            try {
                await (null == browser ? void 0 : browser.close());
                store.globalBrowser = null;
                store.globalPage = null;
                store.downloadedFiles = [];
                store.initialBrowserSetDownloadBehavior = false;
                return {
                    content: [
                        {
                            type: 'text',
                            text: 'Closed browser'
                        }
                    ],
                    isError: false
                };
            } catch (error) {
                logger.error("Failed to browser_close", error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Failed to close browser: ${error.message}`
                        }
                    ],
                    isError: true
                };
            }
        },
        browser_press_key: async (args)=>{
            try {
                await page.keyboard.press(args.key);
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Pressed key: ${args.key}`
                        }
                    ],
                    isError: false
                };
            } catch (error) {
                logger.error("Failed to browser_press_key", error);
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Failed to press key: ${args.key}`
                        }
                    ],
                    isError: true
                };
            }
        }
    };
    if (handlers[name]) return handlers[name](toolArgs);
    return {
        content: [
            {
                type: 'text',
                text: `Unknown tool: ${name}`
            }
        ],
        isError: true
    };
};
function createServer(config = {}) {
    setConfig(config);
    const server = new __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_mcp_js_2c42c5d0__.McpServer({
        name: 'Web Browser',
        version: "1.2.20"
    }, {
        capabilities: {
            logging: {}
        }
    });
    const mergedToolsMap = {
        ...toolsMap
    };
    const ctx = new context_BrowserContext();
    const newTools = [
        ...tools_navigate,
        ...tools_action,
        ...tools_content,
        ...tools_tabs,
        ...tools_evaluate,
        ...config.vision ? vision : [],
        ...download
    ];
    newTools.forEach((tool)=>{
        server.registerTool(tool.name, tool.config, async (args)=>{
            if (tool.skipToolContext) return tool.handle(null, args);
            const toolCtx = await ctx.getToolContext();
            if (!(null == toolCtx ? void 0 : toolCtx.page)) return {
                content: [
                    {
                        type: 'text',
                        text: 'Page not found'
                    }
                ],
                isError: true
            };
            return tool.handle(toolCtx, args);
        });
    });
    Object.entries(mergedToolsMap).forEach(([name, tool])=>{
        if (null == tool ? void 0 : tool.inputSchema) {
            var _tool_inputSchema, _tool_inputSchema1;
            server.tool(name, tool.description, (null === (_tool_inputSchema = tool.inputSchema) || void 0 === _tool_inputSchema ? void 0 : _tool_inputSchema.innerType) ? tool.inputSchema.innerType().shape : null === (_tool_inputSchema1 = tool.inputSchema) || void 0 === _tool_inputSchema1 ? void 0 : _tool_inputSchema1.shape, async (args)=>await handleToolCall(ctx, {
                    name,
                    arguments: args
                }));
        } else server.tool(name, tool.description, async (args)=>await handleToolCall(ctx, {
                name,
                arguments: args
            }));
    });
    const resourceCtx = {
        logger: store.logger
    };
    registerResources(server, resourceCtx);
    return server;
}
var __webpack_exports__BaseLogger = __WEBPACK_EXTERNAL_MODULE__agent_infra_logger_ddae3da2__.BaseLogger;
export { context_BrowserContext as BrowserContext, createServer, getBrowser, getConfig, getScreenshots, setConfig, setInitialBrowser, toolsMap, __webpack_exports__BaseLogger as BaseLogger };
